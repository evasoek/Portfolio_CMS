#!/usr/bin/env php
<?php
/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view
 * the license that is located at the bottom of this file.
 */

// Avoid APC causing random fatal errors per https://github.com/composer/composer/issues/264
if (extension_loaded('apc') && ini_get('apc.enable_cli') && ini_get('apc.cache_by_default')) {
    if (version_compare(phpversion('apc'), '3.0.12', '>=')) {
        ini_set('apc.cache_by_default', 0);
    } else {
        fwrite(STDERR, 'Warning: APC <= 3.0.12 may cause fatal errors when running composer commands.'.PHP_EOL);
        fwrite(STDERR, 'Update APC, or set apc.enable_cli or apc.cache_by_default to 0 in your php.ini.'.PHP_EOL);
    }
}

Phar::mapPhar('composer.phar');
define('COMPOSER_DEV_WARNING_TIME', 1438008732);
require 'phar://composer.phar/bin/composer';

__HALT_COMPILER(); ?>
}u  i         composer.phar    +   src/Composer/Autoload/AutoloadGenerator.phpÄE  ú+gUÄE  ª26 ∂      +   src/Composer/Autoload/ClassMapGenerator.php˚  ú+gU˚  ∏Nj∂         src/Composer/Cache.phpô  ú+gUô  ¿ŒKH∂      %   src/Composer/Command/AboutCommand.phpº  ú+gUº  ZFèá∂      '   src/Composer/Command/ArchiveCommand.php  ú+gU  ∏Uˆ™∂      *   src/Composer/Command/ClearCacheCommand.phpZ  ú+gUZ  âÏ>∂          src/Composer/Command/Command.phpâ  ú+gUâ  µvJ∂      &   src/Composer/Command/ConfigCommand.phpØ5  ú+gUØ5  §?0B∂      -   src/Composer/Command/CreateProjectCommand.php	2  ú+gU	2  DfL‰∂      '   src/Composer/Command/DependsCommand.phpÑ
  ú+gUÑ
  »!"∂      (   src/Composer/Command/DiagnoseCommand.phpÖ9  ú+gUÖ9  ™éû∂      ,   src/Composer/Command/DumpAutoloadCommand.phpˇ  ú+gUˇ  FZ∂      &   src/Composer/Command/GlobalCommand.php  ú+gU  ©®@ï∂      $   src/Composer/Command/HomeCommand.php+  ú+gU+  ^ö∂      $   src/Composer/Command/InitCommand.php`8  ú+gU`8  …?w∂      '   src/Composer/Command/InstallCommand.php#  ú+gU#  =J%∂      (   src/Composer/Command/LicensesCommand.phpû  ú+gUû  }Ï¥ø∂      &   src/Composer/Command/RemoveCommand.php^  ú+gU^  $îûy∂      '   src/Composer/Command/RequireCommand.php¬  ú+gU¬  9y∏B∂      )   src/Composer/Command/RunScriptCommand.phpê  ú+gUê  s£4∂      +   src/Composer/Command/ScriptAliasCommand.php≤  ú+gU≤  Ò«$Ω∂      &   src/Composer/Command/SearchCommand.phpl	  ú+gUl	  ∂K4∂      *   src/Composer/Command/SelfUpdateCommand.php#  ú+gU#  °#à)∂      $   src/Composer/Command/ShowCommand.phpÚ0  ú+gUÚ0  Ÿì˝∂      &   src/Composer/Command/StatusCommand.phpo	  ú+gUo	  ó≤Œ∂      &   src/Composer/Command/UpdateCommand.php*  ú+gU*  Õ
#√∂      (   src/Composer/Command/ValidateCommand.php  ú+gU  ‰ºC∂         src/Composer/Composer.php)	  ú+gU)	  BäHÓ∂         src/Composer/Config.phpÌ  ú+gUÌ  ˛åº&∂      -   src/Composer/Config/ConfigSourceInterface.phpÆ  ú+gUÆ  6J[™∂      (   src/Composer/Config/JsonConfigSource.phpì  ú+gUì  *ÌﬁT∂      $   src/Composer/Console/Application.phpD!  ú+gUD!  K¨˝∂      ,   src/Composer/Console/HtmlOutputFormatter.phpŒ  ú+gUŒ  ‡πüÑ∂      /   src/Composer/DependencyResolver/DebugSolver.phpâ  ú+gUâ  £“≠Ö∂      -   src/Composer/DependencyResolver/Decisions.phpQ  ú+gUQ  ?ò¨$∂      1   src/Composer/DependencyResolver/DefaultPolicy.php  ú+gU  âho≥∂      >   src/Composer/DependencyResolver/Operation/InstallOperation.phpC  ú+gUC  ¥\ı*∂      I   src/Composer/DependencyResolver/Operation/MarkAliasInstalledOperation.php–  ú+gU–  xUZa∂      K   src/Composer/DependencyResolver/Operation/MarkAliasUninstalledOperation.php÷  ú+gU÷  _i«´∂      @   src/Composer/DependencyResolver/Operation/OperationInterface.php”   ú+gU”   Ÿ‚&‰∂      =   src/Composer/DependencyResolver/Operation/SolverOperation.phpÎ  ú+gUÎ  ƒß›î∂      @   src/Composer/DependencyResolver/Operation/UninstallOperation.phpI  ú+gUI  F˚¬…∂      =   src/Composer/DependencyResolver/Operation/UpdateOperation.phph  ú+gUh  ˆS’]∂      3   src/Composer/DependencyResolver/PolicyInterface.phpí  ú+gUí  n∞&≥∂      (   src/Composer/DependencyResolver/Pool.php˝!  ú+gU˝!  Ü6∂      +   src/Composer/DependencyResolver/Problem.php+  ú+gU+  ò:$ç∂      +   src/Composer/DependencyResolver/Request.phpú  ú+gUú  fDC∂      (   src/Composer/DependencyResolver/Rule.php$  ú+gU$  K¸»˝∂      +   src/Composer/DependencyResolver/RuleSet.php%
  ú+gU%
  9z	∂      4   src/Composer/DependencyResolver/RuleSetGenerator.php]  ú+gU]  4ì—9∂      3   src/Composer/DependencyResolver/RuleSetIterator.php  ú+gU  }ı«˘∂      2   src/Composer/DependencyResolver/RuleWatchChain.phpi  ú+gUi  hÔö,∂      2   src/Composer/DependencyResolver/RuleWatchGraph.php‹  ú+gU‹  â8∂      1   src/Composer/DependencyResolver/RuleWatchNode.phpÁ  ú+gUÁ  óﬁ»∂      *   src/Composer/DependencyResolver/Solver.php
7  ú+gU
7  I©-!∂      6   src/Composer/DependencyResolver/SolverBugException.phpò  ú+gUò  "qN∂      ;   src/Composer/DependencyResolver/SolverProblemsException.php&  ú+gU&  ∂Æ¯∂      /   src/Composer/DependencyResolver/Transaction.php‘  ú+gU‘  †3Ù∂      -   src/Composer/Downloader/ArchiveDownloader.php†  ú+gU†  –∂Tj∂      1   src/Composer/Downloader/ChangeReportInterface.phpÃ   ú+gUÃ   Ø‡®ø∂      +   src/Composer/Downloader/DownloadManager.phpë  ú+gUë  'o≈b∂      /   src/Composer/Downloader/DownloaderInterface.php   ú+gU   gs!l∂      *   src/Composer/Downloader/FileDownloader.php¶  ú+gU¶  cãŒ∂      /   src/Composer/Downloader/FilesystemException.php  ú+gU  ]TΩà∂      )   src/Composer/Downloader/GitDownloader.phpw#  ú+gUw#  ùÒ"R∂      *   src/Composer/Downloader/GzipDownloader.php»  ú+gU»  ≠‰ﬂ–∂      (   src/Composer/Downloader/HgDownloader.phpd  ú+gUd  ´.Ω∂      0   src/Composer/Downloader/PearPackageExtractor.phpa  ú+gUa  @‘ÿ#∂      .   src/Composer/Downloader/PerforceDownloader.phpx  ú+gUx  <Èc∂      *   src/Composer/Downloader/PharDownloader.phpÂ   ú+gUÂ   ﬁ…Á∂      )   src/Composer/Downloader/RarDownloader.phpﬂ  ú+gUﬂ  æº∂      )   src/Composer/Downloader/SvnDownloader.php]  ú+gU]  Û<l∂      )   src/Composer/Downloader/TarDownloader.php„   ú+gU„   ÕíX?∂      .   src/Composer/Downloader/TransportException.phpñ  ú+gUñ  h"Br∂      )   src/Composer/Downloader/VcsDownloader.php˜  ú+gU˜  ´ëﬂÚ∂      )   src/Composer/Downloader/ZipDownloader.phpC  ú+gUC  ]^+∂      &   src/Composer/EventDispatcher/Event.php†  ú+gU†  ±ôjÔ∂      0   src/Composer/EventDispatcher/EventDispatcher.phpö  ú+gUö  W∂      9   src/Composer/EventDispatcher/EventSubscriberInterface.php©   ú+gU©   h∑0∂         src/Composer/Factory.php-  ú+gU-  Û~†õ∂         src/Composer/IO/BaseIO.phpp  ú+gUp  »NÒZ∂         src/Composer/IO/BufferIO.php  ú+gU  hv·∂         src/Composer/IO/ConsoleIO.phph  ú+gUh  ø*]≈∂         src/Composer/IO/IOInterface.phpÜ  ú+gUÜ  
û’8∂         src/Composer/IO/NullIO.php≥  ú+gU≥  ~1ƒ∂         src/Composer/Installer.phpˇ~  ú+gUˇ~  ÏÌw∂      .   src/Composer/Installer/InstallationManager.php@  ú+gU@  õˆ´∂      )   src/Composer/Installer/InstallerEvent.php  ú+gU  l‘zi∂      *   src/Composer/Installer/InstallerEvents.phpﬁ   ú+gUﬁ   Ïü@G∂      -   src/Composer/Installer/InstallerInterface.php≈  ú+gU≈  HSì°∂      +   src/Composer/Installer/LibraryInstaller.phpâ  ú+gUâ  ÜÉ≠∂      /   src/Composer/Installer/MetapackageInstaller.phpú  ú+gUú  ∆≈!∂      (   src/Composer/Installer/NoopInstaller.php+  ú+gU+  ¿∑M}∂      '   src/Composer/Installer/PackageEvent.phpâ  ú+gUâ  ë:†∂      (   src/Composer/Installer/PackageEvents.php∏  ú+gU∏  dbÿs∂      (   src/Composer/Installer/PearInstaller.phpV  ú+gUV  ùz∂      *   src/Composer/Installer/PluginInstaller.phpJ  ú+gUJ  ´ËV∂      +   src/Composer/Installer/ProjectInstaller.php  ú+gU  *0@P∂         src/Composer/Json/JsonFile.php   ú+gU   í‹˛∂      #   src/Composer/Json/JsonFormatter.php  ú+gU  cñ]Y∂      %   src/Composer/Json/JsonManipulator.php*  ú+gU*  r%∂      -   src/Composer/Json/JsonValidationException.php\  ú+gU\  .XÛ‹∂      %   src/Composer/Package/AliasPackage.php  ú+gU  R≥∂–∂      7   src/Composer/Package/Archiver/ArchivableFilesFinder.phpø  ú+gUø  écEl∂      0   src/Composer/Package/Archiver/ArchiveManager.php'  ú+gU'  ÈâÙ∂      3   src/Composer/Package/Archiver/ArchiverInterface.phpÔ   ú+gUÔ   < ∏∂      3   src/Composer/Package/Archiver/BaseExcludeFilter.phpë  ú+gUë  M˘∂      7   src/Composer/Package/Archiver/ComposerExcludeFilter.php  ú+gU  ãSZ0∂      2   src/Composer/Package/Archiver/GitExcludeFilter.phpw  ú+gUw  LgUª∂      1   src/Composer/Package/Archiver/HgExcludeFilter.php  ú+gU  ~î∏∂      .   src/Composer/Package/Archiver/PharArchiver.php[  ú+gU[   5Õ¯∂      $   src/Composer/Package/BasePackage.phpM  ú+gUM  ∑%˛∂      (   src/Composer/Package/CompletePackage.phpˇ  ú+gUˇ  o+„	∂      1   src/Composer/Package/CompletePackageInterface.phpı  ú+gUı  ¶ ÅÚ∂      +   src/Composer/Package/Dumper/ArrayDumper.phpÏ  ú+gUÏ  ™ñÊ∂         src/Composer/Package/Link.php*  ú+gU*  _íÖ∂      7   src/Composer/Package/LinkConstraint/EmptyConstraint.phpÍ  ú+gUÍ   Ïæ∂      ?   src/Composer/Package/LinkConstraint/LinkConstraintInterface.php  ú+gU  Â˛á¢∂      7   src/Composer/Package/LinkConstraint/MultiConstraint.phpg  ú+gUg  s3∂      :   src/Composer/Package/LinkConstraint/SpecificConstraint.phpp  ú+gUp  _ÑàY∂      9   src/Composer/Package/LinkConstraint/VersionConstraint.php…  ú+gU…  y?≥ÿ∂      +   src/Composer/Package/Loader/ArrayLoader.php  ú+gU  I ˚À∂      7   src/Composer/Package/Loader/InvalidPackageException.phpE  ú+gUE  xbæ∂      *   src/Composer/Package/Loader/JsonLoader.php˘  ú+gU˘  !~à{∂      /   src/Composer/Package/Loader/LoaderInterface.php≤   ú+gU≤   ¶}˙Œ∂      1   src/Composer/Package/Loader/RootPackageLoader.phpS"  ú+gUS"  ®<∂      5   src/Composer/Package/Loader/ValidatingArrayLoader.phpÈ/  ú+gUÈ/  }Å±≤∂         src/Composer/Package/Locker.phpÚ  ú+gUÚ  ¨Ô$∂          src/Composer/Package/Package.phpƒ  ú+gUƒ  ÑÙ∂      )   src/Composer/Package/PackageInterface.php_  ú+gU_  ÊàπÇ∂      )   src/Composer/Package/RootAliasPackage.phpy  ú+gUy  ¿E'∂      $   src/Composer/Package/RootPackage.phpn  ú+gUn  ·ACO∂      -   src/Composer/Package/RootPackageInterface.php¥  ú+gU¥  ÍqK–∂      .   src/Composer/Package/Version/VersionParser.phpÔ-  ú+gUÔ-  Í‚∞r∂      0   src/Composer/Package/Version/VersionSelector.phpÉ  ú+gUÉ  ªj6∂      $   src/Composer/Plugin/CommandEvent.php‚  ú+gU‚  ≥∆«W∂      $   src/Composer/Plugin/PluginEvents.php§   ú+gU§   0ÔﬁX∂      '   src/Composer/Plugin/PluginInterface.phpÙ   ú+gUÙ   1â%∂      %   src/Composer/Plugin/PluginManager.phpv  ú+gUv  öUùi∂      ,   src/Composer/Plugin/PreFileDownloadEvent.php`  ú+gU`   9-Œ∂      +   src/Composer/Repository/ArrayRepository.php  ú+gU  ¥Øﬁ/∂      .   src/Composer/Repository/ArtifactRepository.phpÎ
  ú+gUÎ
  öœo∂      .   src/Composer/Repository/ComposerRepository.php§>  ú+gU§>  ﬁË∂      /   src/Composer/Repository/CompositeRepository.php	  ú+gU	  4˙E∂      0   src/Composer/Repository/FilesystemRepository.php¿  ú+gU¿  &xb£∂      4   src/Composer/Repository/InstalledArrayRepository.php£   ú+gU£   /ˆ~>∂      9   src/Composer/Repository/InstalledFilesystemRepository.php£   ú+gU£   V
ï_∂      8   src/Composer/Repository/InstalledRepositoryInterface.phpá   ú+gUá   £9p∂      6   src/Composer/Repository/InvalidRepositoryException.phpn   ú+gUn   ‡ìÎò∂      -   src/Composer/Repository/PackageRepository.phpG  ú+gUG  Ì:k∂      2   src/Composer/Repository/Pear/BaseChannelReader.php6  ú+gU6  .fi!∂      ,   src/Composer/Repository/Pear/ChannelInfo.phpƒ  ú+gUƒ  :T*…∂      .   src/Composer/Repository/Pear/ChannelReader.phpn  ú+gUn  ö8∂      4   src/Composer/Repository/Pear/ChannelRest10Reader.php¡	  ú+gU¡	  OÄÎ∂      4   src/Composer/Repository/Pear/ChannelRest11Reader.php&	  ú+gU&	  ÚUb∂      5   src/Composer/Repository/Pear/DependencyConstraint.phpq  ú+gUq  9=∂      /   src/Composer/Repository/Pear/DependencyInfo.phpq  ú+gUq  f∫TÚ∂      8   src/Composer/Repository/Pear/PackageDependencyParser.php%  ú+gU%  j?ì∂      ,   src/Composer/Repository/Pear/PackageInfo.php∞  ú+gU∞  ü∏∂      ,   src/Composer/Repository/Pear/ReleaseInfo.phpí  ú+gUí  oìä√∂      *   src/Composer/Repository/PearRepository.php∞  ú+gU∞  
,B∑∂      .   src/Composer/Repository/PlatformRepository.phpÅ  ú+gUÅ  :ß’A∂      /   src/Composer/Repository/RepositoryInterface.php‘  ú+gU‘  Úêü…∂      -   src/Composer/Repository/RepositoryManager.php≥  ú+gU≥  33∏Ô∂      7   src/Composer/Repository/RepositorySecurityException.phpo   ú+gUo   p’´™∂      2   src/Composer/Repository/Vcs/GitBitbucketDriver.phpÏ  ú+gUÏ  FˇÙ∂      )   src/Composer/Repository/Vcs/GitDriver.php  ú+gU  \ÓÔ∂      ,   src/Composer/Repository/Vcs/GitHubDriver.phpr'  ú+gUr'  ".j0∂      1   src/Composer/Repository/Vcs/HgBitbucketDriver.phpÙ  ú+gUÙ  ò·Wı∂      (   src/Composer/Repository/Vcs/HgDriver.php‡  ú+gU‡  ÒëÁ∂∂      .   src/Composer/Repository/Vcs/PerforceDriver.php!
  ú+gU!
  çÄŸk∂      )   src/Composer/Repository/Vcs/SvnDriver.php≤  ú+gU≤  À¬†W∂      )   src/Composer/Repository/Vcs/VcsDriver.php—  ú+gU—  Â%R∂      2   src/Composer/Repository/Vcs/VcsDriverInterface.phpâ  ú+gUâ  pO„§∂      )   src/Composer/Repository/VcsRepository.php@  ú+gU@  É≤£´∂      3   src/Composer/Repository/WritableArrayRepository.php  ú+gU  æG*∂      7   src/Composer/Repository/WritableRepositoryInterface.phpâ  ú+gUâ  ë/sÔ∂      $   src/Composer/Script/CommandEvent.phpW   ú+gUW   £VZt∂         src/Composer/Script/Event.phpµ  ú+gUµ  lt¶M∂      $   src/Composer/Script/PackageEvent.phpú   ú+gUú   ßˇ…∂      $   src/Composer/Script/ScriptEvents.phpP  ú+gUP  áè∂∂          src/Composer/Util/AuthHelper.phpÀ  ú+gUÀ  >zxñ∂      $   src/Composer/Util/ComposerMirror.php±  ú+gU±  ≠Ω¯ÿ∂      %   src/Composer/Util/ConfigValidator.php(  ú+gU(  =_ıT∂      "   src/Composer/Util/ErrorHandler.php  ú+gU  ¥@ÖÊ∂          src/Composer/Util/Filesystem.php4&  ú+gU4&  Rlóá∂         src/Composer/Util/Git.php  ú+gU  ´kV®∂         src/Composer/Util/GitHub.php±
  ú+gU±
  _ÿ¢˘∂      $   src/Composer/Util/NoProxyPattern.phpæ  ú+gUæ  Z+∞m∂         src/Composer/Util/Perforce.php3  ú+gU3  Ç=e.∂      %   src/Composer/Util/ProcessExecutor.phpÓ  ú+gUÓ  ‘¿∂      &   src/Composer/Util/RemoteFilesystem.php÷%  ú+gU÷%  Ç‰ ∂      !   src/Composer/Util/SpdxLicense.php±  ú+gU±  õaí9∂      )   src/Composer/Util/SpdxLicensesUpdater.phpq  ú+gUq  »◊Í∂      *   src/Composer/Util/StreamContextFactory.phpŒ  ú+gUŒ  Î‰≥Y∂         src/Composer/Util/Svn.phpá  ú+gUá  õÉeZ∂         src/bootstrap.php≈  ú+gU≈  ®Ø2ê∂      %   src/Composer/Autoload/ClassLoader.phpÑ0  ú+gUÑ0  &íﬁ=∂         res/composer-schema.json§S  ú+gU§S  Ë¥O∂         res/spdx-licenses.json‚`  ú+gU‚`  íí˛ ∂      *   vendor/seld/cli-prompt/res/hiddeninput.exe $  ú+gU $  ïç•v∂      @   vendor/symfony/console/Symfony/Component/Console/Application.php∂R  ú+gU∂R  6›XÒ∂      D   vendor/symfony/console/Symfony/Component/Console/Command/Command.php  ú+gU  p≈∂      H   vendor/symfony/console/Symfony/Component/Console/Command/HelpCommand.php6  ú+gU6  #Øæ}∂      H   vendor/symfony/console/Symfony/Component/Console/Command/ListCommand.php≥  ú+gU≥  V”È∂      B   vendor/symfony/console/Symfony/Component/Console/ConsoleEvents.phpÔ   ú+gUÔ   ’H∏∂      V   vendor/symfony/console/Symfony/Component/Console/Descriptor/ApplicationDescription.php˘  ú+gU˘  â>O∂      J   vendor/symfony/console/Symfony/Component/Console/Descriptor/Descriptor.php\  ú+gU\  WJ[Ì∂      S   vendor/symfony/console/Symfony/Component/Console/Descriptor/DescriptorInterface.php¸   ú+gU¸   ±Qµ∂      N   vendor/symfony/console/Symfony/Component/Console/Descriptor/JsonDescriptor.php2  ú+gU2  Üca∂      R   vendor/symfony/console/Symfony/Component/Console/Descriptor/MarkdownDescriptor.php
  ú+gU
   L€*∂      N   vendor/symfony/console/Symfony/Component/Console/Descriptor/TextDescriptor.php6  ú+gU6  ™‡Ì;∂      M   vendor/symfony/console/Symfony/Component/Console/Descriptor/XmlDescriptor.php†  ú+gU†  Ö{Óm∂      N   vendor/symfony/console/Symfony/Component/Console/Event/ConsoleCommandEvent.php≤  ú+gU≤  Zkâ2∂      G   vendor/symfony/console/Symfony/Component/Console/Event/ConsoleEvent.php≈  ú+gU≈  “x€\∂      P   vendor/symfony/console/Symfony/Component/Console/Event/ConsoleExceptionEvent.php  ú+gU  ·2È∂      P   vendor/symfony/console/Symfony/Component/Console/Event/ConsoleTerminateEvent.phpz  ú+gUz  ≥,ÓL∂      N   vendor/symfony/console/Symfony/Component/Console/Formatter/OutputFormatter.phpf  ú+gUf  Kdˇ-∂      W   vendor/symfony/console/Symfony/Component/Console/Formatter/OutputFormatterInterface.phpò  ú+gUò  3l~¥∂      S   vendor/symfony/console/Symfony/Component/Console/Formatter/OutputFormatterStyle.php∑  ú+gU∑  « ≈K∂      \   vendor/symfony/console/Symfony/Component/Console/Formatter/OutputFormatterStyleInterface.phpé  ú+gUé  ˆÎƒ=∂      X   vendor/symfony/console/Symfony/Component/Console/Formatter/OutputFormatterStyleStack.php
  ú+gU
  ,Ω-∂      P   vendor/symfony/console/Symfony/Component/Console/Helper/DebugFormatterHelper.phpm  ú+gUm  ÚØs>∂      L   vendor/symfony/console/Symfony/Component/Console/Helper/DescriptorHelper.php9  ú+gU9  ˚˘‰∂      H   vendor/symfony/console/Symfony/Component/Console/Helper/DialogHelper.php   ú+gU   ù∞Î•∂      K   vendor/symfony/console/Symfony/Component/Console/Helper/FormatterHelper.phpc  ú+gUc  ì˝´N∂      B   vendor/symfony/console/Symfony/Component/Console/Helper/Helper.phpﬂ  ú+gUﬂ  oæ„∂      K   vendor/symfony/console/Symfony/Component/Console/Helper/HelperInterface.phpÔ   ú+gUÔ   =e∂      E   vendor/symfony/console/Symfony/Component/Console/Helper/HelperSet.php/  ú+gU/  ‚w d∂      L   vendor/symfony/console/Symfony/Component/Console/Helper/InputAwareHelper.phpc  ú+gUc  Ò¯ê|∂      I   vendor/symfony/console/Symfony/Component/Console/Helper/ProcessHelper.php‚  ú+gU‚  |Ãº∂      G   vendor/symfony/console/Symfony/Component/Console/Helper/ProgressBar.php$  ú+gU$  2å5J∂      J   vendor/symfony/console/Symfony/Component/Console/Helper/ProgressHelper.phpÉ  ú+gUÉ  ìhô∂      J   vendor/symfony/console/Symfony/Component/Console/Helper/QuestionHelper.php  ú+gU  Rä∂      A   vendor/symfony/console/Symfony/Component/Console/Helper/Table.php  ú+gU  {üVÇ∂      G   vendor/symfony/console/Symfony/Component/Console/Helper/TableHelper.phpÿ
  ú+gUÿ
  ,†∂      J   vendor/symfony/console/Symfony/Component/Console/Helper/TableSeparator.php[   ú+gU[   LV°∂      F   vendor/symfony/console/Symfony/Component/Console/Helper/TableStyle.php’  ú+gU’  Ê"˘∂      D   vendor/symfony/console/Symfony/Component/Console/Input/ArgvInput.phpŸ  ú+gUŸ  ÀkE∂      E   vendor/symfony/console/Symfony/Component/Console/Input/ArrayInput.php˚	  ú+gU˚	  ‚ˆ•p∂      @   vendor/symfony/console/Symfony/Component/Console/Input/Input.php
  ú+gU
  «˝T∂      H   vendor/symfony/console/Symfony/Component/Console/Input/InputArgument.phpû  ú+gUû  K]Ïi∂      N   vendor/symfony/console/Symfony/Component/Console/Input/InputAwareInterface.phpö   ú+gUö   ájTü∂      J   vendor/symfony/console/Symfony/Component/Console/Input/InputDefinition.php  ú+gU  ò£JM∂      I   vendor/symfony/console/Symfony/Component/Console/Input/InputInterface.php   ú+gU   9î¯«∂      F   vendor/symfony/console/Symfony/Component/Console/Input/InputOption.php´  ú+gU´  ÍÜÆΩ∂      F   vendor/symfony/console/Symfony/Component/Console/Input/StringInput.phpã  ú+gUã  Üun˝∂      8   vendor/symfony/console/Symfony/Component/Console/LICENSE)  ú+gU)  Î&ï∂      I   vendor/symfony/console/Symfony/Component/Console/Logger/ConsoleLogger.php;	  ú+gU;	  #ÿB~∂      J   vendor/symfony/console/Symfony/Component/Console/Output/BufferedOutput.php_  ú+gU_  ˚BÕ∑∂      I   vendor/symfony/console/Symfony/Component/Console/Output/ConsoleOutput.php  ú+gU  jÂ¨∂      R   vendor/symfony/console/Symfony/Component/Console/Output/ConsoleOutputInterface.phpÂ   ú+gUÂ   rNÙ ∂      F   vendor/symfony/console/Symfony/Component/Console/Output/NullOutput.phpø  ú+gUø  `5EÀ∂      B   vendor/symfony/console/Symfony/Component/Console/Output/Output.phpß  ú+gUß  ⁄ _∂      K   vendor/symfony/console/Symfony/Component/Console/Output/OutputInterface.phpI  ú+gUI  »‚„B∂      H   vendor/symfony/console/Symfony/Component/Console/Output/StreamOutput.php¢  ú+gU¢  ¸0∂      L   vendor/symfony/console/Symfony/Component/Console/Question/ChoiceQuestion.phpf  ú+gUf  ‘h∂      R   vendor/symfony/console/Symfony/Component/Console/Question/ConfirmationQuestion.phpK  ú+gUK  ı√T»∂      F   vendor/symfony/console/Symfony/Component/Console/Question/Question.phpÆ  ú+gUÆ  .e8÷∂      :   vendor/symfony/console/Symfony/Component/Console/Shell.php.  ú+gU.  ˛…éá∂      M   vendor/symfony/console/Symfony/Component/Console/Tester/ApplicationTester.php‘  ú+gU‘  ¨Ï§d∂      I   vendor/symfony/console/Symfony/Component/Console/Tester/CommandTester.phpê  ú+gUê  Hª‚`∂      J   vendor/symfony/finder/Symfony/Component/Finder/Adapter/AbstractAdapter.php§
  ú+gU§
  ¢)z9∂      N   vendor/symfony/finder/Symfony/Component/Finder/Adapter/AbstractFindAdapter.php›  ú+gU›  ﬁ_ì¯∂      K   vendor/symfony/finder/Symfony/Component/Finder/Adapter/AdapterInterface.phpØ  ú+gUØ  ãÈ»∂      I   vendor/symfony/finder/Symfony/Component/Finder/Adapter/BsdFindAdapter.php{  ú+gU{  Q,D2∂      I   vendor/symfony/finder/Symfony/Component/Finder/Adapter/GnuFindAdapter.php^  ú+gU^  ﬂzòr∂      E   vendor/symfony/finder/Symfony/Component/Finder/Adapter/PhpAdapter.php+  ú+gU+  &òÓ“∂      H   vendor/symfony/finder/Symfony/Component/Finder/Comparator/Comparator.phpå  ú+gUå  w˛T∂      L   vendor/symfony/finder/Symfony/Component/Finder/Comparator/DateComparator.php%  ú+gU%  LøE«∂      N   vendor/symfony/finder/Symfony/Component/Finder/Comparator/NumberComparator.php~  ú+gU~  îá x∂      R   vendor/symfony/finder/Symfony/Component/Finder/Exception/AccessDeniedException.phpÑ   ú+gUÑ   Ωæsú∂      T   vendor/symfony/finder/Symfony/Component/Finder/Exception/AdapterFailureException.php  ú+gU  må_,∂      O   vendor/symfony/finder/Symfony/Component/Finder/Exception/ExceptionInterface.phpÑ   ú+gUÑ   Gz-∂      Z   vendor/symfony/finder/Symfony/Component/Finder/Exception/OperationNotPermitedException.phpä   ú+gUä   U88∂      Y   vendor/symfony/finder/Symfony/Component/Finder/Exception/ShellCommandFailureException.php$  ú+gU$  Cîs”∂      H   vendor/symfony/finder/Symfony/Component/Finder/Expression/Expression.php}  ú+gU}  /∑c∂      B   vendor/symfony/finder/Symfony/Component/Finder/Expression/Glob.php°  ú+gU°    Vø∂      C   vendor/symfony/finder/Symfony/Component/Finder/Expression/Regex.phpÅ  ú+gUÅ  S7PÊ∂      L   vendor/symfony/finder/Symfony/Component/Finder/Expression/ValueInterface.php;  ú+gU;  Ó„”∂      9   vendor/symfony/finder/Symfony/Component/Finder/Finder.php˙"  ú+gU˙"  gÉ∂      7   vendor/symfony/finder/Symfony/Component/Finder/Glob.php  ú+gU  zù¯
∂      P   vendor/symfony/finder/Symfony/Component/Finder/Iterator/CustomFilterIterator.php]  ú+gU]  t‡±µ∂      S   vendor/symfony/finder/Symfony/Component/Finder/Iterator/DateRangeFilterIterator.phpz  ú+gUz  }¢∂      T   vendor/symfony/finder/Symfony/Component/Finder/Iterator/DepthRangeFilterIterator.php  ú+gU  ﬂ0ô∂      Z   vendor/symfony/finder/Symfony/Component/Finder/Iterator/ExcludeDirectoryFilterIterator.phpî  ú+gUî  "÷Û¡∂      M   vendor/symfony/finder/Symfony/Component/Finder/Iterator/FilePathsIterator.phpç  ú+gUç  ˝Ú‰Q∂      R   vendor/symfony/finder/Symfony/Component/Finder/Iterator/FileTypeFilterIterator.php\  ú+gU\  pë'ò∂      U   vendor/symfony/finder/Symfony/Component/Finder/Iterator/FilecontentFilterIterator.php#  ú+gU#  ⁄_V«∂      R   vendor/symfony/finder/Symfony/Component/Finder/Iterator/FilenameFilterIterator.phpá  ú+gUá  F í∂      J   vendor/symfony/finder/Symfony/Component/Finder/Iterator/FilterIterator.phpÜ  ú+gUÜ  0£æ‘∂      V   vendor/symfony/finder/Symfony/Component/Finder/Iterator/MultiplePcreFilterIterator.phpÿ  ú+gUÿ  “˘ì∂      N   vendor/symfony/finder/Symfony/Component/Finder/Iterator/PathFilterIterator.php∏  ú+gU∏  E*E∂      V   vendor/symfony/finder/Symfony/Component/Finder/Iterator/RecursiveDirectoryIterator.phpY  ú+gUY  Í” ‹∂      S   vendor/symfony/finder/Symfony/Component/Finder/Iterator/SizeRangeFilterIterator.phpg  ú+gUg  !‘óÈ∂      L   vendor/symfony/finder/Symfony/Component/Finder/Iterator/SortableIterator.phpﬁ  ú+gUﬁ  ˆ≥%∂      6   vendor/symfony/finder/Symfony/Component/Finder/LICENSE)  ú+gU)  Î&ï∂      @   vendor/symfony/finder/Symfony/Component/Finder/Shell/Command.php•
  ú+gU•
  ÜÄ˛ä∂      >   vendor/symfony/finder/Symfony/Component/Finder/Shell/Shell.phpÈ  ú+gUÈ  øÎ€ï∂      >   vendor/symfony/finder/Symfony/Component/Finder/SplFileInfo.php˚  ú+gU˚  ëÜ6∂      Q   vendor/symfony/process/Symfony/Component/Process/Exception/ExceptionInterface.phpf   ú+gUf   ]ˆ>T∂      W   vendor/symfony/process/Symfony/Component/Process/Exception/InvalidArgumentException.php®   ú+gU®   –¿+_∂      M   vendor/symfony/process/Symfony/Component/Process/Exception/LogicException.phpî   ú+gUî    ≥„Ò∂      U   vendor/symfony/process/Symfony/Component/Process/Exception/ProcessFailedException.php<  ú+gU<  "w€n∂      W   vendor/symfony/process/Symfony/Component/Process/Exception/ProcessTimedOutException.php  ú+gU  .	√·∂      O   vendor/symfony/process/Symfony/Component/Process/Exception/RuntimeException.phpò   ú+gUò   ¢ÿ:∂      E   vendor/symfony/process/Symfony/Component/Process/ExecutableFinder.php~  ú+gU~  +Ö∂      8   vendor/symfony/process/Symfony/Component/Process/LICENSE)  ú+gU)  Î&ï∂      H   vendor/symfony/process/Symfony/Component/Process/PhpExecutableFinder.php  ú+gU  ˚‘M>∂      ?   vendor/symfony/process/Symfony/Component/Process/PhpProcess.php◊  ú+gU◊  äÄ´∂      H   vendor/symfony/process/Symfony/Component/Process/Pipes/AbstractPipes.php   ú+gU   ò|•æ∂      I   vendor/symfony/process/Symfony/Component/Process/Pipes/PipesInterface.phpD  ú+gUD  vÿÓ°∂      D   vendor/symfony/process/Symfony/Component/Process/Pipes/UnixPipes.php§  ú+gU§  ¯Ut∂      G   vendor/symfony/process/Symfony/Component/Process/Pipes/WindowsPipes.phpΩ  ú+gUΩ   .X£∂      <   vendor/symfony/process/Symfony/Component/Process/Process.php⁄N  ú+gU⁄N  ZEkv∂      C   vendor/symfony/process/Symfony/Component/Process/ProcessBuilder.php  ú+gU  èÔy∂      A   vendor/symfony/process/Symfony/Component/Process/ProcessUtils.phpå  ú+gUå  »b›v∂         vendor/seld/jsonlint/LICENSE"  ú+gU"  aÉsy∂      5   vendor/seld/jsonlint/src/Seld/JsonLint/JsonParser.php)1  ú+gU)1  ?5R3∂      0   vendor/seld/jsonlint/src/Seld/JsonLint/Lexer.php  ú+gU  âÑm!∂      ;   vendor/seld/jsonlint/src/Seld/JsonLint/ParsingException.php  ú+gU  â≤Ò∂      4   vendor/seld/jsonlint/src/Seld/JsonLint/Undefined.php>   ú+gU>   ˇqüü∂         vendor/seld/cli-prompt/LICENSE"  ú+gU"  àÒ?e∂      &   vendor/seld/cli-prompt/res/example.php'  ú+gU'  I£∂      (   vendor/seld/cli-prompt/src/CliPrompt.php  ú+gU  ≠Èôv∂      (   vendor/justinrainbow/json-schema/LICENSE˜  ú+gU˜  xﬁxt∂      T   vendor/justinrainbow/json-schema/src/JsonSchema/Constraints/CollectionConstraint.php	  ú+gU	  ª~´x∂      J   vendor/justinrainbow/json-schema/src/JsonSchema/Constraints/Constraint.phpâ  ú+gUâ  ! fπ∂      S   vendor/justinrainbow/json-schema/src/JsonSchema/Constraints/ConstraintInterface.phpN  ú+gUN  ¯∆My∂      N   vendor/justinrainbow/json-schema/src/JsonSchema/Constraints/EnumConstraint.phpO  ú+gUO  &.À∂      P   vendor/justinrainbow/json-schema/src/JsonSchema/Constraints/FormatConstraint.php˜  ú+gU˜  ¯ÓΩK∂      P   vendor/justinrainbow/json-schema/src/JsonSchema/Constraints/NumberConstraint.phpµ  ú+gUµ  ñË∏L∂      P   vendor/justinrainbow/json-schema/src/JsonSchema/Constraints/ObjectConstraint.phpÊ
  ú+gUÊ
  ∑Eò∂      P   vendor/justinrainbow/json-schema/src/JsonSchema/Constraints/SchemaConstraint.php   ú+gU   »Ã’‚∂      P   vendor/justinrainbow/json-schema/src/JsonSchema/Constraints/StringConstraint.php©  ú+gU©  mÚe‡∂      N   vendor/justinrainbow/json-schema/src/JsonSchema/Constraints/TypeConstraint.php|  ú+gU|  ,$¢€∂      S   vendor/justinrainbow/json-schema/src/JsonSchema/Constraints/UndefinedConstraint.phpû  ú+gUû  ÔÆ∂      V   vendor/justinrainbow/json-schema/src/JsonSchema/Exception/InvalidArgumentException.phpv   ú+gUv   ¨ ´"∂      ]   vendor/justinrainbow/json-schema/src/JsonSchema/Exception/InvalidSchemaMediaTypeException.phpv   ú+gUv   äC”∂      W   vendor/justinrainbow/json-schema/src/JsonSchema/Exception/InvalidSourceUriException.phpw   ú+gUw   N-Ú[∂      S   vendor/justinrainbow/json-schema/src/JsonSchema/Exception/JsonDecodingException.phpﬁ  ú+gUﬁ  Üæ©ë∂      W   vendor/justinrainbow/json-schema/src/JsonSchema/Exception/ResourceNotFoundException.phpo   ú+gUo   ∆$"≈∂      R   vendor/justinrainbow/json-schema/src/JsonSchema/Exception/UriResolverException.phpj   ú+gUj   S”«≥∂      ?   vendor/justinrainbow/json-schema/src/JsonSchema/RefResolver.php|
  ú+gU|
  ô&i∂      T   vendor/justinrainbow/json-schema/src/JsonSchema/Uri/Retrievers/AbstractRetriever.php‹   ú+gU‹   ]j∂      G   vendor/justinrainbow/json-schema/src/JsonSchema/Uri/Retrievers/Curl.phpt  ú+gUt  I∑˝ ∂      R   vendor/justinrainbow/json-schema/src/JsonSchema/Uri/Retrievers/FileGetContents.php—  ú+gU—  Êá®∂      R   vendor/justinrainbow/json-schema/src/JsonSchema/Uri/Retrievers/PredefinedArray.php^  ú+gU^  "ﬂ6o∂      X   vendor/justinrainbow/json-schema/src/JsonSchema/Uri/Retrievers/UriRetrieverInterface.php©   ú+gU©   CO∂      C   vendor/justinrainbow/json-schema/src/JsonSchema/Uri/UriResolver.phpÆ	  ú+gUÆ	  ‡Pæ°∂      D   vendor/justinrainbow/json-schema/src/JsonSchema/Uri/UriRetriever.phpñ  ú+gUñ  ™ˇ®‹∂      =   vendor/justinrainbow/json-schema/src/JsonSchema/Validator.phpá  ú+gUá  - ⁄Ù∂         vendor/autoload.phpá   ú+gUá   Á«˙∑∂      '   vendor/composer/autoload_namespaces.php±  ú+gU±  [Æ„∂      !   vendor/composer/autoload_psr4.php8  ú+gU8  â’Ez∂      %   vendor/composer/autoload_classmap.phpd   ú+gUd   Z°¶H∂      !   vendor/composer/autoload_real.php7  ú+gU7  öz÷…∂      !   vendor/composer/include_paths.php≤   ú+gU≤   ıE∂         vendor/composer/ClassLoader.php2  ú+gU2  +°⁄K∂         bin/composerl  ú+gUl  ‘ö√	∂         LICENSE3  ú+gU3  f˝ﬁX∂      <?php











namespace Composer\Autoload;

use Composer\Config;
use Composer\EventDispatcher\EventDispatcher;
use Composer\Installer\InstallationManager;
use Composer\IO\IOInterface;
use Composer\Package\AliasPackage;
use Composer\Package\PackageInterface;
use Composer\Repository\InstalledRepositoryInterface;
use Composer\Util\Filesystem;
use Composer\Script\ScriptEvents;





class AutoloadGenerator
{



private $eventDispatcher;




private $io;

private $devMode = false;

public function __construct(EventDispatcher $eventDispatcher, IOInterface $io = null)
{
$this->eventDispatcher = $eventDispatcher;
$this->io = $io;
}

public function setDevMode($devMode = true)
{
$this->devMode = (boolean) $devMode;
}

public function dump(Config $config, InstalledRepositoryInterface $localRepo, PackageInterface $mainPackage, InstallationManager $installationManager, $targetDir, $scanPsr0Packages = false, $suffix = '')
{
$this->eventDispatcher->dispatchScript(ScriptEvents::PRE_AUTOLOAD_DUMP, $this->devMode, array(), array(
'optimize' => (bool) $scanPsr0Packages,
));

$filesystem = new Filesystem();
$filesystem->ensureDirectoryExists($config->get('vendor-dir'));
$basePath = $filesystem->normalizePath(realpath(getcwd()));
$vendorPath = $filesystem->normalizePath(realpath($config->get('vendor-dir')));
$useGlobalIncludePath = (bool) $config->get('use-include-path');
$prependAutoloader = $config->get('prepend-autoloader') === false ? 'false' : 'true';
$classMapAuthoritative = $config->get('classmap-authoritative');
$targetDir = $vendorPath.'/'.$targetDir;
$filesystem->ensureDirectoryExists($targetDir);

$vendorPathCode = $filesystem->findShortestPathCode(realpath($targetDir), $vendorPath, true);
$vendorPathCode52 = str_replace('__DIR__', 'dirname(__FILE__)', $vendorPathCode);
$vendorPathToTargetDirCode = $filesystem->findShortestPathCode($vendorPath, realpath($targetDir), true);

$appBaseDirCode = $filesystem->findShortestPathCode($vendorPath, $basePath, true);
$appBaseDirCode = str_replace('__DIR__', '$vendorDir', $appBaseDirCode);

$namespacesFile = <<<EOF
<?php

// autoload_namespaces.php @generated by Composer

\$vendorDir = $vendorPathCode52;
\$baseDir = $appBaseDirCode;

return array(

EOF;

$psr4File = <<<EOF
<?php

// autoload_psr4.php @generated by Composer

\$vendorDir = $vendorPathCode52;
\$baseDir = $appBaseDirCode;

return array(

EOF;


 $packageMap = $this->buildPackageMap($installationManager, $mainPackage, $localRepo->getCanonicalPackages());
$autoloads = $this->parseAutoloads($packageMap, $mainPackage);


 foreach ($autoloads['psr-0'] as $namespace => $paths) {
$exportedPaths = array();
foreach ($paths as $path) {
$exportedPaths[] = $this->getPathCode($filesystem, $basePath, $vendorPath, $path);
}
$exportedPrefix = var_export($namespace, true);
$namespacesFile .= "    $exportedPrefix => ";
$namespacesFile .= "array(".implode(', ', $exportedPaths)."),\n";
}
$namespacesFile .= ");\n";


 foreach ($autoloads['psr-4'] as $namespace => $paths) {
$exportedPaths = array();
foreach ($paths as $path) {
$exportedPaths[] = $this->getPathCode($filesystem, $basePath, $vendorPath, $path);
}
$exportedPrefix = var_export($namespace, true);
$psr4File .= "    $exportedPrefix => ";
$psr4File .= "array(".implode(', ', $exportedPaths)."),\n";
}
$psr4File .= ");\n";

$classmapFile = <<<EOF
<?php

// autoload_classmap.php @generated by Composer

\$vendorDir = $vendorPathCode52;
\$baseDir = $appBaseDirCode;

return array(

EOF;


 $targetDirLoader = null;
$mainAutoload = $mainPackage->getAutoload();
if ($mainPackage->getTargetDir() && !empty($mainAutoload['psr-0'])) {
$levels = count(explode('/', $filesystem->normalizePath($mainPackage->getTargetDir())));
$prefixes = implode(', ', array_map(function ($prefix) {
return var_export($prefix, true);
}, array_keys($mainAutoload['psr-0'])));
$baseDirFromTargetDirCode = $filesystem->findShortestPathCode($targetDir, $basePath, true);

$targetDirLoader = <<<EOF

    public static function autoload(\$class)
    {
        \$dir = $baseDirFromTargetDirCode . '/';
        \$prefixes = array($prefixes);
        foreach (\$prefixes as \$prefix) {
            if (0 !== strpos(\$class, \$prefix)) {
                continue;
            }
            \$path = \$dir . implode('/', array_slice(explode('\\\\', \$class), $levels)).'.php';
            if (!\$path = stream_resolve_include_path(\$path)) {
                return false;
            }
            require \$path;

            return true;
        }
    }

EOF;
}


 $classMap = array();
if ($scanPsr0Packages) {

 foreach (array('psr-0', 'psr-4') as $psrType) {
foreach ($autoloads[$psrType] as $namespace => $paths) {
foreach ($paths as $dir) {
$dir = $filesystem->normalizePath($filesystem->isAbsolutePath($dir) ? $dir : $basePath.'/'.$dir);
if (!is_dir($dir)) {
continue;
}
$whitelist = sprintf(
'{%s/%s.+(?<!(?<!/)Test\.php)$}',
preg_quote($dir),
($psrType === 'psr-0' && strpos($namespace, '_') === false) ? preg_quote(strtr($namespace, '\\', '/')) : ''
);

$namespaceFilter = $namespace === '' ? null : $namespace;
foreach (ClassMapGenerator::createMap($dir, $whitelist, $this->io, $namespaceFilter) as $class => $path) {
if (!isset($classMap[$class])) {
$path = $this->getPathCode($filesystem, $basePath, $vendorPath, $path);
$classMap[$class] = $path.",\n";
}
}
}
}
}
}

foreach ($autoloads['classmap'] as $dir) {
foreach (ClassMapGenerator::createMap($dir, null, $this->io) as $class => $path) {
$path = $this->getPathCode($filesystem, $basePath, $vendorPath, $path);
$classMap[$class] = $path.",\n";
}
}

ksort($classMap);
foreach ($classMap as $class => $code) {
$classmapFile .= '    '.var_export($class, true).' => '.$code;
}
$classmapFile .= ");\n";

if (!$suffix) {
if (!$config->get('autoloader-suffix') && is_readable($vendorPath.'/autoload.php')) {
$content = file_get_contents($vendorPath.'/autoload.php');
if (preg_match('{ComposerAutoloaderInit([^:\s]+)::}', $content, $match)) {
$suffix = $match[1];
}
}

if (!$suffix) {
$suffix = $config->get('autoloader-suffix') ?: md5(uniqid('', true));
}
}

file_put_contents($targetDir.'/autoload_namespaces.php', $namespacesFile);
file_put_contents($targetDir.'/autoload_psr4.php', $psr4File);
file_put_contents($targetDir.'/autoload_classmap.php', $classmapFile);
if ($includePathFile = $this->getIncludePathsFile($packageMap, $filesystem, $basePath, $vendorPath, $vendorPathCode52, $appBaseDirCode)) {
file_put_contents($targetDir.'/include_paths.php', $includePathFile);
}
if ($includeFilesFile = $this->getIncludeFilesFile($autoloads['files'], $filesystem, $basePath, $vendorPath, $vendorPathCode52, $appBaseDirCode)) {
file_put_contents($targetDir.'/autoload_files.php', $includeFilesFile);
}
file_put_contents($vendorPath.'/autoload.php', $this->getAutoloadFile($vendorPathToTargetDirCode, $suffix));
file_put_contents($targetDir.'/autoload_real.php', $this->getAutoloadRealFile(true, (bool) $includePathFile, $targetDirLoader, (bool) $includeFilesFile, $vendorPathCode, $appBaseDirCode, $suffix, $useGlobalIncludePath, $prependAutoloader, $classMapAuthoritative));


 
 $sourceLoader = fopen(__DIR__.'/ClassLoader.php', 'r');
$targetLoader = fopen($targetDir.'/ClassLoader.php', 'w+');
stream_copy_to_stream($sourceLoader, $targetLoader);
fclose($sourceLoader);
fclose($targetLoader);
unset($sourceLoader, $targetLoader);

$this->eventDispatcher->dispatchScript(ScriptEvents::POST_AUTOLOAD_DUMP, $this->devMode, array(), array(
'optimize' => (bool) $scanPsr0Packages,
));
}

public function buildPackageMap(InstallationManager $installationManager, PackageInterface $mainPackage, array $packages)
{

 $packageMap = array(array($mainPackage, ''));

foreach ($packages as $package) {
if ($package instanceof AliasPackage) {
continue;
}
$this->validatePackage($package);

$packageMap[] = array(
$package,
$installationManager->getInstallPath($package),
);
}

return $packageMap;
}






protected function validatePackage(PackageInterface $package)
{
$autoload = $package->getAutoload();
if (!empty($autoload['psr-4']) && null !== $package->getTargetDir()) {
$name = $package->getName();
$package->getTargetDir();
throw new \InvalidArgumentException("PSR-4 autoloading is incompatible with the target-dir property, remove the target-dir in package '$name'.");
}
if (!empty($autoload['psr-4'])) {
foreach ($autoload['psr-4'] as $namespace => $dirs) {
if ($namespace !== '' && '\\' !== substr($namespace, -1)) {
throw new \InvalidArgumentException("psr-4 namespaces must end with a namespace separator, '$namespace' does not, use '$namespace\\'.");
}
}
}
}








public function parseAutoloads(array $packageMap, PackageInterface $mainPackage)
{
$mainPackageMap = array_shift($packageMap);
$sortedPackageMap = $this->sortPackageMap($packageMap);
$sortedPackageMap[] = $mainPackageMap;
array_unshift($packageMap, $mainPackageMap);

$psr0 = $this->parseAutoloadsType($packageMap, 'psr-0', $mainPackage);
$psr4 = $this->parseAutoloadsType($packageMap, 'psr-4', $mainPackage);
$classmap = $this->parseAutoloadsType($sortedPackageMap, 'classmap', $mainPackage);
$files = $this->parseAutoloadsType($sortedPackageMap, 'files', $mainPackage);

krsort($psr0);
krsort($psr4);

return array('psr-0' => $psr0, 'psr-4' => $psr4, 'classmap' => $classmap, 'files' => $files);
}







public function createLoader(array $autoloads)
{
$loader = new ClassLoader();

if (isset($autoloads['psr-0'])) {
foreach ($autoloads['psr-0'] as $namespace => $path) {
$loader->add($namespace, $path);
}
}

if (isset($autoloads['psr-4'])) {
foreach ($autoloads['psr-4'] as $namespace => $path) {
$loader->addPsr4($namespace, $path);
}
}

return $loader;
}

protected function getIncludePathsFile(array $packageMap, Filesystem $filesystem, $basePath, $vendorPath, $vendorPathCode, $appBaseDirCode)
{
$includePaths = array();

foreach ($packageMap as $item) {
list($package, $installPath) = $item;

if (null !== $package->getTargetDir() && strlen($package->getTargetDir()) > 0) {
$installPath = substr($installPath, 0, -strlen('/'.$package->getTargetDir()));
}

foreach ($package->getIncludePaths() as $includePath) {
$includePath = trim($includePath, '/');
$includePaths[] = empty($installPath) ? $includePath : $installPath.'/'.$includePath;
}
}

if (!$includePaths) {
return;
}

$includePathsCode = '';
foreach ($includePaths as $path) {
$includePathsCode .= "    " . $this->getPathCode($filesystem, $basePath, $vendorPath, $path) . ",\n";
}

return <<<EOF
<?php

// include_paths.php @generated by Composer

\$vendorDir = $vendorPathCode;
\$baseDir = $appBaseDirCode;

return array(
$includePathsCode);

EOF;
}

protected function getIncludeFilesFile(array $files, Filesystem $filesystem, $basePath, $vendorPath, $vendorPathCode, $appBaseDirCode)
{
$filesCode = '';
foreach ($files as $functionFile) {
$filesCode .= '    '.$this->getPathCode($filesystem, $basePath, $vendorPath, $functionFile).",\n";
}

if (!$filesCode) {
return false;
}

return <<<EOF
<?php

// autoload_files.php @generated by Composer

\$vendorDir = $vendorPathCode;
\$baseDir = $appBaseDirCode;

return array(
$filesCode);

EOF;
}

protected function getPathCode(Filesystem $filesystem, $basePath, $vendorPath, $path)
{
if (!$filesystem->isAbsolutePath($path)) {
$path = $basePath . '/' . $path;
}
$path = $filesystem->normalizePath($path);

$baseDir = '';
if (strpos($path.'/', $vendorPath.'/') === 0) {
$path = substr($path, strlen($vendorPath));
$baseDir = '$vendorDir';

if ($path !== false) {
$baseDir .= " . ";
}
} else {
$path = $filesystem->normalizePath($filesystem->findShortestPath($basePath, $path, true));
if (!$filesystem->isAbsolutePath($path)) {
$baseDir = '$baseDir . ';
$path = '/' . $path;
}
}

if (preg_match('/\.phar$/', $path)) {
$baseDir = "'phar://' . " . $baseDir;
}

return $baseDir . (($path !== false) ? var_export($path, true) : "");
}

protected function getAutoloadFile($vendorPathToTargetDirCode, $suffix)
{
return <<<AUTOLOAD
<?php

// autoload.php @generated by Composer

require_once $vendorPathToTargetDirCode . '/autoload_real.php';

return ComposerAutoloaderInit$suffix::getLoader();

AUTOLOAD;
}

protected function getAutoloadRealFile($useClassMap, $useIncludePath, $targetDirLoader, $useIncludeFiles, $vendorPathCode, $appBaseDirCode, $suffix, $useGlobalIncludePath, $prependAutoloader, $classMapAuthoritative)
{

 
 
 
 
 

$file = <<<HEADER
<?php

// autoload_real.php @generated by Composer

class ComposerAutoloaderInit$suffix
{
    private static \$loader;

    public static function loadClassLoader(\$class)
    {
        if ('Composer\\Autoload\\ClassLoader' === \$class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    public static function getLoader()
    {
        if (null !== self::\$loader) {
            return self::\$loader;
        }

        spl_autoload_register(array('ComposerAutoloaderInit$suffix', 'loadClassLoader'), true, $prependAutoloader);
        self::\$loader = \$loader = new \\Composer\\Autoload\\ClassLoader();
        spl_autoload_unregister(array('ComposerAutoloaderInit$suffix', 'loadClassLoader'));


HEADER;

if ($useIncludePath) {
$file .= <<<'INCLUDE_PATH'
        $includePaths = require __DIR__ . '/include_paths.php';
        array_push($includePaths, get_include_path());
        set_include_path(join(PATH_SEPARATOR, $includePaths));


INCLUDE_PATH;
}

$file .= <<<'PSR0'
        $map = require __DIR__ . '/autoload_namespaces.php';
        foreach ($map as $namespace => $path) {
            $loader->set($namespace, $path);
        }


PSR0;

$file .= <<<'PSR4'
        $map = require __DIR__ . '/autoload_psr4.php';
        foreach ($map as $namespace => $path) {
            $loader->setPsr4($namespace, $path);
        }


PSR4;

if ($useClassMap) {
$file .= <<<'CLASSMAP'
        $classMap = require __DIR__ . '/autoload_classmap.php';
        if ($classMap) {
            $loader->addClassMap($classMap);
        }


CLASSMAP;
}

if ($classMapAuthoritative) {
$file .= <<<'CLASSMAPAUTHORITATIVE'
        $loader->setClassMapAuthoritative(true);

CLASSMAPAUTHORITATIVE;
}

if ($useGlobalIncludePath) {
$file .= <<<'INCLUDEPATH'
        $loader->setUseIncludePath(true);

INCLUDEPATH;
}

if ($targetDirLoader) {
$file .= <<<REGISTER_AUTOLOAD
        spl_autoload_register(array('ComposerAutoloaderInit$suffix', 'autoload'), true, true);


REGISTER_AUTOLOAD;
}

$file .= <<<REGISTER_LOADER
        \$loader->register($prependAutoloader);


REGISTER_LOADER;

if ($useIncludeFiles) {
$file .= <<<INCLUDE_FILES
        \$includeFiles = require __DIR__ . '/autoload_files.php';
        foreach (\$includeFiles as \$file) {
            composerRequire$suffix(\$file);
        }


INCLUDE_FILES;
}

$file .= <<<METHOD_FOOTER
        return \$loader;
    }

METHOD_FOOTER;

$file .= $targetDirLoader;

return $file . <<<FOOTER
}

function composerRequire$suffix(\$file)
{
    require \$file;
}

FOOTER;
}

protected function parseAutoloadsType(array $packageMap, $type, PackageInterface $mainPackage)
{
$autoloads = array();

foreach ($packageMap as $item) {
list($package, $installPath) = $item;

$autoload = $package->getAutoload();
if ($this->devMode && $package === $mainPackage) {
$autoload = array_merge_recursive($autoload, $package->getDevAutoload());
}


 if (!isset($autoload[$type]) || !is_array($autoload[$type])) {
continue;
}
if (null !== $package->getTargetDir() && $package !== $mainPackage) {
$installPath = substr($installPath, 0, -strlen('/'.$package->getTargetDir()));
}

foreach ($autoload[$type] as $namespace => $paths) {
foreach ((array) $paths as $path) {
if (($type === 'files' || $type === 'classmap') && $package->getTargetDir() && !is_readable($installPath.'/'.$path)) {

 if ($package === $mainPackage) {
$targetDir = str_replace('\\<dirsep\\>', '[\\\\/]', preg_quote(str_replace(array('/', '\\'), '<dirsep>', $package->getTargetDir())));
$path = ltrim(preg_replace('{^'.$targetDir.'}', '', ltrim($path, '\\/')), '\\/');
} else {

 $path = $package->getTargetDir() . '/' . $path;
}
}

$relativePath = empty($installPath) ? (empty($path) ? '.' : $path) : $installPath.'/'.$path;

if ($type === 'files' || $type === 'classmap') {
$autoloads[] = $relativePath;
continue;
}

$autoloads[$namespace][] = $relativePath;
}
}
}

return $autoloads;
}









protected function sortPackageMap(array $packageMap)
{
$packages = array();
$paths = array();
$usageList = array();

foreach ($packageMap as $item) {
list($package, $path) = $item;
$name = $package->getName();
$packages[$name] = $package;
$paths[$name] = $path;

foreach (array_merge($package->getRequires(), $package->getDevRequires()) as $link) {
$target = $link->getTarget();
$usageList[$target][] = $name;
}
}

$computing = array();
$computed = array();
$computeImportance = function ($name) use (&$computeImportance, &$computing, &$computed, $usageList) {

 if (isset($computed[$name])) {
return $computed[$name];
}


 if (isset($computing[$name])) {
return 0;
}

$computing[$name] = true;
$weight = 0;

if (isset($usageList[$name])) {
foreach ($usageList[$name] as $user) {
$weight -= 1 - $computeImportance($user);
}
}

unset($computing[$name]);
$computed[$name] = $weight;

return $weight;
};

$weightList = array();

foreach ($packages as $name => $package) {
$weight = $computeImportance($name);
$weightList[$name] = $weight;
}

$stable_sort = function (&$array) {
static $transform, $restore;

$i = 0;

if (!$transform) {
$transform = function (&$v, $k) use (&$i) {
$v = array($v, ++$i, $k, $v);
};

$restore = function (&$v, $k) {
$v = $v[3];
};
}

array_walk($array, $transform);
asort($array);
array_walk($array, $restore);
};

$stable_sort($weightList);

$sortedPackageMap = array();

foreach (array_keys($weightList) as $name) {
$sortedPackageMap[] = array($packages[$name], $paths[$name]);
}

return $sortedPackageMap;
}
}
<?php












namespace Composer\Autoload;

use Symfony\Component\Finder\Finder;
use Composer\IO\IOInterface;







class ClassMapGenerator
{






public static function dump($dirs, $file)
{
$maps = array();

foreach ($dirs as $dir) {
$maps = array_merge($maps, static::createMap($dir));
}

file_put_contents($file, sprintf('<?php return %s;', var_export($maps, true)));
}













public static function createMap($path, $whitelist = null, IOInterface $io = null, $namespace = null)
{
if (is_string($path)) {
if (is_file($path)) {
$path = array(new \SplFileInfo($path));
} elseif (is_dir($path)) {
$path = Finder::create()->files()->followLinks()->name('/\.(php|inc|hh)$/')->in($path);
} else {
throw new \RuntimeException(
'Could not scan for classes inside "'.$path.
'" which does not appear to be a file nor a folder'
);
}
}

$map = array();

foreach ($path as $file) {
$filePath = $file->getRealPath();

if (!in_array(pathinfo($filePath, PATHINFO_EXTENSION), array('php', 'inc', 'hh'))) {
continue;
}

if ($whitelist && !preg_match($whitelist, strtr($filePath, '\\', '/'))) {
continue;
}

$classes = self::findClasses($filePath);

foreach ($classes as $class) {

 if (null !== $namespace && 0 !== strpos($class, $namespace)) {
continue;
}

if (!isset($map[$class])) {
$map[$class] = $filePath;
} elseif ($io && $map[$class] !== $filePath && !preg_match('{/(test|fixture|example)s?/}i', strtr($map[$class].' '.$filePath, '\\', '/'))) {
$io->writeError(
'<warning>Warning: Ambiguous class resolution, "'.$class.'"'.
' was found in both "'.$map[$class].'" and "'.$filePath.'", the first will be used.</warning>'
);
}
}
}

return $map;
}








private static function findClasses($path)
{
$extraTypes = PHP_VERSION_ID < 50400 ? '' : '|trait';
if (defined('HHVM_VERSION') && version_compare(HHVM_VERSION, '3.3', '>=')) {
$extraTypes .= '|enum';
}

try {
$contents = @php_strip_whitespace($path);
if (!$contents) {
if (!file_exists($path)) {
throw new \Exception('File does not exist');
}
if (!is_readable($path)) {
throw new \Exception('File is not readable');
}
}
} catch (\Exception $e) {
throw new \RuntimeException('Could not scan for classes inside '.$path.": \n".$e->getMessage(), 0, $e);
}


 if (!preg_match('{\b(?:class|interface'.$extraTypes.')\s}i', $contents)) {
return array();
}


 $contents = preg_replace('{<<<\s*(\'?)(\w+)\\1(?:\r\n|\n|\r)(?:.*?)(?:\r\n|\n|\r)\\2(?=\r\n|\n|\r|;)}s', 'null', $contents);

 $contents = preg_replace('{"[^"\\\\]*(\\\\.[^"\\\\]*)*"|\'[^\'\\\\]*(\\\\.[^\'\\\\]*)*\'}s', 'null', $contents);

 if (substr($contents, 0, 2) !== '<?') {
$contents = preg_replace('{^.+?<\?}s', '<?', $contents, 1, $replacements);
if ($replacements === 0) {
return array();
}
}

 $contents = preg_replace('{\?>.+<\?}s', '?><?', $contents);

 $pos = strrpos($contents, '?>');
if (false !== $pos && false === strpos(substr($contents, $pos), '<?')) {
$contents = substr($contents, 0, $pos);
}

preg_match_all('{
            (?:
                 \b(?<![\$:>])(?P<type>class|interface'.$extraTypes.') \s+ (?P<name>[a-zA-Z_\x7f-\xff:][a-zA-Z0-9_\x7f-\xff:\-]*)
               | \b(?<![\$:>])(?P<ns>namespace) (?P<nsname>\s+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*(?:\s*\\\\\s*[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)*)? \s*[\{;]
            )
        }ix', $contents, $matches);

$classes = array();
$namespace = '';

for ($i = 0, $len = count($matches['type']); $i < $len; $i++) {
if (!empty($matches['ns'][$i])) {
$namespace = str_replace(array(' ', "\t", "\r", "\n"), '', $matches['nsname'][$i]) . '\\';
} else {
$name = $matches['name'][$i];
if ($name[0] === ':') {

 $name = 'xhp'.substr(str_replace(array('-', ':'), array('_', '__'), $name), 1);
} elseif ($matches['type'][$i] === 'enum') {

 
 
 
 $name = rtrim($name, ':');
}
$classes[] = ltrim($namespace . $name, '\\');
}
}

return $classes;
}
}
<?php











namespace Composer;

use Composer\IO\IOInterface;
use Composer\Util\Filesystem;
use Symfony\Component\Finder\Finder;






class Cache
{
private static $cacheCollected = false;
private $io;
private $root;
private $enabled = true;
private $whitelist;
private $filesystem;







public function __construct(IOInterface $io, $cacheDir, $whitelist = 'a-z0-9.', Filesystem $filesystem = null)
{
$this->io = $io;
$this->root = rtrim($cacheDir, '/\\') . '/';
$this->whitelist = $whitelist;
$this->filesystem = $filesystem ?: new Filesystem();

if (!is_dir($this->root)) {
if (!@mkdir($this->root, 0777, true)) {
$this->enabled = false;
}
}
}

public function isEnabled()
{
return $this->enabled;
}

public function getRoot()
{
return $this->root;
}

public function read($file)
{
$file = preg_replace('{[^'.$this->whitelist.']}i', '-', $file);
if ($this->enabled && file_exists($this->root . $file)) {
if ($this->io->isDebug()) {
$this->io->writeError('Reading '.$this->root . $file.' from cache');
}

return file_get_contents($this->root . $file);
}

return false;
}

public function write($file, $contents)
{
if ($this->enabled) {
$file = preg_replace('{[^'.$this->whitelist.']}i', '-', $file);

if ($this->io->isDebug()) {
$this->io->writeError('Writing '.$this->root . $file.' into cache');
}

try {
return file_put_contents($this->root . $file, $contents);
} catch (\ErrorException $e) {
if (preg_match('{^file_put_contents\(\): Only ([0-9]+) of ([0-9]+) bytes written}', $e->getMessage(), $m)) {

 unlink($this->root . $file);

$message = sprintf(
'<warning>Writing %1$s into cache failed after %2$u of %3$u bytes written, only %4$u bytes of free space available</warning>',
$this->root . $file,
$m[1],
$m[2],
@disk_free_space($this->root . dirname($file))
);

$this->io->writeError($message);

return false;
}

throw $e;
}
}

return false;
}




public function copyFrom($file, $source)
{
if ($this->enabled) {
$file = preg_replace('{[^'.$this->whitelist.']}i', '-', $file);
$this->filesystem->ensureDirectoryExists(dirname($this->root . $file));

if ($this->io->isDebug()) {
$this->io->writeError('Writing '.$this->root . $file.' into cache');
}

return copy($source, $this->root . $file);
}

return false;
}




public function copyTo($file, $target)
{
$file = preg_replace('{[^'.$this->whitelist.']}i', '-', $file);
if ($this->enabled && file_exists($this->root . $file)) {
try {
touch($this->root . $file, filemtime($this->root . $file), time());
} catch (\ErrorException $e) {

 
 touch($this->root . $file);
}

if ($this->io->isDebug()) {
$this->io->writeError('Reading '.$this->root . $file.' from cache');
}

return copy($this->root . $file, $target);
}

return false;
}

public function gcIsNecessary()
{
return (!self::$cacheCollected && !mt_rand(0, 50));
}

public function remove($file)
{
$file = preg_replace('{[^'.$this->whitelist.']}i', '-', $file);
if ($this->enabled && file_exists($this->root . $file)) {
return $this->filesystem->unlink($this->root . $file);
}

return false;
}

public function gc($ttl, $maxSize)
{
if ($this->enabled) {
$expire = new \DateTime();
$expire->modify('-'.$ttl.' seconds');

$finder = $this->getFinder()->date('until '.$expire->format('Y-m-d H:i:s'));
foreach ($finder as $file) {
$this->filesystem->unlink($file->getPathname());
}

$totalSize = $this->filesystem->size($this->root);
if ($totalSize > $maxSize) {
$iterator = $this->getFinder()->sortByAccessedTime()->getIterator();
while ($totalSize > $maxSize && $iterator->valid()) {
$filepath = $iterator->current()->getPathname();
$totalSize -= $this->filesystem->size($filepath);
$this->filesystem->unlink($filepath);
$iterator->next();
}
}

self::$cacheCollected = true;

return true;
}

return false;
}

public function sha1($file)
{
$file = preg_replace('{[^'.$this->whitelist.']}i', '-', $file);
if ($this->enabled && file_exists($this->root . $file)) {
return sha1_file($this->root . $file);
}

return false;
}

public function sha256($file)
{
$file = preg_replace('{[^'.$this->whitelist.']}i', '-', $file);
if ($this->enabled && file_exists($this->root . $file)) {
return hash_file('sha256', $this->root . $file);
}

return false;
}

protected function getFinder()
{
return Finder::create()->in($this->root)->files();
}
}
<?php











namespace Composer\Command;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;




class AboutCommand extends Command
{
protected function configure()
{
$this
->setName('about')
->setDescription('Short information about Composer')
->setHelp(<<<EOT
<info>php composer.phar about</info>
EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
$this->getIO()->write(<<<EOT
<info>Composer - Package Management for PHP</info>
<comment>Composer is a dependency manager tracking local dependencies of your projects and libraries.
See https://getcomposer.org/ for more information.</comment>
EOT
);
}
}
<?php











namespace Composer\Command;

use Composer\Factory;
use Composer\IO\IOInterface;
use Composer\DependencyResolver\Pool;
use Composer\Repository\CompositeRepository;
use Composer\Script\ScriptEvents;
use Composer\Plugin\CommandEvent;
use Composer\Plugin\PluginEvents;
use Composer\Package\Version\VersionParser;

use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;






class ArchiveCommand extends Command
{
protected function configure()
{
$this
->setName('archive')
->setDescription('Create an archive of this composer package')
->setDefinition(array(
new InputArgument('package', InputArgument::OPTIONAL, 'The package to archive instead of the current project'),
new InputArgument('version', InputArgument::OPTIONAL, 'A version constraint to find the package to archive'),
new InputOption('format', 'f', InputOption::VALUE_REQUIRED, 'Format of the resulting archive: tar or zip', 'tar'),
new InputOption('dir', false, InputOption::VALUE_REQUIRED, 'Write the archive to this directory', '.'),
))
->setHelp(<<<EOT
The <info>archive</info> command creates an archive of the specified format
containing the files and directories of the Composer project or the specified
package in the specified version and writes it to the specified directory.

<info>php composer.phar archive [--format=zip] [--dir=/foo] [package [version]]</info>

EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
$composer = $this->getComposer(false);
if ($composer) {
$commandEvent = new CommandEvent(PluginEvents::COMMAND, 'archive', $input, $output);
$composer->getEventDispatcher()->dispatch($commandEvent->getName(), $commandEvent);
$composer->getEventDispatcher()->dispatchScript(ScriptEvents::PRE_ARCHIVE_CMD);
}

$returnCode = $this->archive(
$this->getIO(),
$input->getArgument('package'),
$input->getArgument('version'),
$input->getOption('format'),
$input->getOption('dir')
);

if (0 === $returnCode && $composer) {
$composer->getEventDispatcher()->dispatchScript(ScriptEvents::POST_ARCHIVE_CMD);
}

return $returnCode;
}

protected function archive(IOInterface $io, $packageName = null, $version = null, $format = 'tar', $dest = '.')
{
$config = Factory::createConfig();
$factory = new Factory;
$downloadManager = $factory->createDownloadManager($io, $config);
$archiveManager = $factory->createArchiveManager($config, $downloadManager);

if ($packageName) {
$package = $this->selectPackage($io, $packageName, $version);

if (!$package) {
return 1;
}
} else {
$package = $this->getComposer()->getPackage();
}

$io->writeError('<info>Creating the archive.</info>');
$archiveManager->archive($package, $format, $dest);

return 0;
}

protected function selectPackage(IOInterface $io, $packageName, $version = null)
{
$io->writeError('<info>Searching for the specified package.</info>');

if ($composer = $this->getComposer(false)) {
$localRepo = $composer->getRepositoryManager()->getLocalRepository();
$repos = new CompositeRepository(array_merge(array($localRepo), $composer->getRepositoryManager()->getRepositories()));
} else {
$defaultRepos = Factory::createDefaultRepositories($this->getIO());
$io->writeError('No composer.json found in the current directory, searching packages from ' . implode(', ', array_keys($defaultRepos)));
$repos = new CompositeRepository($defaultRepos);
}

$pool = new Pool();
$pool->addRepository($repos);

$parser = new VersionParser();
$constraint = ($version) ? $parser->parseConstraints($version) : null;
$packages = $pool->whatProvides($packageName, $constraint, true);

if (count($packages) > 1) {
$package = reset($packages);
$io->writeError('<info>Found multiple matches, selected '.$package->getPrettyString().'.</info>');
$io->writeError('Alternatives were '.implode(', ', array_map(function ($p) { return $p->getPrettyString(); }, $packages)).'.');
$io->writeError('<comment>Please use a more specific constraint to pick a different package.</comment>');
} elseif ($packages) {
$package = reset($packages);
$io->writeError('<info>Found an exact match '.$package->getPrettyString().'.</info>');
} else {
$io->writeError('<error>Could not find a package matching '.$packageName.'.</error>');

return false;
}

return $package;
}
}
<?php











namespace Composer\Command;

use Composer\Cache;
use Composer\Factory;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;




class ClearCacheCommand extends Command
{
protected function configure()
{
$this
->setName('clear-cache')
->setAliases(array('clearcache'))
->setDescription('Clears composer\'s internal package cache.')
->setHelp(<<<EOT
The <info>clear-cache</info> deletes all cached packages from composer's
cache directory.
EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
$config = Factory::createConfig();
$io = $this->getIO();

$cachePaths = array(
'cache-dir' => $config->get('cache-dir'),
'cache-files-dir' => $config->get('cache-files-dir'),
'cache-repo-dir' => $config->get('cache-repo-dir'),
'cache-vcs-dir' => $config->get('cache-vcs-dir'),
);

foreach ($cachePaths as $key => $cachePath) {
$cachePath = realpath($cachePath);
if (!$cachePath) {
$io->writeError("<info>Cache directory does not exist ($key): $cachePath</info>");

continue;
}
$cache = new Cache($io, $cachePath);
if (!$cache->isEnabled()) {
$io->writeError("<info>Cache is not enabled ($key): $cachePath</info>");

continue;
}

$io->writeError("<info>Clearing cache ($key): $cachePath</info>");
$cache->gc(0, 0);
}

$io->writeError('<info>All caches cleared.</info>');
}
}
<?php











namespace Composer\Command;

use Composer\Composer;
use Composer\Console\Application;
use Composer\IO\IOInterface;
use Composer\IO\NullIO;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Command\Command as BaseCommand;







abstract class Command extends BaseCommand
{



private $composer;




private $io;







public function getComposer($required = true, $disablePlugins = false)
{
if (null === $this->composer) {
$application = $this->getApplication();
if ($application instanceof Application) {

$this->composer = $application->getComposer($required, $disablePlugins);
} elseif ($required) {
throw new \RuntimeException(
'Could not create a Composer\Composer instance, you must inject '.
'one if this command is not used with a Composer\Console\Application instance'
);
}
}

return $this->composer;
}




public function setComposer(Composer $composer)
{
$this->composer = $composer;
}




public function resetComposer()
{
$this->composer = null;
$this->getApplication()->resetComposer();
}




public function getIO()
{
if (null === $this->io) {
$application = $this->getApplication();
if ($application instanceof Application) {

$this->io = $application->getIO();
} else {
$this->io = new NullIO();
}
}

return $this->io;
}




public function setIO(IOInterface $io)
{
$this->io = $io;
}




protected function initialize(InputInterface $input, OutputInterface $output)
{
if (true === $input->hasParameterOption(array('--no-ansi')) && $input->hasOption('no-progress')) {
$input->setOption('no-progress', true);
}

parent::initialize($input, $output);
}
}
<?php











namespace Composer\Command;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Composer\Config;
use Composer\Config\JsonConfigSource;
use Composer\Factory;
use Composer\Json\JsonFile;





class ConfigCommand extends Command
{



protected $config;




protected $configFile;




protected $configSource;




protected $authConfigFile;




protected $authConfigSource;




protected function configure()
{
$this
->setName('config')
->setDescription('Set config options')
->setDefinition(array(
new InputOption('global', 'g', InputOption::VALUE_NONE, 'Apply command to the global config file'),
new InputOption('editor', 'e', InputOption::VALUE_NONE, 'Open editor'),
new InputOption('auth', 'a', InputOption::VALUE_NONE, 'Affect auth config file (only used for --editor)'),
new InputOption('unset', null, InputOption::VALUE_NONE, 'Unset the given setting-key'),
new InputOption('list', 'l', InputOption::VALUE_NONE, 'List configuration settings'),
new InputOption('file', 'f', InputOption::VALUE_REQUIRED, 'If you want to choose a different composer.json or config.json', 'composer.json'),
new InputOption('absolute', null, InputOption::VALUE_NONE, 'Returns absolute paths when fetching *-dir config values instead of relative'),
new InputArgument('setting-key', null, 'Setting key'),
new InputArgument('setting-value', InputArgument::IS_ARRAY, 'Setting value'),
))
->setHelp(<<<EOT
This command allows you to edit some basic composer settings in either the
local composer.json file or the global config.json file.

To set a config setting:

    <comment>%command.full_name% bin-dir bin/</comment>

To read a config setting:

    <comment>%command.full_name% bin-dir</comment>
    Outputs: <info>bin</info>

To edit the global config.json file:

    <comment>%command.full_name% --global</comment>

To add a repository:

    <comment>%command.full_name% repositories.foo vcs http://bar.com</comment>

To remove a repository (repo is a short alias for repositories):

    <comment>%command.full_name% --unset repo.foo</comment>

To disable packagist:

    <comment>%command.full_name% repo.packagist false</comment>

You can alter repositories in the global config.json file by passing in the
<info>--global</info> option.

To edit the file in an external editor:

    <comment>%command.full_name% --editor</comment>

To choose your editor you can set the "EDITOR" env variable.

To get a list of configuration values in the file:

    <comment>%command.full_name% --list</comment>

You can always pass more than one option. As an example, if you want to edit the
global config.json file.

    <comment>%command.full_name% --editor --global</comment>
EOT
)
;
}




protected function initialize(InputInterface $input, OutputInterface $output)
{
parent::initialize($input, $output);

if ($input->getOption('global') && 'composer.json' !== $input->getOption('file')) {
throw new \RuntimeException('--file and --global can not be combined');
}

$this->config = Factory::createConfig($this->getIO());


 
 $configFile = $input->getOption('global')
? ($this->config->get('home') . '/config.json')
: $input->getOption('file');


 if ($configFile === 'composer.json' && !file_exists($configFile) && realpath(getcwd()) === realpath($this->config->get('home'))) {
file_put_contents($configFile, "{\n}\n");
}

$this->configFile = new JsonFile($configFile);
$this->configSource = new JsonConfigSource($this->configFile);

$authConfigFile = $input->getOption('global')
? ($this->config->get('home') . '/auth.json')
: dirname(realpath($input->getOption('file'))) . '/auth.json';

$this->authConfigFile = new JsonFile($authConfigFile);
$this->authConfigSource = new JsonConfigSource($this->authConfigFile, true);


 if ($input->getOption('global') && !$this->configFile->exists()) {
touch($this->configFile->getPath());
$this->configFile->write(array('config' => new \ArrayObject));
@chmod($this->configFile->getPath(), 0600);
}
if ($input->getOption('global') && !$this->authConfigFile->exists()) {
touch($this->authConfigFile->getPath());
$this->authConfigFile->write(array('http-basic' => new \ArrayObject, 'github-oauth' => new \ArrayObject));
@chmod($this->authConfigFile->getPath(), 0600);
}

if (!$this->configFile->exists()) {
throw new \RuntimeException(sprintf('File "%s" cannot be found in the current directory', $configFile));
}
}




protected function execute(InputInterface $input, OutputInterface $output)
{

 if ($input->getOption('editor')) {
$editor = escapeshellcmd(getenv('EDITOR'));
if (!$editor) {
if (defined('PHP_WINDOWS_VERSION_BUILD')) {
$editor = 'notepad';
} else {
foreach (array('vim', 'vi', 'nano', 'pico', 'ed') as $candidate) {
if (exec('which '.$candidate)) {
$editor = $candidate;
break;
}
}
}
}

$file = $input->getOption('auth') ? $this->authConfigFile->getPath() : $this->configFile->getPath();
system($editor . ' ' . $file . (defined('PHP_WINDOWS_VERSION_BUILD') ? '' : ' > `tty`'));

return 0;
}

if (!$input->getOption('global')) {
$this->config->merge($this->configFile->read());
$this->config->merge(array('config' => $this->authConfigFile->exists() ? $this->authConfigFile->read() : array()));
}


 if ($input->getOption('list')) {
$this->listConfiguration($this->config->all(), $this->config->raw(), $output);

return 0;
}

$settingKey = $input->getArgument('setting-key');
if (!$settingKey) {
return 0;
}


 if (array() !== $input->getArgument('setting-value') && $input->getOption('unset')) {
throw new \RuntimeException('You can not combine a setting value with --unset');
}


 if (array() === $input->getArgument('setting-value') && !$input->getOption('unset')) {
$data = $this->config->all();
if (preg_match('/^repos?(?:itories)?(?:\.(.+))?/', $settingKey, $matches)) {
if (empty($matches[1])) {
$value = isset($data['repositories']) ? $data['repositories'] : array();
} else {
if (!isset($data['repositories'][$matches[1]])) {
throw new \InvalidArgumentException('There is no '.$matches[1].' repository defined');
}

$value = $data['repositories'][$matches[1]];
}
} elseif (strpos($settingKey, '.')) {
$bits = explode('.', $settingKey);
$data = $data['config'];
foreach ($bits as $bit) {
if (isset($data[$bit])) {
$data = $data[$bit];
} elseif (isset($data[implode('.', $bits)])) {

 $data = $data[implode('.', $bits)];
break;
} else {
throw new \RuntimeException($settingKey.' is not defined');
}
array_shift($bits);
}

$value = $data;
} elseif (isset($data['config'][$settingKey])) {
$value = $this->config->get($settingKey, $input->getOption('absolute') ? 0 : Config::RELATIVE_PATHS);
} else {
throw new \RuntimeException($settingKey.' is not defined');
}

if (is_array($value)) {
$value = json_encode($value);
}

$this->getIO()->write($value);

return 0;
}

$values = $input->getArgument('setting-value'); 

$booleanValidator = function ($val) { return in_array($val, array('true', 'false', '1', '0'), true); };
$booleanNormalizer = function ($val) { return $val !== 'false' && (bool) $val; };


 $uniqueConfigValues = array(
'process-timeout' => array('is_numeric', 'intval'),
'use-include-path' => array($booleanValidator, $booleanNormalizer),
'preferred-install' => array(
function ($val) { return in_array($val, array('auto', 'source', 'dist'), true); },
function ($val) { return $val; }
),
'store-auths' => array(
function ($val) { return in_array($val, array('true', 'false', 'prompt'), true); },
function ($val) {
if ('prompt' === $val) {
return 'prompt';
}

return $val !== 'false' && (bool) $val;
}
),
'notify-on-install' => array($booleanValidator, $booleanNormalizer),
'vendor-dir' => array('is_string', function ($val) { return $val; }),
'bin-dir' => array('is_string', function ($val) { return $val; }),
'cache-dir' => array('is_string', function ($val) { return $val; }),
'cache-files-dir' => array('is_string', function ($val) { return $val; }),
'cache-repo-dir' => array('is_string', function ($val) { return $val; }),
'cache-vcs-dir' => array('is_string', function ($val) { return $val; }),
'cache-ttl' => array('is_numeric', 'intval'),
'cache-files-ttl' => array('is_numeric', 'intval'),
'cache-files-maxsize' => array(
function ($val) { return preg_match('/^\s*([0-9.]+)\s*(?:([kmg])(?:i?b)?)?\s*$/i', $val) > 0; },
function ($val) { return $val; }
),
'discard-changes' => array(
function ($val) { return in_array($val, array('stash', 'true', 'false', '1', '0'), true); },
function ($val) {
if ('stash' === $val) {
return 'stash';
}

return $val !== 'false' && (bool) $val;
}
),
'autoloader-suffix' => array('is_string', function ($val) { return $val === 'null' ? null : $val; }),
'optimize-autoloader' => array($booleanValidator, $booleanNormalizer),
'classmap-authoritative' => array($booleanValidator, $booleanNormalizer),
'prepend-autoloader' => array($booleanValidator, $booleanNormalizer),
'github-expose-hostname' => array($booleanValidator, $booleanNormalizer),
);
$multiConfigValues = array(
'github-protocols' => array(
function ($vals) {
if (!is_array($vals)) {
return 'array expected';
}

foreach ($vals as $val) {
if (!in_array($val, array('git', 'https', 'ssh'))) {
return 'valid protocols include: git, https, ssh';
}
}

return true;
},
function ($vals) {
return $vals;
}
),
'github-domains' => array(
function ($vals) {
if (!is_array($vals)) {
return 'array expected';
}

return true;
},
function ($vals) {
return $vals;
}
),
);

foreach ($uniqueConfigValues as $name => $callbacks) {
if ($settingKey === $name) {
if ($input->getOption('unset')) {
return $this->configSource->removeConfigSetting($settingKey);
}

list($validator, $normalizer) = $callbacks;
if (1 !== count($values)) {
throw new \RuntimeException('You can only pass one value. Example: php composer.phar config process-timeout 300');
}

if (true !== $validation = $validator($values[0])) {
throw new \RuntimeException(sprintf(
'"%s" is an invalid value'.($validation ? ' ('.$validation.')' : ''),
$values[0]
));
}

return $this->configSource->addConfigSetting($settingKey, $normalizer($values[0]));
}
}

foreach ($multiConfigValues as $name => $callbacks) {
if ($settingKey === $name) {
if ($input->getOption('unset')) {
return $this->configSource->removeConfigSetting($settingKey);
}

list($validator, $normalizer) = $callbacks;
if (true !== $validation = $validator($values)) {
throw new \RuntimeException(sprintf(
'%s is an invalid value'.($validation ? ' ('.$validation.')' : ''),
json_encode($values)
));
}

return $this->configSource->addConfigSetting($settingKey, $normalizer($values));
}
}


 if (preg_match('/^repos?(?:itories)?\.(.+)/', $settingKey, $matches)) {
if ($input->getOption('unset')) {
return $this->configSource->removeRepository($matches[1]);
}

if (2 === count($values)) {
return $this->configSource->addRepository($matches[1], array(
'type' => $values[0],
'url' => $values[1],
));
}

if (1 === count($values)) {
$bool = strtolower($values[0]);
if (true === $booleanValidator($bool) && false === $booleanNormalizer($bool)) {
return $this->configSource->addRepository($matches[1], false);
}
}

throw new \RuntimeException('You must pass the type and a url. Example: php composer.phar config repositories.foo vcs http://bar.com');
}


 if (preg_match('/^platform\.(.+)/', $settingKey, $matches)) {
if ($input->getOption('unset')) {
return $this->configSource->removeConfigSetting($settingKey);
}

return $this->configSource->addConfigSetting($settingKey, $values[0]);
}


 if (preg_match('/^(github-oauth|http-basic)\.(.+)/', $settingKey, $matches)) {
if ($input->getOption('unset')) {
$this->authConfigSource->removeConfigSetting($matches[1].'.'.$matches[2]);
$this->configSource->removeConfigSetting($matches[1].'.'.$matches[2]);

return;
}

if ($matches[1] === 'github-oauth') {
if (1 !== count($values)) {
throw new \RuntimeException('Too many arguments, expected only one token');
}
$this->configSource->removeConfigSetting($matches[1].'.'.$matches[2]);
$this->authConfigSource->addConfigSetting($matches[1].'.'.$matches[2], $values[0]);
} elseif ($matches[1] === 'http-basic') {
if (2 !== count($values)) {
throw new \RuntimeException('Expected two arguments (username, password), got '.count($values));
}
$this->configSource->removeConfigSetting($matches[1].'.'.$matches[2]);
$this->authConfigSource->addConfigSetting($matches[1].'.'.$matches[2], array('username' => $values[0], 'password' => $values[1]));
}

return;
}

throw new \InvalidArgumentException('Setting '.$settingKey.' does not exist or is not supported by this command');
}









protected function listConfiguration(array $contents, array $rawContents, OutputInterface $output, $k = null)
{
$origK = $k;
foreach ($contents as $key => $value) {
if ($k === null && !in_array($key, array('config', 'repositories'))) {
continue;
}

$rawVal = isset($rawContents[$key]) ? $rawContents[$key] : null;

if (is_array($value) && (!is_numeric(key($value)) || ($key === 'repositories' && null === $k))) {
$k .= preg_replace('{^config\.}', '', $key . '.');
$this->listConfiguration($value, $rawVal, $output, $k);

if (substr_count($k, '.') > 1) {
$k = str_split($k, strrpos($k, '.', -2));
$k = $k[0] . '.';
} else {
$k = $origK;
}

continue;
}

if (is_array($value)) {
$value = array_map(function ($val) {
return is_array($val) ? json_encode($val) : $val;
}, $value);

$value = '['.implode(', ', $value).']';
}

if (is_bool($value)) {
$value = var_export($value, true);
}

if (is_string($rawVal) && $rawVal != $value) {
$this->getIO()->write('[<comment>' . $k . $key . '</comment>] <info>' . $rawVal . ' (' . $value . ')</info>');
} else {
$this->getIO()->write('[<comment>' . $k . $key . '</comment>] <info>' . $value . '</info>');
}
}
}
}
<?php











namespace Composer\Command;

use Composer\Config;
use Composer\Factory;
use Composer\Installer;
use Composer\Installer\ProjectInstaller;
use Composer\Installer\InstallationManager;
use Composer\IO\IOInterface;
use Composer\Package\BasePackage;
use Composer\DependencyResolver\Pool;
use Composer\DependencyResolver\Operation\InstallOperation;
use Composer\Package\Version\VersionSelector;
use Composer\Repository\ComposerRepository;
use Composer\Repository\CompositeRepository;
use Composer\Repository\FilesystemRepository;
use Composer\Repository\InstalledFilesystemRepository;
use Composer\Script\ScriptEvents;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Finder\Finder;
use Composer\Json\JsonFile;
use Composer\Config\JsonConfigSource;
use Composer\Util\Filesystem;
use Composer\Util\RemoteFilesystem;
use Composer\Package\Version\VersionParser;









class CreateProjectCommand extends Command
{
protected function configure()
{
$this
->setName('create-project')
->setDescription('Create new project from a package into given directory.')
->setDefinition(array(
new InputArgument('package', InputArgument::OPTIONAL, 'Package name to be installed'),
new InputArgument('directory', InputArgument::OPTIONAL, 'Directory where the files should be created'),
new InputArgument('version', InputArgument::OPTIONAL, 'Version, will default to latest'),
new InputOption('stability', 's', InputOption::VALUE_REQUIRED, 'Minimum-stability allowed (unless a version is specified).'),
new InputOption('prefer-source', null, InputOption::VALUE_NONE, 'Forces installation from package sources when possible, including VCS information.'),
new InputOption('prefer-dist', null, InputOption::VALUE_NONE, 'Forces installation from package dist even for dev versions.'),
new InputOption('repository-url', null, InputOption::VALUE_REQUIRED, 'Pick a different repository url to look for the package.'),
new InputOption('dev', null, InputOption::VALUE_NONE, 'Enables installation of require-dev packages (enabled by default, only present for BC).'),
new InputOption('no-dev', null, InputOption::VALUE_NONE, 'Disables installation of require-dev packages.'),
new InputOption('no-plugins', null, InputOption::VALUE_NONE, 'Whether to disable plugins.'),
new InputOption('no-custom-installers', null, InputOption::VALUE_NONE, 'DEPRECATED: Use no-plugins instead.'),
new InputOption('no-scripts', null, InputOption::VALUE_NONE, 'Whether to prevent execution of all defined scripts in the root package.'),
new InputOption('no-progress', null, InputOption::VALUE_NONE, 'Do not output download progress.'),
new InputOption('keep-vcs', null, InputOption::VALUE_NONE, 'Whether to prevent deletion vcs folder.'),
new InputOption('no-install', null, InputOption::VALUE_NONE, 'Whether to skip installation of the package dependencies.'),
new InputOption('ignore-platform-reqs', null, InputOption::VALUE_NONE, 'Ignore platform requirements (php & ext- packages).'),
))
->setHelp(<<<EOT
The <info>create-project</info> command creates a new project from a given
package into a new directory. If executed without params and in a directory
with a composer.json file it installs the packages for the current project.

You can use this command to bootstrap new projects or setup a clean
version-controlled installation for developers of your project.

<info>php composer.phar create-project vendor/project target-directory [version]</info>

You can also specify the version with the package name using = or : as separator.

To install unstable packages, either specify the version you want, or use the
--stability=dev (where dev can be one of RC, beta, alpha or dev).

To setup a developer workable version you should create the project using the source
controlled code by appending the <info>'--prefer-source'</info> flag.

To install a package from another repository than the default one you
can pass the <info>'--repository-url=http://myrepository.org'</info> flag.

EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
$config = Factory::createConfig();

$preferSource = false;
$preferDist = false;
$this->updatePreferredOptions($config, $input, $preferSource, $preferDist);

if ($input->getOption('no-custom-installers')) {
$this->getIO()->writeError('<warning>You are using the deprecated option "no-custom-installers". Use "no-plugins" instead.</warning>');
$input->setOption('no-plugins', true);
}

return $this->installProject(
$this->getIO(),
$config,
$input->getArgument('package'),
$input->getArgument('directory'),
$input->getArgument('version'),
$input->getOption('stability'),
$preferSource,
$preferDist,
!$input->getOption('no-dev'),
$input->getOption('repository-url'),
$input->getOption('no-plugins'),
$input->getOption('no-scripts'),
$input->getOption('keep-vcs'),
$input->getOption('no-progress'),
$input->getOption('no-install'),
$input->getOption('ignore-platform-reqs'),
$input
);
}

public function installProject(IOInterface $io, Config $config, $packageName, $directory = null, $packageVersion = null, $stability = 'stable', $preferSource = false, $preferDist = false, $installDevPackages = false, $repositoryUrl = null, $disablePlugins = false, $noScripts = false, $keepVcs = false, $noProgress = false, $noInstall = false, $ignorePlatformReqs = false, InputInterface $input)
{
$oldCwd = getcwd();


 $io->loadConfiguration($config);

if ($packageName !== null) {
$installedFromVcs = $this->installRootPackage($io, $config, $packageName, $directory, $packageVersion, $stability, $preferSource, $preferDist, $installDevPackages, $repositoryUrl, $disablePlugins, $noScripts, $keepVcs, $noProgress);
} else {
$installedFromVcs = false;
}

$composer = Factory::create($io, null, $disablePlugins);
$composer->getDownloadManager()->setOutputProgress(!$noProgress);

$fs = new Filesystem();

if ($noScripts === false) {

 $composer->getEventDispatcher()->dispatchScript(ScriptEvents::POST_ROOT_PACKAGE_INSTALL, $installDevPackages);
}

$rootPackageConfig = $composer->getConfig();
$this->updatePreferredOptions($rootPackageConfig, $input, $preferSource, $preferDist);


 if ($noInstall === false) {
$installer = Installer::create($io, $composer);
$installer->setPreferSource($preferSource)
->setPreferDist($preferDist)
->setDevMode($installDevPackages)
->setRunScripts(!$noScripts)
->setIgnorePlatformRequirements($ignorePlatformReqs);

if ($disablePlugins) {
$installer->disablePlugins();
}

$status = $installer->run();
if (0 !== $status) {
return $status;
}
}

$hasVcs = $installedFromVcs;
if (!$keepVcs && $installedFromVcs
&& (
!$io->isInteractive()
|| $io->askConfirmation('<info>Do you want to remove the existing VCS (.git, .svn..) history?</info> [<comment>Y,n</comment>]? ', true)
)
) {
$finder = new Finder();
$finder->depth(0)->directories()->in(getcwd())->ignoreVCS(false)->ignoreDotFiles(false);
foreach (array('.svn', '_svn', 'CVS', '_darcs', '.arch-params', '.monotone', '.bzr', '.git', '.hg') as $vcsName) {
$finder->name($vcsName);
}

try {
$dirs = iterator_to_array($finder);
unset($finder);
foreach ($dirs as $dir) {
if (!$fs->removeDirectory($dir)) {
throw new \RuntimeException('Could not remove '.$dir);
}
}
} catch (\Exception $e) {
$io->writeError('<error>An error occurred while removing the VCS metadata: '.$e->getMessage().'</error>');
}

$hasVcs = false;
}


 if (!$hasVcs) {
$package = $composer->getPackage();
$configSource = new JsonConfigSource(new JsonFile('composer.json'));
foreach (BasePackage::$supportedLinkTypes as $type => $meta) {
foreach ($package->{'get'.$meta['method']}() as $link) {
if ($link->getPrettyConstraint() === 'self.version') {
$configSource->addLink($type, $link->getTarget(), $package->getPrettyVersion());
}
}
}
}

if ($noScripts === false) {

 $composer->getEventDispatcher()->dispatchScript(ScriptEvents::POST_CREATE_PROJECT_CMD, $installDevPackages);
}

chdir($oldCwd);
$vendorComposerDir = $composer->getConfig()->get('vendor-dir').'/composer';
if (is_dir($vendorComposerDir) && $fs->isDirEmpty($vendorComposerDir)) {
@rmdir($vendorComposerDir);
$vendorDir = $composer->getConfig()->get('vendor-dir');
if (is_dir($vendorDir) && $fs->isDirEmpty($vendorDir)) {
@rmdir($vendorDir);
}
}

return 0;
}

protected function installRootPackage(IOInterface $io, Config $config, $packageName, $directory = null, $packageVersion = null, $stability = 'stable', $preferSource = false, $preferDist = false, $installDevPackages = false, $repositoryUrl = null, $disablePlugins = false, $noScripts = false, $keepVcs = false, $noProgress = false)
{
if (null === $repositoryUrl) {
$sourceRepo = new CompositeRepository(Factory::createDefaultRepositories($io, $config));
} elseif ("json" === pathinfo($repositoryUrl, PATHINFO_EXTENSION) && file_exists($repositoryUrl)) {
$json = new JsonFile($repositoryUrl, new RemoteFilesystem($io, $config));
$data = $json->read();
if (!empty($data['packages']) || !empty($data['includes']) || !empty($data['provider-includes'])) {
$sourceRepo = new ComposerRepository(array('url' => 'file://' . strtr(realpath($repositoryUrl), '\\', '/')), $io, $config);
} else {
$sourceRepo = new FilesystemRepository($json);
}
} elseif (0 === strpos($repositoryUrl, 'http')) {
$sourceRepo = new ComposerRepository(array('url' => $repositoryUrl), $io, $config);
} else {
throw new \InvalidArgumentException("Invalid repository url given. Has to be a .json file or an http url.");
}

$parser = new VersionParser();
$requirements = $parser->parseNameVersionPairs(array($packageName));
$name = strtolower($requirements[0]['name']);
if (!$packageVersion && isset($requirements[0]['version'])) {
$packageVersion = $requirements[0]['version'];
}

if (null === $stability) {
if (preg_match('{^[^,\s]*?@('.implode('|', array_keys(BasePackage::$stabilities)).')$}i', $packageVersion, $match)) {
$stability = $match[1];
} else {
$stability = VersionParser::parseStability($packageVersion);
}
}

$stability = VersionParser::normalizeStability($stability);

if (!isset(BasePackage::$stabilities[$stability])) {
throw new \InvalidArgumentException('Invalid stability provided ('.$stability.'), must be one of: '.implode(', ', array_keys(BasePackage::$stabilities)));
}

$pool = new Pool($stability);
$pool->addRepository($sourceRepo);


 $versionSelector = new VersionSelector($pool);
$package = $versionSelector->findBestCandidate($name, $packageVersion);

if (!$package) {
throw new \InvalidArgumentException("Could not find package $name" . ($packageVersion ? " with version $packageVersion." : " with stability $stability."));
}

if (null === $directory) {
$parts = explode("/", $name, 2);
$directory = getcwd() . DIRECTORY_SEPARATOR . array_pop($parts);
}

$io->writeError('<info>Installing ' . $package->getName() . ' (' . VersionParser::formatVersion($package, false) . ')</info>');

if ($disablePlugins) {
$io->writeError('<info>Plugins have been disabled.</info>');
}

if (0 === strpos($package->getPrettyVersion(), 'dev-') && in_array($package->getSourceType(), array('git', 'hg'))) {
$package->setSourceReference(substr($package->getPrettyVersion(), 4));
}

$dm = $this->createDownloadManager($io, $config);
$dm->setPreferSource($preferSource)
->setPreferDist($preferDist)
->setOutputProgress(!$noProgress);

$projectInstaller = new ProjectInstaller($directory, $dm);
$im = $this->createInstallationManager();
$im->addInstaller($projectInstaller);
$im->install(new InstalledFilesystemRepository(new JsonFile('php://memory')), new InstallOperation($package));
$im->notifyInstalls();

$installedFromVcs = 'source' === $package->getInstallationSource();

$io->writeError('<info>Created project in ' . $directory . '</info>');
chdir($directory);

$_SERVER['COMPOSER_ROOT_VERSION'] = $package->getPrettyVersion();
putenv('COMPOSER_ROOT_VERSION='.$_SERVER['COMPOSER_ROOT_VERSION']);

return $installedFromVcs;
}

protected function createDownloadManager(IOInterface $io, Config $config)
{
$factory = new Factory();

return $factory->createDownloadManager($io, $config);
}

protected function createInstallationManager()
{
return new InstallationManager();
}








protected function updatePreferredOptions(Config $config, InputInterface $input, &$preferSource, &$preferDist)
{
switch ($config->get('preferred-install')) {
case 'source':
$preferSource = true;
$preferDist = false;
break;
case 'dist':
$preferSource = false;
$preferDist = true;
break;
case 'auto':
default:

 break;
}

if ($input->getOption('prefer-source') || $input->getOption('prefer-dist') || $input->getOption('keep-vcs')) {
$preferSource = $input->getOption('prefer-source') || $input->getOption('keep-vcs');
$preferDist = $input->getOption('prefer-dist');
}
}
}
<?php











namespace Composer\Command;

use Composer\DependencyResolver\Pool;
use Composer\Plugin\CommandEvent;
use Composer\Plugin\PluginEvents;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;





class DependsCommand extends Command
{
protected $linkTypes = array(
'require' => array('requires', 'requires'),
'require-dev' => array('devRequires', 'requires (dev)'),
);

protected function configure()
{
$this
->setName('depends')
->setDescription('Shows which packages depend on the given package')
->setDefinition(array(
new InputArgument('package', InputArgument::REQUIRED, 'Package to inspect'),
new InputOption('link-type', '', InputOption::VALUE_REQUIRED | InputOption::VALUE_IS_ARRAY, 'Link types to show (require, require-dev)', array_keys($this->linkTypes)),
))
->setHelp(<<<EOT
Displays detailed information about where a package is referenced.

<info>php composer.phar depends composer/composer</info>

EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
$composer = $this->getComposer();

$commandEvent = new CommandEvent(PluginEvents::COMMAND, 'depends', $input, $output);
$composer->getEventDispatcher()->dispatch($commandEvent->getName(), $commandEvent);

$repo = $composer->getRepositoryManager()->getLocalRepository();
$needle = $input->getArgument('package');

$pool = new Pool();
$pool->addRepository($repo);

$packages = $pool->whatProvides($needle);
if (empty($packages)) {
throw new \InvalidArgumentException('Could not find package "'.$needle.'" in your project.');
}

$linkTypes = $this->linkTypes;

$types = array_map(function ($type) use ($linkTypes) {
$type = rtrim($type, 's');
if (!isset($linkTypes[$type])) {
throw new \InvalidArgumentException('Unexpected link type: '.$type.', valid types: '.implode(', ', array_keys($linkTypes)));
}

return $type;
}, $input->getOption('link-type'));

$messages = array();
$outputPackages = array();
foreach ($repo->getPackages() as $package) {
foreach ($types as $type) {
foreach ($package->{'get'.$linkTypes[$type][0]}() as $link) {
if ($link->getTarget() === $needle) {
if (!isset($outputPackages[$package->getName()])) {
$messages[] = '<info>'.$package->getPrettyName() . '</info> ' . $linkTypes[$type][1] . ' ' . $needle .' (<info>' . $link->getPrettyConstraint() . '</info>)';
$outputPackages[$package->getName()] = true;
}
}
}
}
}

if ($messages) {
sort($messages);
$this->getIO()->write($messages);
} else {
$this->getIO()->writeError('<info>There is no installed package depending on "'.$needle.'".</info>');
}
}
}
<?php











namespace Composer\Command;

use Composer\Composer;
use Composer\Factory;
use Composer\Downloader\TransportException;
use Composer\Plugin\CommandEvent;
use Composer\Plugin\PluginEvents;
use Composer\Util\ConfigValidator;
use Composer\Util\ProcessExecutor;
use Composer\Util\RemoteFilesystem;
use Composer\Util\StreamContextFactory;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;




class DiagnoseCommand extends Command
{

protected $rfs;


protected $process;


protected $failures = 0;

protected function configure()
{
$this
->setName('diagnose')
->setDescription('Diagnoses the system to identify common errors.')
->setHelp(<<<EOT
The <info>diagnose</info> command checks common errors to help debugging problems.

EOT
)
;
}




protected function execute(InputInterface $input, OutputInterface $output)
{
$composer = $this->getComposer(false);

if ($composer) {
$commandEvent = new CommandEvent(PluginEvents::COMMAND, 'diagnose', $input, $output);
$composer->getEventDispatcher()->dispatch($commandEvent->getName(), $commandEvent);

$this->getIO()->write('Checking composer.json: ', false);
$this->outputResult($this->checkComposerSchema());
}

if ($composer) {
$config = $composer->getConfig();
} else {
$config = Factory::createConfig();
}

$this->rfs = new RemoteFilesystem($this->getIO(), $config);
$this->process = new ProcessExecutor($this->getIO());

$this->getIO()->write('Checking platform settings: ', false);
$this->outputResult($this->checkPlatform());

$this->getIO()->write('Checking git settings: ', false);
$this->outputResult($this->checkGit());

$this->getIO()->write('Checking http connectivity: ', false);
$this->outputResult($this->checkHttp());

$opts = stream_context_get_options(StreamContextFactory::getContext('http://example.org'));
if (!empty($opts['http']['proxy'])) {
$this->getIO()->write('Checking HTTP proxy: ', false);
$this->outputResult($this->checkHttpProxy());
$this->getIO()->write('Checking HTTP proxy support for request_fulluri: ', false);
$this->outputResult($this->checkHttpProxyFullUriRequestParam());
$this->getIO()->write('Checking HTTPS proxy support for request_fulluri: ', false);
$this->outputResult($this->checkHttpsProxyFullUriRequestParam());
}

if ($oauth = $config->get('github-oauth')) {
foreach ($oauth as $domain => $token) {
$this->getIO()->write('Checking '.$domain.' oauth access: ', false);
$this->outputResult($this->checkGithubOauth($domain, $token));
}
} else {
$this->getIO()->write('Checking github.com rate limit: ', false);
try {
$rate = $this->getGithubRateLimit('github.com');
$this->outputResult(true);
if (10 > $rate['remaining']) {
$this->getIO()->write('<warning>WARNING</warning>');
$this->getIO()->write(sprintf(
'<comment>Github has a rate limit on their API. '
. 'You currently have <options=bold>%u</options=bold> '
. 'out of <options=bold>%u</options=bold> requests left.' . PHP_EOL
. 'See https://developer.github.com/v3/#rate-limiting and also' . PHP_EOL
. '    https://getcomposer.org/doc/articles/troubleshooting.md#api-rate-limit-and-oauth-tokens</comment>',
$rate['remaining'],
$rate['limit']
));
}
} catch (\Exception $e) {
if ($e instanceof TransportException && $e->getCode() === 401) {
$this->outputResult('<comment>The oauth token for github.com seems invalid, run "composer config --global --unset github-oauth.github.com" to remove it</comment>');
} else {
$this->outputResult($e);
}
}
}

$this->getIO()->write('Checking disk free space: ', false);
$this->outputResult($this->checkDiskSpace($config));

$this->getIO()->write('Checking composer version: ', false);
$this->outputResult($this->checkVersion());

return $this->failures;
}

private function checkComposerSchema()
{
$validator = new ConfigValidator($this->getIO());
list($errors, $publishErrors, $warnings) = $validator->validate(Factory::getComposerFile());

if ($errors || $publishErrors || $warnings) {
$messages = array(
'error' => array_merge($errors, $publishErrors),
'warning' => $warnings,
);

$output = '';
foreach ($messages as $style => $msgs) {
foreach ($msgs as $msg) {
$output .= '<' . $style . '>' . $msg . '</' . $style . '>' . PHP_EOL;
}
}

return rtrim($output);
}

return true;
}

private function checkGit()
{
$this->process->execute('git config color.ui', $output);
if (strtolower(trim($output)) === 'always') {
return '<comment>Your git color.ui setting is set to always, this is known to create issues. Use "git config --global color.ui true" to set it correctly.</comment>';
}

return true;
}

private function checkHttp()
{
$protocol = extension_loaded('openssl') ? 'https' : 'http';
try {
$this->rfs->getContents('packagist.org', $protocol . '://packagist.org/packages.json', false);
} catch (\Exception $e) {
return $e;
}

return true;
}

private function checkHttpProxy()
{
$protocol = extension_loaded('openssl') ? 'https' : 'http';
try {
$json = json_decode($this->rfs->getContents('packagist.org', $protocol . '://packagist.org/packages.json', false), true);
$hash = reset($json['provider-includes']);
$hash = $hash['sha256'];
$path = str_replace('%hash%', $hash, key($json['provider-includes']));
$provider = $this->rfs->getContents('packagist.org', $protocol . '://packagist.org/'.$path, false);

if (hash('sha256', $provider) !== $hash) {
return 'It seems that your proxy is modifying http traffic on the fly';
}
} catch (\Exception $e) {
return $e;
}

return true;
}








private function checkHttpProxyFullUriRequestParam()
{
$url = 'http://packagist.org/packages.json';
try {
$this->rfs->getContents('packagist.org', $url, false);
} catch (TransportException $e) {
try {
$this->rfs->getContents('packagist.org', $url, false, array('http' => array('request_fulluri' => false)));
} catch (TransportException $e) {
return 'Unable to assess the situation, maybe packagist.org is down ('.$e->getMessage().')';
}

return 'It seems there is a problem with your proxy server, try setting the "HTTP_PROXY_REQUEST_FULLURI" and "HTTPS_PROXY_REQUEST_FULLURI" environment variables to "false"';
}

return true;
}








private function checkHttpsProxyFullUriRequestParam()
{
if (!extension_loaded('openssl')) {
return 'You need the openssl extension installed for this check';
}

$url = 'https://api.github.com/repos/Seldaek/jsonlint/zipball/1.0.0';
try {
$this->rfs->getContents('github.com', $url, false);
} catch (TransportException $e) {
try {
$this->rfs->getContents('github.com', $url, false, array('http' => array('request_fulluri' => false)));
} catch (TransportException $e) {
return 'Unable to assess the situation, maybe github is down ('.$e->getMessage().')';
}

return 'It seems there is a problem with your proxy server, try setting the "HTTPS_PROXY_REQUEST_FULLURI" environment variable to "false"';
}

return true;
}

private function checkGithubOauth($domain, $token)
{
$this->getIO()->setAuthentication($domain, $token, 'x-oauth-basic');
try {
$url = $domain === 'github.com' ? 'https://api.'.$domain.'/user/repos' : 'https://'.$domain.'/api/v3/user/repos';

return $this->rfs->getContents($domain, $url, false, array(
'retry-auth-failure' => false
)) ? true : 'Unexpected error';
} catch (\Exception $e) {
if ($e instanceof TransportException && $e->getCode() === 401) {
return '<comment>The oauth token for '.$domain.' seems invalid, run "composer config --global --unset github-oauth.'.$domain.'" to remove it</comment>';
}

return $e;
}
}







private function getGithubRateLimit($domain, $token = null)
{
if ($token) {
$this->getIO()->setAuthentication($domain, $token, 'x-oauth-basic');
}

$url = $domain === 'github.com' ? 'https://api.'.$domain.'/rate_limit' : 'https://'.$domain.'/api/rate_limit';
$json = $this->rfs->getContents($domain, $url, false, array('retry-auth-failure' => false));
$data = json_decode($json, true);

return $data['resources']['core'];
}

private function checkDiskSpace($config)
{
$minSpaceFree = 1024*1024;
if ((($df = @disk_free_space($dir = $config->get('home'))) !== false && $df < $minSpaceFree)
|| (($df = @disk_free_space($dir = $config->get('vendor-dir'))) !== false && $df < $minSpaceFree)
) {
return '<error>The disk hosting '.$dir.' is full</error>';
}

return true;
}

private function checkVersion()
{
$protocol = extension_loaded('openssl') ? 'https' : 'http';
$latest = trim($this->rfs->getContents('getcomposer.org', $protocol . '://getcomposer.org/version', false));

if (Composer::VERSION !== $latest && Composer::VERSION !== '@package_version@') {
return '<comment>You are not running the latest version</comment>';
}

return true;
}




private function outputResult($result)
{
if (true === $result) {
$this->getIO()->write('<info>OK</info>');
} else {
$this->failures++;
$this->getIO()->write('<error>FAIL</error>');
if ($result instanceof \Exception) {
$this->getIO()->write('['.get_class($result).'] '.$result->getMessage());
} elseif ($result) {
$this->getIO()->write(trim($result));
}
}
}

private function checkPlatform()
{
$output = '';
$out = function ($msg, $style) use (&$output) {
$output .= '<'.$style.'>'.$msg.'</'.$style.'>'.PHP_EOL;
};


 $errors = array();
$warnings = array();

$iniPath = php_ini_loaded_file();
$displayIniMessage = false;
if ($iniPath) {
$iniMessage = PHP_EOL.PHP_EOL.'The php.ini used by your command-line PHP is: ' . $iniPath;
} else {
$iniMessage = PHP_EOL.PHP_EOL.'A php.ini file does not exist. You will have to create one.';
}
$iniMessage .= PHP_EOL.'If you can not modify the ini file, you can also run `php -d option=value` to modify ini values on the fly. You can use -d multiple times.';

if (!function_exists('json_decode')) {
$errors['json'] = true;
}

if (!extension_loaded('Phar')) {
$errors['phar'] = true;
}

if (!extension_loaded('filter')) {
$errors['filter'] = true;
}

if (!extension_loaded('hash')) {
$errors['hash'] = true;
}

if (!ini_get('allow_url_fopen')) {
$errors['allow_url_fopen'] = true;
}

if (extension_loaded('ionCube Loader') && ioncube_loader_iversion() < 40009) {
$errors['ioncube'] = ioncube_loader_version();
}

if (PHP_VERSION_ID < 50302) {
$errors['php'] = PHP_VERSION;
}

if (!isset($errors['php']) && PHP_VERSION_ID < 50304) {
$warnings['php'] = PHP_VERSION;
}

if (!extension_loaded('openssl')) {
$errors['openssl'] = true;
}

if (!defined('HHVM_VERSION') && !extension_loaded('apcu') && ini_get('apc.enable_cli')) {
$warnings['apc_cli'] = true;
}

ob_start();
phpinfo(INFO_GENERAL);
$phpinfo = ob_get_clean();
if (preg_match('{Configure Command(?: *</td><td class="v">| *=> *)(.*?)(?:</td>|$)}m', $phpinfo, $match)) {
$configure = $match[1];

if (false !== strpos($configure, '--enable-sigchild')) {
$warnings['sigchild'] = true;
}

if (false !== strpos($configure, '--with-curlwrappers')) {
$warnings['curlwrappers'] = true;
}
}

if (ini_get('xdebug.profiler_enabled')) {
$warnings['xdebug_profile'] = true;
} elseif (extension_loaded('xdebug')) {
$warnings['xdebug_loaded'] = true;
}

if (!empty($errors)) {
foreach ($errors as $error => $current) {
switch ($error) {
case 'json':
$text = PHP_EOL."The json extension is missing.".PHP_EOL;
$text .= "Install it or recompile php without --disable-json";
break;

case 'phar':
$text = PHP_EOL."The phar extension is missing.".PHP_EOL;
$text .= "Install it or recompile php without --disable-phar";
break;

case 'filter':
$text = PHP_EOL."The filter extension is missing.".PHP_EOL;
$text .= "Install it or recompile php without --disable-filter";
break;

case 'hash':
$text = PHP_EOL."The hash extension is missing.".PHP_EOL;
$text .= "Install it or recompile php without --disable-hash";
break;

case 'unicode':
$text = PHP_EOL."The detect_unicode setting must be disabled.".PHP_EOL;
$text .= "Add the following to the end of your `php.ini`:".PHP_EOL;
$text .= "    detect_unicode = Off";
$displayIniMessage = true;
break;

case 'suhosin':
$text = PHP_EOL."The suhosin.executor.include.whitelist setting is incorrect.".PHP_EOL;
$text .= "Add the following to the end of your `php.ini` or suhosin.ini (Example path [for Debian]: /etc/php5/cli/conf.d/suhosin.ini):".PHP_EOL;
$text .= "    suhosin.executor.include.whitelist = phar ".$current;
$displayIniMessage = true;
break;

case 'php':
$text = PHP_EOL."Your PHP ({$current}) is too old, you must upgrade to PHP 5.3.2 or higher.";
break;

case 'allow_url_fopen':
$text = PHP_EOL."The allow_url_fopen setting is incorrect.".PHP_EOL;
$text .= "Add the following to the end of your `php.ini`:".PHP_EOL;
$text .= "    allow_url_fopen = On";
$displayIniMessage = true;
break;

case 'ioncube':
$text = PHP_EOL."Your ionCube Loader extension ($current) is incompatible with Phar files.".PHP_EOL;
$text .= "Upgrade to ionCube 4.0.9 or higher or remove this line (path may be different) from your `php.ini` to disable it:".PHP_EOL;
$text .= "    zend_extension = /usr/lib/php5/20090626+lfs/ioncube_loader_lin_5.3.so";
$displayIniMessage = true;
break;

case 'openssl':
$text = PHP_EOL."The openssl extension is missing, which means that secure HTTPS transfers are impossible.".PHP_EOL;
$text .= "If possible you should enable it or recompile php with --with-openssl";
break;
}
$out($text, 'error');
}

$output .= PHP_EOL;
}

if (!empty($warnings)) {
foreach ($warnings as $warning => $current) {
switch ($warning) {
case 'apc_cli':
$text = "The apc.enable_cli setting is incorrect.".PHP_EOL;
$text .= "Add the following to the end of your `php.ini`:".PHP_EOL;
$text .= "  apc.enable_cli = Off";
$displayIniMessage = true;
break;

case 'sigchild':
$text = "PHP was compiled with --enable-sigchild which can cause issues on some platforms.".PHP_EOL;
$text .= "Recompile it without this flag if possible, see also:".PHP_EOL;
$text .= "  https://bugs.php.net/bug.php?id=22999";
break;

case 'curlwrappers':
$text = "PHP was compiled with --with-curlwrappers which will cause issues with HTTP authentication and GitHub.".PHP_EOL;
$text .= " Recompile it without this flag if possible";
break;

case 'php':
$text = "Your PHP ({$current}) is quite old, upgrading to PHP 5.3.4 or higher is recommended.".PHP_EOL;
$text .= " Composer works with 5.3.2+ for most people, but there might be edge case issues.";
break;

case 'xdebug_loaded':
$text = "The xdebug extension is loaded, this can slow down Composer a little.".PHP_EOL;
$text .= " Disabling it when using Composer is recommended.";
break;

case 'xdebug_profile':
$text = "The xdebug.profiler_enabled setting is enabled, this can slow down Composer a lot.".PHP_EOL;
$text .= "Add the following to the end of your `php.ini` to disable it:".PHP_EOL;
$text .= "  xdebug.profiler_enabled = 0";
$displayIniMessage = true;
break;
}
$out($text, 'comment');
}
}

if ($displayIniMessage) {
$out($iniMessage, 'comment');
}

return !$warnings && !$errors ? true : $output;
}
}
<?php











namespace Composer\Command;

use Composer\Plugin\CommandEvent;
use Composer\Plugin\PluginEvents;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;




class DumpAutoloadCommand extends Command
{
protected function configure()
{
$this
->setName('dump-autoload')
->setAliases(array('dumpautoload'))
->setDescription('Dumps the autoloader')
->setDefinition(array(
new InputOption('optimize', 'o', InputOption::VALUE_NONE, 'Optimizes PSR0 and PSR4 packages to be loaded with classmaps too, good for production.'),
new InputOption('no-dev', null, InputOption::VALUE_NONE, 'Disables autoload-dev rules.'),
))
->setHelp(<<<EOT
<info>php composer.phar dump-autoload</info>
EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
$composer = $this->getComposer();

$commandEvent = new CommandEvent(PluginEvents::COMMAND, 'dump-autoload', $input, $output);
$composer->getEventDispatcher()->dispatch($commandEvent->getName(), $commandEvent);

$installationManager = $composer->getInstallationManager();
$localRepo = $composer->getRepositoryManager()->getLocalRepository();
$package = $composer->getPackage();
$config = $composer->getConfig();

$optimize = $input->getOption('optimize') || $config->get('optimize-autoloader') || $config->get('classmap-authoritative');

if ($optimize) {
$this->getIO()->writeError('<info>Generating optimized autoload files</info>');
} else {
$this->getIO()->writeError('<info>Generating autoload files</info>');
}

$generator = $composer->getAutoloadGenerator();
$generator->setDevMode(!$input->getOption('no-dev'));
$generator->dump($config, $localRepo, $package, $installationManager, 'composer', $optimize);
}
}
<?php











namespace Composer\Command;

use Composer\Factory;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\StringInput;
use Symfony\Component\Console\Output\OutputInterface;




class GlobalCommand extends Command
{
protected function configure()
{
$this
->setName('global')
->setDescription('Allows running commands in the global composer dir ($COMPOSER_HOME).')
->setDefinition(array(
new InputArgument('command-name', InputArgument::REQUIRED, ''),
new InputArgument('args', InputArgument::IS_ARRAY | InputArgument::OPTIONAL, ''),
))
->setHelp(<<<EOT
Use this command as a wrapper to run other Composer commands
within the global context of COMPOSER_HOME.

You can use this to install CLI utilities globally, all you need
is to add the COMPOSER_HOME/vendor/bin dir to your PATH env var.

COMPOSER_HOME is c:\Users\<user>\AppData\Roaming\Composer on Windows
and /home/<user>/.composer on unix systems.

Note: This path may vary depending on customizations to bin-dir in
composer.json or the environmental variable COMPOSER_BIN_DIR.

EOT
)
;
}

public function run(InputInterface $input, OutputInterface $output)
{

 $tokens = preg_split('{\s+}', $input->__toString());
$args = array();
foreach ($tokens as $token) {
if ($token && $token[0] !== '-') {
$args[] = $token;
if (count($args) >= 2) {
break;
}
}
}


 if (count($args) < 2) {
return parent::run($input, $output);
}


 $config = Factory::createConfig();
chdir($config->get('home'));
$this->getIO()->writeError('<info>Changed current directory to '.$config->get('home').'</info>');


 $input = new StringInput(preg_replace('{\bg(?:l(?:o(?:b(?:a(?:l)?)?)?)?)?\b}', '', $input->__toString(), 1));

return $this->getApplication()->run($input, $output);
}
}
<?php











namespace Composer\Command;

use Composer\DependencyResolver\Pool;
use Composer\Factory;
use Composer\Package\CompletePackageInterface;
use Composer\Repository\CompositeRepository;
use Composer\Repository\RepositoryInterface;
use Composer\Util\ProcessExecutor;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;




class HomeCommand extends Command
{



protected function configure()
{
$this
->setName('browse')
->setAliases(array('home'))
->setDescription('Opens the package\'s repository URL or homepage in your browser.')
->setDefinition(array(
new InputArgument('packages', InputArgument::IS_ARRAY | InputArgument::REQUIRED, 'Package(s) to browse to.'),
new InputOption('homepage', 'H', InputOption::VALUE_NONE, 'Open the homepage instead of the repository URL.'),
new InputOption('show', 's', InputOption::VALUE_NONE, 'Only show the homepage or repository URL.'),
))
->setHelp(<<<EOT
The home command opens or shows a package's repository URL or
homepage in your default browser.

To open the homepage by default, use -H or --homepage.
To show instead of open the repository or homepage URL, use -s or --show.
EOT
);
}




protected function execute(InputInterface $input, OutputInterface $output)
{
$repos = $this->initializeRepos();
$return = 0;

foreach ($input->getArgument('packages') as $packageName) {
foreach ($repos as $repo) {
$package = $this->getPackage($repo, $packageName);
if ($package instanceof CompletePackageInterface) {
break;
}
}
$package = $this->getPackage($repo, $packageName);

if (!$package instanceof CompletePackageInterface) {
$return = 1;
$this->getIO()->writeError('<warning>Package '.$packageName.' not found</warning>');

continue;
}

$support = $package->getSupport();
$url = isset($support['source']) ? $support['source'] : $package->getSourceUrl();
if (!$url || $input->getOption('homepage')) {
$url = $package->getHomepage();
}

if (!filter_var($url, FILTER_VALIDATE_URL)) {
$return = 1;
$this->getIO()->writeError('<warning>'.($input->getOption('homepage') ? 'Invalid or missing homepage' : 'Invalid or missing repository URL').' for '.$packageName.'</warning>');

continue;
}

if ($input->getOption('show')) {
$this->getIO()->write(sprintf('<info>%s</info>', $url));
} else {
$this->openBrowser($url);
}
}

return $return;
}








protected function getPackage(RepositoryInterface $repos, $name)
{
$name = strtolower($name);
$pool = new Pool('dev');
$pool->addRepository($repos);
$matches = $pool->whatProvides($name);

foreach ($matches as $index => $package) {

 if ($package->getName() !== $name) {
unset($matches[$index]);
continue;
}

return $package;
}
}






private function openBrowser($url)
{
$url = ProcessExecutor::escape($url);

if (defined('PHP_WINDOWS_VERSION_MAJOR')) {
return passthru('start "web" explorer "' . $url . '"');
}

passthru('which xdg-open', $linux);
passthru('which open', $osx);

if (0 === $linux) {
passthru('xdg-open ' . $url);
} elseif (0 === $osx) {
passthru('open ' . $url);
} else {
$this->getIO()->writeError('no suitable browser opening command found, open yourself: ' . $url);
}
}








private function initializeRepos()
{
$composer = $this->getComposer(false);

if ($composer) {
return array(
$composer->getRepositoryManager()->getLocalRepository(),
new CompositeRepository($composer->getRepositoryManager()->getRepositories())
);
}

$defaultRepos = Factory::createDefaultRepositories($this->getIO());

return array(new CompositeRepository($defaultRepos));
}
}
<?php











namespace Composer\Command;

use Composer\DependencyResolver\Pool;
use Composer\Json\JsonFile;
use Composer\Factory;
use Composer\Package\BasePackage;
use Composer\Package\Version\VersionSelector;
use Composer\Repository\CompositeRepository;
use Composer\Repository\PlatformRepository;
use Composer\Package\Version\VersionParser;
use Composer\Util\ProcessExecutor;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Process\Process;
use Symfony\Component\Process\ExecutableFinder;





class InitCommand extends Command
{

protected $repos;


private $gitConfig;


private $pool;




protected function configure()
{
$this
->setName('init')
->setDescription('Creates a basic composer.json file in current directory.')
->setDefinition(array(
new InputOption('name', null, InputOption::VALUE_REQUIRED, 'Name of the package'),
new InputOption('description', null, InputOption::VALUE_REQUIRED, 'Description of package'),
new InputOption('author', null, InputOption::VALUE_REQUIRED, 'Author name of package'),

 new InputOption('type', null, InputOption::VALUE_OPTIONAL, 'Type of package'),
new InputOption('homepage', null, InputOption::VALUE_REQUIRED, 'Homepage of package'),
new InputOption('require', null, InputOption::VALUE_IS_ARRAY | InputOption::VALUE_REQUIRED, 'Package to require with a version constraint, e.g. foo/bar:1.0.0 or foo/bar=1.0.0 or "foo/bar 1.0.0"'),
new InputOption('require-dev', null, InputOption::VALUE_IS_ARRAY | InputOption::VALUE_REQUIRED, 'Package to require for development with a version constraint, e.g. foo/bar:1.0.0 or foo/bar=1.0.0 or "foo/bar 1.0.0"'),
new InputOption('stability', 's', InputOption::VALUE_REQUIRED, 'Minimum stability (empty or one of: '.implode(', ', array_keys(BasePackage::$stabilities)).')'),
new InputOption('license', 'l', InputOption::VALUE_REQUIRED, 'License of package'),
))
->setHelp(<<<EOT
The <info>init</info> command creates a basic composer.json file
in the current directory.

<info>php composer.phar init</info>

EOT
)
;
}




protected function execute(InputInterface $input, OutputInterface $output)
{
$whitelist = array('name', 'description', 'author', 'type', 'homepage', 'require', 'require-dev', 'stability', 'license');

$options = array_filter(array_intersect_key($input->getOptions(), array_flip($whitelist)));

if (isset($options['author'])) {
$options['authors'] = $this->formatAuthors($options['author']);
unset($options['author']);
}

if (isset($options['stability'])) {
$options['minimum-stability'] = $options['stability'];
unset($options['stability']);
}

$options['require'] = isset($options['require']) ? $this->formatRequirements($options['require']) : new \stdClass;
if (array() === $options['require']) {
$options['require'] = new \stdClass;
}

if (isset($options['require-dev'])) {
$options['require-dev'] = $this->formatRequirements($options['require-dev']);
if (array() === $options['require-dev']) {
$options['require-dev'] = new \stdClass;
}
}

$file = new JsonFile('composer.json');
$json = $file->encode($options);

if ($input->isInteractive()) {
$this->getIO()->writeError(array('', $json, ''));
if (!$this->getIO()->askConfirmation('Do you confirm generation [<comment>yes</comment>]? ', true)) {
$this->getIO()->writeError('<error>Command aborted</error>');

return 1;
}
}

$file->write($options);

if ($input->isInteractive() && is_dir('.git')) {
$ignoreFile = realpath('.gitignore');

if (false === $ignoreFile) {
$ignoreFile = realpath('.') . '/.gitignore';
}

if (!$this->hasVendorIgnore($ignoreFile)) {
$question = 'Would you like the <info>vendor</info> directory added to your <info>.gitignore</info> [<comment>yes</comment>]? ';

if ($this->getIO()->askConfirmation($question, true)) {
$this->addVendorIgnore($ignoreFile);
}
}
}
}




protected function interact(InputInterface $input, OutputInterface $output)
{
$git = $this->getGitConfig();

$formatter = $this->getHelperSet()->get('formatter');

$this->getIO()->writeError(array(
'',
$formatter->formatBlock('Welcome to the Composer config generator', 'bg=blue;fg=white', true),
''
));


 $this->getIO()->writeError(array(
'',
'This command will guide you through creating your composer.json config.',
'',
));

$cwd = realpath(".");

if (!$name = $input->getOption('name')) {
$name = basename($cwd);
$name = preg_replace('{(?:([a-z])([A-Z])|([A-Z])([A-Z][a-z]))}', '\\1\\3-\\2\\4', $name);
$name = strtolower($name);
if (isset($git['github.user'])) {
$name = $git['github.user'] . '/' . $name;
} elseif (!empty($_SERVER['USERNAME'])) {
$name = $_SERVER['USERNAME'] . '/' . $name;
} elseif (get_current_user()) {
$name = get_current_user() . '/' . $name;
} else {

 $name = $name . '/' . $name;
}
} else {
if (!preg_match('{^[a-z0-9_.-]+/[a-z0-9_.-]+$}', $name)) {
throw new \InvalidArgumentException(
'The package name '.$name.' is invalid, it should be lowercase and have a vendor name, a forward slash, and a package name, matching: [a-z0-9_.-]+/[a-z0-9_.-]+'
);
}
}

$name = $this->getIO()->askAndValidate(
'Package name (<vendor>/<name>) [<comment>'.$name.'</comment>]: ',
function ($value) use ($name) {
if (null === $value) {
return $name;
}

if (!preg_match('{^[a-z0-9_.-]+/[a-z0-9_.-]+$}', $value)) {
throw new \InvalidArgumentException(
'The package name '.$value.' is invalid, it should be lowercase and have a vendor name, a forward slash, and a package name, matching: [a-z0-9_.-]+/[a-z0-9_.-]+'
);
}

return $value;
},
null,
$name
);
$input->setOption('name', $name);

$description = $input->getOption('description') ?: false;
$description = $this->getIO()->ask(
'Description [<comment>'.$description.'</comment>]: ',
$description
);
$input->setOption('description', $description);

if (null === $author = $input->getOption('author')) {
if (isset($git['user.name']) && isset($git['user.email'])) {
$author = sprintf('%s <%s>', $git['user.name'], $git['user.email']);
}
}

$self = $this;
$author = $this->getIO()->askAndValidate(
'Author [<comment>'.$author.'</comment>]: ',
function ($value) use ($self, $author) {
$value = $value ?: $author;
$author = $self->parseAuthorString($value);

return sprintf('%s <%s>', $author['name'], $author['email']);
},
null,
$author
);
$input->setOption('author', $author);

$minimumStability = $input->getOption('stability') ?: null;
$minimumStability = $this->getIO()->askAndValidate(
'Minimum Stability [<comment>'.$minimumStability.'</comment>]: ',
function ($value) use ($self, $minimumStability) {
if (null === $value) {
return $minimumStability;
}

if (!isset(BasePackage::$stabilities[$value])) {
throw new \InvalidArgumentException(
'Invalid minimum stability "'.$value.'". Must be empty or one of: '.
implode(', ', array_keys(BasePackage::$stabilities))
);
}

return $value;
},
null,
$minimumStability
);
$input->setOption('stability', $minimumStability);

$type = $input->getOption('type') ?: false;
$type = $this->getIO()->ask(
'Package Type [<comment>'.$type.'</comment>]: ',
$type
);
$input->setOption('type', $type);

$license = $input->getOption('license') ?: false;
$license = $this->getIO()->ask(
'License [<comment>'.$license.'</comment>]: ',
$license
);
$input->setOption('license', $license);

$this->getIO()->writeError(array('', 'Define your dependencies.', ''));

$question = 'Would you like to define your dependencies (require) interactively [<comment>yes</comment>]? ';
$requirements = array();
if ($this->getIO()->askConfirmation($question, true)) {
$requirements = $this->determineRequirements($input, $output, $input->getOption('require'));
}
$input->setOption('require', $requirements);

$question = 'Would you like to define your dev dependencies (require-dev) interactively [<comment>yes</comment>]? ';
$devRequirements = array();
if ($this->getIO()->askConfirmation($question, true)) {
$devRequirements = $this->determineRequirements($input, $output, $input->getOption('require-dev'));
}
$input->setOption('require-dev', $devRequirements);
}






public function parseAuthorString($author)
{
if (preg_match('/^(?P<name>[- \.,\p{L}\p{N}\'‚Äô]+) <(?P<email>.+?)>$/u', $author, $match)) {
if ($this->isValidEmail($match['email'])) {
return array(
'name' => trim($match['name']),
'email' => $match['email']
);
}
}

throw new \InvalidArgumentException(
'Invalid author string.  Must be in the format: '.
'John Smith <john@example.com>'
);
}

protected function findPackages($name)
{
return $this->getRepos()->search($name);
}

protected function getRepos()
{
if (!$this->repos) {
$this->repos = new CompositeRepository(array_merge(
array(new PlatformRepository),
Factory::createDefaultRepositories($this->getIO())
));
}

return $this->repos;
}

protected function determineRequirements(InputInterface $input, OutputInterface $output, $requires = array())
{
if ($requires) {
$requires = $this->normalizeRequirements($requires);
$result = array();

foreach ($requires as $requirement) {
if (!isset($requirement['version'])) {

 $version = $this->findBestVersionForPackage($input, $requirement['name']);
$requirement['version'] = $version;

$this->getIO()->writeError(sprintf(
'Using version <info>%s</info> for <info>%s</info>',
$requirement['version'],
$requirement['name']
));
}

$result[] = $requirement['name'] . ' ' . $requirement['version'];
}

return $result;
}

$versionParser = new VersionParser();
while (null !== $package = $this->getIO()->ask('Search for a package: ')) {
$matches = $this->findPackages($package);

if (count($matches)) {
$exactMatch = null;
$choices = array();
foreach ($matches as $position => $foundPackage) {
$choices[] = sprintf(' <info>%5s</info> %s', "[$position]", $foundPackage['name']);
if ($foundPackage['name'] === $package) {
$exactMatch = true;
break;
}
}


 if (!$exactMatch) {
$this->getIO()->writeError(array(
'',
sprintf('Found <info>%s</info> packages matching <info>%s</info>', count($matches), $package),
''
));

$this->getIO()->writeError($choices);
$this->getIO()->writeError('');

$validator = function ($selection) use ($matches, $versionParser) {
if ('' === $selection) {
return false;
}

if (is_numeric($selection) && isset($matches[(int) $selection])) {
$package = $matches[(int) $selection];

return $package['name'];
}

if (preg_match('{^\s*(?P<name>[\S/]+)(?:\s+(?P<version>\S+))?\s*$}', $selection, $packageMatches)) {
if (isset($packageMatches['version'])) {



 $versionParser->parseConstraints($packageMatches['version']);

return $packageMatches['name'].' '.$packageMatches['version'];
}


 return $packageMatches['name'];
}

throw new \Exception('Not a valid selection');
};

$package = $this->getIO()->askAndValidate(
'Enter package # to add, or the complete package name if it is not listed: ',
$validator,
3,
false
);
}


 if (false !== $package && false === strpos($package, ' ')) {
$validator = function ($input) {
$input = trim($input);

return $input ?: false;
};

$constraint = $this->getIO()->askAndValidate(
'Enter the version constraint to require (or leave blank to use the latest version): ',
$validator,
3,
false
);

if (false === $constraint) {
$constraint = $this->findBestVersionForPackage($input, $package);

$this->getIO()->writeError(sprintf(
'Using version <info>%s</info> for <info>%s</info>',
$constraint,
$package
));
}

$package .= ' '.$constraint;
}

if (false !== $package) {
$requires[] = $package;
}
}
}

return $requires;
}

protected function formatAuthors($author)
{
return array($this->parseAuthorString($author));
}

protected function formatRequirements(array $requirements)
{
$requires = array();
$requirements = $this->normalizeRequirements($requirements);
foreach ($requirements as $requirement) {
$requires[$requirement['name']] = $requirement['version'];
}

return $requires;
}

protected function getGitConfig()
{
if (null !== $this->gitConfig) {
return $this->gitConfig;
}

$finder = new ExecutableFinder();
$gitBin = $finder->find('git');

$cmd = new Process(sprintf('%s config -l', ProcessExecutor::escape($gitBin)));
$cmd->run();

if ($cmd->isSuccessful()) {
$this->gitConfig = array();
preg_match_all('{^([^=]+)=(.*)$}m', $cmd->getOutput(), $matches, PREG_SET_ORDER);
foreach ($matches as $match) {
$this->gitConfig[$match[1]] = $match[2];
}

return $this->gitConfig;
}

return $this->gitConfig = array();
}

















protected function hasVendorIgnore($ignoreFile, $vendor = 'vendor')
{
if (!file_exists($ignoreFile)) {
return false;
}

$pattern = sprintf('{^/?%s(/\*?)?$}', preg_quote($vendor));

$lines = file($ignoreFile, FILE_IGNORE_NEW_LINES);
foreach ($lines as $line) {
if (preg_match($pattern, $line)) {
return true;
}
}

return false;
}

protected function normalizeRequirements(array $requirements)
{
$parser = new VersionParser();

return $parser->parseNameVersionPairs($requirements);
}

protected function addVendorIgnore($ignoreFile, $vendor = '/vendor/')
{
$contents = "";
if (file_exists($ignoreFile)) {
$contents = file_get_contents($ignoreFile);

if ("\n" !== substr($contents, 0, -1)) {
$contents .= "\n";
}
}

file_put_contents($ignoreFile, $contents . $vendor. "\n");
}

protected function isValidEmail($email)
{

 if (!function_exists('filter_var')) {
return true;
}


 if (PHP_VERSION_ID < 50303) {
return true;
}

return false !== filter_var($email, FILTER_VALIDATE_EMAIL);
}

private function getPool(InputInterface $input)
{
if (!$this->pool) {
$this->pool = new Pool($this->getMinimumStability($input));
$this->pool->addRepository($this->getRepos());
}

return $this->pool;
}

private function getMinimumStability(InputInterface $input)
{
if ($input->hasOption('stability')) {
return $input->getOption('stability') ?: 'stable';
}

$file = Factory::getComposerFile();
if (is_file($file) && is_readable($file) && is_array($composer = json_decode(file_get_contents($file), true))) {
if (!empty($composer['minimum-stability'])) {
return $composer['minimum-stability'];
}
}

return 'stable';
}











private function findBestVersionForPackage(InputInterface $input, $name)
{

 $versionSelector = new VersionSelector($this->getPool($input));
$package = $versionSelector->findBestCandidate($name);

if (!$package) {
throw new \InvalidArgumentException(sprintf(
'Could not find package %s at any version for your minimum-stability (%s). Check the package spelling or your minimum-stability',
$name,
$this->getMinimumStability($input)
));
}

return $versionSelector->findRecommendedRequireVersion($package);
}
}
<?php











namespace Composer\Command;

use Composer\Installer;
use Composer\Plugin\CommandEvent;
use Composer\Plugin\PluginEvents;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Output\OutputInterface;







class InstallCommand extends Command
{
protected function configure()
{
$this
->setName('install')
->setDescription('Installs the project dependencies from the composer.lock file if present, or falls back on the composer.json.')
->setDefinition(array(
new InputOption('prefer-source', null, InputOption::VALUE_NONE, 'Forces installation from package sources when possible, including VCS information.'),
new InputOption('prefer-dist', null, InputOption::VALUE_NONE, 'Forces installation from package dist even for dev versions.'),
new InputOption('dry-run', null, InputOption::VALUE_NONE, 'Outputs the operations but will not execute anything (implicitly enables --verbose).'),
new InputOption('dev', null, InputOption::VALUE_NONE, 'Enables installation of require-dev packages (enabled by default, only present for BC).'),
new InputOption('no-dev', null, InputOption::VALUE_NONE, 'Disables installation of require-dev packages.'),
new InputOption('no-plugins', null, InputOption::VALUE_NONE, 'Disables all plugins.'),
new InputOption('no-custom-installers', null, InputOption::VALUE_NONE, 'DEPRECATED: Use no-plugins instead.'),
new InputOption('no-autoloader', null, InputOption::VALUE_NONE, 'Skips autoloader generation'),
new InputOption('no-scripts', null, InputOption::VALUE_NONE, 'Skips the execution of all scripts defined in composer.json file.'),
new InputOption('no-progress', null, InputOption::VALUE_NONE, 'Do not output download progress.'),
new InputOption('verbose', 'v|vv|vvv', InputOption::VALUE_NONE, 'Shows more details including new commits pulled in when updating packages.'),
new InputOption('optimize-autoloader', 'o', InputOption::VALUE_NONE, 'Optimize autoloader during autoloader dump'),
new InputOption('ignore-platform-reqs', null, InputOption::VALUE_NONE, 'Ignore platform requirements (php & ext- packages).'),
new InputArgument('packages', InputArgument::IS_ARRAY | InputArgument::OPTIONAL, 'Should not be provided, use composer require instead to add a given package to composer.json.'),
))
->setHelp(<<<EOT
The <info>install</info> command reads the composer.lock file from
the current directory, processes it, and downloads and installs all the
libraries and dependencies outlined in that file. If the file does not
exist it will look for composer.json and do the same.

<info>php composer.phar install</info>

EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
if ($args = $input->getArgument('packages')) {
$this->getIO()->writeError('<error>Invalid argument '.implode(' ', $args).'. Use "composer require '.implode(' ', $args).'" instead to add packages to your composer.json.</error>');

return 1;
}

if ($input->getOption('no-custom-installers')) {
$this->getIO()->writeError('<warning>You are using the deprecated option "no-custom-installers". Use "no-plugins" instead.</warning>');
$input->setOption('no-plugins', true);
}

if ($input->getOption('dev')) {
$this->getIO()->writeError('<warning>You are using the deprecated option "dev". Dev packages are installed by default now.</warning>');
}

$composer = $this->getComposer(true, $input->getOption('no-plugins'));
$composer->getDownloadManager()->setOutputProgress(!$input->getOption('no-progress'));
$io = $this->getIO();

$commandEvent = new CommandEvent(PluginEvents::COMMAND, 'install', $input, $output);
$composer->getEventDispatcher()->dispatch($commandEvent->getName(), $commandEvent);

$install = Installer::create($io, $composer);

$preferSource = false;
$preferDist = false;

$config = $composer->getConfig();

switch ($config->get('preferred-install')) {
case 'source':
$preferSource = true;
break;
case 'dist':
$preferDist = true;
break;
case 'auto':
default:

 break;
}
if ($input->getOption('prefer-source') || $input->getOption('prefer-dist')) {
$preferSource = $input->getOption('prefer-source');
$preferDist = $input->getOption('prefer-dist');
}

$optimize = $input->getOption('optimize-autoloader') || $config->get('optimize-autoloader') || $config->get('classmap-authoritative');

$install
->setDryRun($input->getOption('dry-run'))
->setVerbose($input->getOption('verbose'))
->setPreferSource($preferSource)
->setPreferDist($preferDist)
->setDevMode(!$input->getOption('no-dev'))
->setDumpAutoloader(!$input->getOption('no-autoloader'))
->setRunScripts(!$input->getOption('no-scripts'))
->setOptimizeAutoloader($optimize)
->setIgnorePlatformRequirements($input->getOption('ignore-platform-reqs'))
;

if ($input->getOption('no-plugins')) {
$install->disablePlugins();
}

return $install->run();
}
}
<?php











namespace Composer\Command;

use Composer\Json\JsonFile;
use Composer\Package\Version\VersionParser;
use Composer\Plugin\CommandEvent;
use Composer\Plugin\PluginEvents;
use Composer\Package\PackageInterface;
use Composer\Repository\RepositoryInterface;
use Symfony\Component\Console\Helper\Table;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;




class LicensesCommand extends Command
{
protected function configure()
{
$this
->setName('licenses')
->setDescription('Show information about licenses of dependencies')
->setDefinition(array(
new InputOption('format', 'f', InputOption::VALUE_REQUIRED, 'Format of the output: text or json', 'text'),
new InputOption('no-dev', null, InputOption::VALUE_NONE, 'Disables search in require-dev packages.'),
))
->setHelp(<<<EOT
The license command displays detailed information about the licenses of
the installed dependencies.

EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
$composer = $this->getComposer();

$commandEvent = new CommandEvent(PluginEvents::COMMAND, 'licenses', $input, $output);
$composer->getEventDispatcher()->dispatch($commandEvent->getName(), $commandEvent);

$root = $composer->getPackage();
$repo = $composer->getRepositoryManager()->getLocalRepository();

$versionParser = new VersionParser;

if ($input->getOption('no-dev')) {
$packages = $this->filterRequiredPackages($repo, $root);
} else {
$packages = $this->appendPackages($repo->getPackages(), array());
}

ksort($packages);

switch ($format = $input->getOption('format')) {
case 'text':
$this->getIO()->write('Name: <comment>'.$root->getPrettyName().'</comment>');
$this->getIO()->write('Version: <comment>'.$versionParser->formatVersion($root).'</comment>');
$this->getIO()->write('Licenses: <comment>'.(implode(', ', $root->getLicense()) ?: 'none').'</comment>');
$this->getIO()->write('Dependencies:');
$this->getIO()->write('');

$table = new Table($output);
$table->setStyle('compact');
$table->getStyle()->setVerticalBorderChar('');
$table->getStyle()->setCellRowContentFormat('%s  ');
$table->setHeaders(array('Name', 'Version', 'License'));
foreach ($packages as $package) {
$table->addRow(array(
$package->getPrettyName(),
$versionParser->formatVersion($package),
implode(', ', $package->getLicense()) ?: 'none',
));
}
$table->render();
break;

case 'json':
foreach ($packages as $package) {
$dependencies[$package->getPrettyName()] = array(
'version' => $versionParser->formatVersion($package),
'license' => $package->getLicense(),
);
}

$this->getIO()->write(JsonFile::encode(array(
'name' => $root->getPrettyName(),
'version' => $versionParser->formatVersion($root),
'license' => $root->getLicense(),
'dependencies' => $dependencies,
)));
break;

default:
throw new \RuntimeException(sprintf('Unsupported format "%s".  See help for supported formats.', $format));
}
}







private function filterRequiredPackages(RepositoryInterface $repo, PackageInterface $package, $bucket = array())
{
$requires = array_keys($package->getRequires());

$packageListNames = array_keys($bucket);
$packages = array_filter(
$repo->getPackages(),
function ($package) use ($requires, $packageListNames) {
return in_array($package->getName(), $requires) && !in_array($package->getName(), $packageListNames);
}
);

$bucket = $this->appendPackages($packages, $bucket);

foreach ($packages as $package) {
$bucket = $this->filterRequiredPackages($repo, $package, $bucket);
}

return $bucket;
}








public function appendPackages(array $packages, array $bucket)
{
foreach ($packages as $package) {
$bucket[$package->getName()] = $package;
}

return $bucket;
}
}
<?php











namespace Composer\Command;

use Composer\Config\JsonConfigSource;
use Composer\Installer;
use Composer\Plugin\CommandEvent;
use Composer\Plugin\PluginEvents;
use Composer\Json\JsonFile;
use Composer\Factory;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Output\OutputInterface;





class RemoveCommand extends Command
{
protected function configure()
{
$this
->setName('remove')
->setDescription('Removes a package from the require or require-dev')
->setDefinition(array(
new InputArgument('packages', InputArgument::IS_ARRAY, 'Packages that should be removed.'),
new InputOption('dev', null, InputOption::VALUE_NONE, 'Removes a package from the require-dev section.'),
new InputOption('no-progress', null, InputOption::VALUE_NONE, 'Do not output download progress.'),
new InputOption('no-update', null, InputOption::VALUE_NONE, 'Disables the automatic update of the dependencies.'),
new InputOption('update-no-dev', null, InputOption::VALUE_NONE, 'Run the dependency update with the --no-dev option.'),
new InputOption('update-with-dependencies', null, InputOption::VALUE_NONE, 'Allows inherited dependencies to be updated with explicit dependencies.'),
new InputOption('ignore-platform-reqs', null, InputOption::VALUE_NONE, 'Ignore platform requirements (php & ext- packages).'),
))
->setHelp(<<<EOT
The <info>remove</info> command removes a package from the current
list of installed packages

<info>php composer.phar remove</info>

EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
$packages = $input->getArgument('packages');

$file = Factory::getComposerFile();

$jsonFile = new JsonFile($file);
$composer = $jsonFile->read();
$composerBackup = file_get_contents($jsonFile->getPath());

$json = new JsonConfigSource($jsonFile);

$type = $input->getOption('dev') ? 'require-dev' : 'require';
$altType = !$input->getOption('dev') ? 'require-dev' : 'require';

foreach ($packages as $package) {
if (isset($composer[$type][$package])) {
$json->removeLink($type, $package);
} elseif (isset($composer[$altType][$package])) {
$this->getIO()->writeError('<warning>'.$package.' could not be found in '.$type.' but it is present in '.$altType.'</warning>');
if ($this->getIO()->isInteractive()) {
if ($this->getIO()->askConfirmation('Do you want to remove it from '.$altType.' [<comment>yes</comment>]? ', true)) {
$json->removeLink($altType, $package);
}
}
} else {
$this->getIO()->writeError('<warning>'.$package.' is not required in your composer.json and has not been removed</warning>');
}
}

if ($input->getOption('no-update')) {
return 0;
}


 $composer = $this->getComposer();
$composer->getDownloadManager()->setOutputProgress(!$input->getOption('no-progress'));
$io = $this->getIO();

$commandEvent = new CommandEvent(PluginEvents::COMMAND, 'remove', $input, $output);
$composer->getEventDispatcher()->dispatch($commandEvent->getName(), $commandEvent);

$install = Installer::create($io, $composer);

$updateDevMode = !$input->getOption('update-no-dev');
$install
->setVerbose($input->getOption('verbose'))
->setDevMode($updateDevMode)
->setUpdate(true)
->setUpdateWhitelist($packages)
->setWhitelistDependencies($input->getOption('update-with-dependencies'))
->setIgnorePlatformRequirements($input->getOption('ignore-platform-reqs'))
;

$status = $install->run();
if ($status !== 0) {
$this->getIO()->writeError("\n".'<error>Removal failed, reverting '.$file.' to its original content.</error>');
file_put_contents($jsonFile->getPath(), $composerBackup);
}

return $status;
}
}
<?php











namespace Composer\Command;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Composer\Factory;
use Composer\Installer;
use Composer\Json\JsonFile;
use Composer\Json\JsonManipulator;
use Composer\Package\Version\VersionParser;
use Composer\Plugin\CommandEvent;
use Composer\Plugin\PluginEvents;
use Composer\Repository\CompositeRepository;
use Composer\Repository\PlatformRepository;





class RequireCommand extends InitCommand
{
protected function configure()
{
$this
->setName('require')
->setDescription('Adds required packages to your composer.json and installs them')
->setDefinition(array(
new InputArgument('packages', InputArgument::IS_ARRAY | InputArgument::OPTIONAL, 'Required package name optionally including a version constraint, e.g. foo/bar or foo/bar:1.0.0 or foo/bar=1.0.0 or "foo/bar 1.0.0"'),
new InputOption('dev', null, InputOption::VALUE_NONE, 'Add requirement to require-dev.'),
new InputOption('prefer-source', null, InputOption::VALUE_NONE, 'Forces installation from package sources when possible, including VCS information.'),
new InputOption('prefer-dist', null, InputOption::VALUE_NONE, 'Forces installation from package dist even for dev versions.'),
new InputOption('no-progress', null, InputOption::VALUE_NONE, 'Do not output download progress.'),
new InputOption('no-update', null, InputOption::VALUE_NONE, 'Disables the automatic update of the dependencies.'),
new InputOption('update-no-dev', null, InputOption::VALUE_NONE, 'Run the dependency update with the --no-dev option.'),
new InputOption('update-with-dependencies', null, InputOption::VALUE_NONE, 'Allows inherited dependencies to be updated with explicit dependencies.'),
new InputOption('ignore-platform-reqs', null, InputOption::VALUE_NONE, 'Ignore platform requirements (php & ext- packages).'),
new InputOption('sort-packages', null, InputOption::VALUE_NONE, 'Sorts packages when adding/updating a new dependency'),
))
->setHelp(<<<EOT
The require command adds required packages to your composer.json and installs them.

If you do not specify a version constraint, composer will choose a suitable one based on the available package versions.

If you do not want to install the new dependencies immediately you can call it with --no-update

EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
$file = Factory::getComposerFile();

$newlyCreated = !file_exists($file);
if (!file_exists($file) && !file_put_contents($file, "{\n}\n")) {
$this->getIO()->writeError('<error>'.$file.' could not be created.</error>');

return 1;
}
if (!is_readable($file)) {
$this->getIO()->writeError('<error>'.$file.' is not readable.</error>');

return 1;
}
if (!is_writable($file)) {
$this->getIO()->writeError('<error>'.$file.' is not writable.</error>');

return 1;
}

if (filesize($file) === 0) {
file_put_contents($file, "{\n}\n");
}

$json = new JsonFile($file);
$composerDefinition = $json->read();
$composerBackup = file_get_contents($json->getPath());

$composer = $this->getComposer();
$repos = $composer->getRepositoryManager()->getRepositories();

$this->repos = new CompositeRepository(array_merge(
array(new PlatformRepository),
$repos
));

$requirements = $this->determineRequirements($input, $output, $input->getArgument('packages'));

$requireKey = $input->getOption('dev') ? 'require-dev' : 'require';
$removeKey = $input->getOption('dev') ? 'require' : 'require-dev';
$baseRequirements = array_key_exists($requireKey, $composerDefinition) ? $composerDefinition[$requireKey] : array();
$requirements = $this->formatRequirements($requirements);


 $versionParser = new VersionParser();
foreach ($requirements as $constraint) {
$versionParser->parseConstraints($constraint);
}

$sortPackages = $input->getOption('sort-packages');

if (!$this->updateFileCleanly($json, $baseRequirements, $requirements, $requireKey, $removeKey, $sortPackages)) {
foreach ($requirements as $package => $version) {
$baseRequirements[$package] = $version;

if (isset($composerDefinition[$removeKey][$package])) {
unset($composerDefinition[$removeKey][$package]);
}
}

$composerDefinition[$requireKey] = $baseRequirements;
$json->write($composerDefinition);
}

$this->getIO()->writeError('<info>'.$file.' has been '.($newlyCreated ? 'created' : 'updated').'</info>');

if ($input->getOption('no-update')) {
return 0;
}
$updateDevMode = !$input->getOption('update-no-dev');


 $this->resetComposer();
$composer = $this->getComposer();
$composer->getDownloadManager()->setOutputProgress(!$input->getOption('no-progress'));
$io = $this->getIO();

$commandEvent = new CommandEvent(PluginEvents::COMMAND, 'require', $input, $output);
$composer->getEventDispatcher()->dispatch($commandEvent->getName(), $commandEvent);

$install = Installer::create($io, $composer);

$install
->setVerbose($input->getOption('verbose'))
->setPreferSource($input->getOption('prefer-source'))
->setPreferDist($input->getOption('prefer-dist'))
->setDevMode($updateDevMode)
->setUpdate(true)
->setUpdateWhitelist(array_keys($requirements))
->setWhitelistDependencies($input->getOption('update-with-dependencies'))
->setIgnorePlatformRequirements($input->getOption('ignore-platform-reqs'))
;

$status = $install->run();
if ($status !== 0) {
if ($newlyCreated) {
$this->getIO()->writeError("\n".'<error>Installation failed, deleting '.$file.'.</error>');
unlink($json->getPath());
} else {
$this->getIO()->writeError("\n".'<error>Installation failed, reverting '.$file.' to its original content.</error>');
file_put_contents($json->getPath(), $composerBackup);
}
}

return $status;
}

private function updateFileCleanly($json, array $base, array $new, $requireKey, $removeKey, $sortPackages)
{
$contents = file_get_contents($json->getPath());

$manipulator = new JsonManipulator($contents);

foreach ($new as $package => $constraint) {
if (!$manipulator->addLink($requireKey, $package, $constraint, $sortPackages)) {
return false;
}
if (!$manipulator->removeSubNode($removeKey, $package)) {
return false;
}
}

file_put_contents($json->getPath(), $manipulator->getContents());

return true;
}

protected function interact(InputInterface $input, OutputInterface $output)
{
return;
}
}
<?php











namespace Composer\Command;

use Composer\Script\CommandEvent;
use Composer\Script\ScriptEvents;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Output\OutputInterface;




class RunScriptCommand extends Command
{



protected $scriptEvents = array(
ScriptEvents::PRE_INSTALL_CMD,
ScriptEvents::POST_INSTALL_CMD,
ScriptEvents::PRE_UPDATE_CMD,
ScriptEvents::POST_UPDATE_CMD,
ScriptEvents::PRE_STATUS_CMD,
ScriptEvents::POST_STATUS_CMD,
ScriptEvents::POST_ROOT_PACKAGE_INSTALL,
ScriptEvents::POST_CREATE_PROJECT_CMD,
ScriptEvents::PRE_ARCHIVE_CMD,
ScriptEvents::POST_ARCHIVE_CMD,
ScriptEvents::PRE_AUTOLOAD_DUMP,
ScriptEvents::POST_AUTOLOAD_DUMP,
);

protected function configure()
{
$this
->setName('run-script')
->setDescription('Run the scripts defined in composer.json.')
->setDefinition(array(
new InputArgument('script', InputArgument::OPTIONAL, 'Script name to run.'),
new InputArgument('args', InputArgument::IS_ARRAY | InputArgument::OPTIONAL, ''),
new InputOption('dev', null, InputOption::VALUE_NONE, 'Sets the dev mode.'),
new InputOption('no-dev', null, InputOption::VALUE_NONE, 'Disables the dev mode.'),
new InputOption('list', 'l', InputOption::VALUE_NONE, 'List scripts.'),
))
->setHelp(<<<EOT
The <info>run-script</info> command runs scripts defined in composer.json:

<info>php composer.phar run-script post-update-cmd</info>
EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
if ($input->getOption('list')) {
return $this->listScripts();
} elseif (!$input->getArgument('script')) {
throw new \RunTimeException('Missing required argument "script"');
}

$script = $input->getArgument('script');
if (!in_array($script, $this->scriptEvents)) {
if (defined('Composer\Script\ScriptEvents::'.str_replace('-', '_', strtoupper($script)))) {
throw new \InvalidArgumentException(sprintf('Script "%s" cannot be run with this command', $script));
}
}

$composer = $this->getComposer();
$hasListeners = $composer->getEventDispatcher()->hasEventListeners(new CommandEvent($script, $composer, $this->getIO()));
if (!$hasListeners) {
throw new \InvalidArgumentException(sprintf('Script "%s" is not defined in this package', $script));
}


 $binDir = $composer->getConfig()->get('bin-dir');
if (is_dir($binDir)) {
$_SERVER['PATH'] = realpath($binDir).PATH_SEPARATOR.getenv('PATH');
putenv('PATH='.$_SERVER['PATH']);
}

$args = $input->getArgument('args');

return $composer->getEventDispatcher()->dispatchScript($script, $input->getOption('dev') || !$input->getOption('no-dev'), $args);
}

protected function listScripts()
{
$scripts = $this->getComposer()->getPackage()->getScripts();

if (!count($scripts)) {
return 0;
}

$this->getIO()->writeError('<info>scripts:</info>');
foreach ($scripts as $name => $script) {
$this->getIO()->write('  ' . $name);
}

return 0;
}
}
<?php











namespace Composer\Command;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Output\OutputInterface;




class ScriptAliasCommand extends Command
{
private $script;

public function __construct($script)
{
$this->script = $script;

parent::__construct();
}

protected function configure()
{
$this
->setName($this->script)
->setDescription('Run the '.$this->script.' script as defined in composer.json.')
->setDefinition(array(
new InputOption('dev', null, InputOption::VALUE_NONE, 'Sets the dev mode.'),
new InputOption('no-dev', null, InputOption::VALUE_NONE, 'Disables the dev mode.'),
new InputArgument('args', InputArgument::IS_ARRAY | InputArgument::OPTIONAL, ''),
))
->setHelp(<<<EOT
The <info>run-script</info> command runs scripts defined in composer.json:

<info>php composer.phar run-script post-update-cmd</info>
EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
$composer = $this->getComposer();


 $binDir = $composer->getConfig()->get('bin-dir');
if (is_dir($binDir)) {
$_SERVER['PATH'] = realpath($binDir).PATH_SEPARATOR.getenv('PATH');
putenv('PATH='.$_SERVER['PATH']);
}

$args = $input->getArguments();

return $composer->getEventDispatcher()->dispatchScript($this->script, $input->getOption('dev') || !$input->getOption('no-dev'), $args['args']);
}
}
<?php











namespace Composer\Command;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Composer\Repository\CompositeRepository;
use Composer\Repository\PlatformRepository;
use Composer\Repository\RepositoryInterface;
use Composer\Factory;
use Composer\Plugin\CommandEvent;
use Composer\Plugin\PluginEvents;




class SearchCommand extends Command
{
protected $matches;
protected $lowMatches = array();
protected $tokens;
protected $output;
protected $onlyName;

protected function configure()
{
$this
->setName('search')
->setDescription('Search for packages')
->setDefinition(array(
new InputOption('only-name', 'N', InputOption::VALUE_NONE, 'Search only in name'),
new InputArgument('tokens', InputArgument::IS_ARRAY | InputArgument::REQUIRED, 'tokens to search for'),
))
->setHelp(<<<EOT
The search command searches for packages by its name
<info>php composer.phar search symfony composer</info>

EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{

 $platformRepo = new PlatformRepository;
if ($composer = $this->getComposer(false)) {
$localRepo = $composer->getRepositoryManager()->getLocalRepository();
$installedRepo = new CompositeRepository(array($localRepo, $platformRepo));
$repos = new CompositeRepository(array_merge(array($installedRepo), $composer->getRepositoryManager()->getRepositories()));
} else {
$defaultRepos = Factory::createDefaultRepositories($this->getIO());
$this->getIO()->writeError('No composer.json found in the current directory, showing packages from ' . implode(', ', array_keys($defaultRepos)));
$installedRepo = $platformRepo;
$repos = new CompositeRepository(array_merge(array($installedRepo), $defaultRepos));
}

if ($composer) {
$commandEvent = new CommandEvent(PluginEvents::COMMAND, 'search', $input, $output);
$composer->getEventDispatcher()->dispatch($commandEvent->getName(), $commandEvent);
}

$onlyName = $input->getOption('only-name');

$flags = $onlyName ? RepositoryInterface::SEARCH_NAME : RepositoryInterface::SEARCH_FULLTEXT;
$results = $repos->search(implode(' ', $input->getArgument('tokens')), $flags);

foreach ($results as $result) {
$this->getIO()->write($result['name'] . (isset($result['description']) ? ' '. $result['description'] : ''));
}
}
}
<?php











namespace Composer\Command;

use Composer\Composer;
use Composer\Factory;
use Composer\Util\Filesystem;
use Composer\Util\RemoteFilesystem;
use Composer\Downloader\FilesystemException;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Finder\Finder;






class SelfUpdateCommand extends Command
{
const HOMEPAGE = 'getcomposer.org';
const OLD_INSTALL_EXT = '-old.phar';

protected function configure()
{
$this
->setName('self-update')
->setAliases(array('selfupdate'))
->setDescription('Updates composer.phar to the latest version.')
->setDefinition(array(
new InputOption('rollback', 'r', InputOption::VALUE_NONE, 'Revert to an older installation of composer'),
new InputOption('clean-backups', null, InputOption::VALUE_NONE, 'Delete old backups during an update. This makes the current version of composer the only backup available after the update'),
new InputArgument('version', InputArgument::OPTIONAL, 'The version to update to'),
new InputOption('no-progress', null, InputOption::VALUE_NONE, 'Do not output download progress.'),
))
->setHelp(<<<EOT
The <info>self-update</info> command checks getcomposer.org for newer
versions of composer and if found, installs the latest.

<info>php composer.phar self-update</info>

EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
$baseUrl = (extension_loaded('openssl') ? 'https' : 'http') . '://' . self::HOMEPAGE;
$config = Factory::createConfig();
$remoteFilesystem = new RemoteFilesystem($this->getIO(), $config);
$cacheDir = $config->get('cache-dir');
$rollbackDir = $config->get('home');
$localFilename = realpath($_SERVER['argv'][0]) ?: $_SERVER['argv'][0];


 $tmpDir = is_writable(dirname($localFilename)) ? dirname($localFilename) : $cacheDir;


 if (!is_writable($tmpDir)) {
throw new FilesystemException('Composer update failed: the "'.$tmpDir.'" directory used to download the temp file could not be written');
}
if (!is_writable($localFilename)) {
throw new FilesystemException('Composer update failed: the "'.$localFilename.'" file could not be written');
}

if ($input->getOption('rollback')) {
return $this->rollback($output, $rollbackDir, $localFilename);
}

$latestVersion = trim($remoteFilesystem->getContents(self::HOMEPAGE, $baseUrl. '/version', false));
$updateVersion = $input->getArgument('version') ?: $latestVersion;

if (preg_match('{^[0-9a-f]{40}$}', $updateVersion) && $updateVersion !== $latestVersion) {
$this->getIO()->writeError('<error>You can not update to a specific SHA-1 as those phars are not available for download</error>');

return 1;
}

if (Composer::VERSION === $updateVersion) {
$this->getIO()->writeError('<info>You are already using composer version '.$updateVersion.'.</info>');

return 0;
}

$tempFilename = $tmpDir . '/' . basename($localFilename, '.phar').'-temp.phar';
$backupFile = sprintf(
'%s/%s-%s%s',
$rollbackDir,
strtr(Composer::RELEASE_DATE, ' :', '_-'),
preg_replace('{^([0-9a-f]{7})[0-9a-f]{33}$}', '$1', Composer::VERSION),
self::OLD_INSTALL_EXT
);

$this->getIO()->writeError(sprintf("Updating to version <info>%s</info>.", $updateVersion));
$remoteFilename = $baseUrl . (preg_match('{^[0-9a-f]{40}$}', $updateVersion) ? '/composer.phar' : "/download/{$updateVersion}/composer.phar");
$remoteFilesystem->copy(self::HOMEPAGE, $remoteFilename, $tempFilename, !$input->getOption('no-progress'));
if (!file_exists($tempFilename)) {
$this->getIO()->writeError('<error>The download of the new composer version failed for an unexpected reason</error>');

return 1;
}


 if ($input->getOption('clean-backups')) {
$finder = $this->getOldInstallationFinder($rollbackDir);

$fs = new Filesystem;
foreach ($finder as $file) {
$file = (string) $file;
$this->getIO()->writeError('<info>Removing: '.$file.'</info>');
$fs->remove($file);
}
}

if ($err = $this->setLocalPhar($localFilename, $tempFilename, $backupFile)) {
$this->getIO()->writeError('<error>The file is corrupted ('.$err->getMessage().').</error>');
$this->getIO()->writeError('<error>Please re-run the self-update command to try again.</error>');

return 1;
}

if (file_exists($backupFile)) {
$this->getIO()->writeError('Use <info>composer self-update --rollback</info> to return to version '.Composer::VERSION);
} else {
$this->getIO()->writeError('<warning>A backup of the current version could not be written to '.$backupFile.', no rollback possible</warning>');
}
}

protected function rollback(OutputInterface $output, $rollbackDir, $localFilename)
{
$rollbackVersion = $this->getLastBackupVersion($rollbackDir);
if (!$rollbackVersion) {
throw new \UnexpectedValueException('Composer rollback failed: no installation to roll back to in "'.$rollbackDir.'"');
}

if (!is_writable($rollbackDir)) {
throw new FilesystemException('Composer rollback failed: the "'.$rollbackDir.'" dir could not be written to');
}

$old = $rollbackDir . '/' . $rollbackVersion . self::OLD_INSTALL_EXT;

if (!is_file($old)) {
throw new FilesystemException('Composer rollback failed: "'.$old.'" could not be found');
}
if (!is_readable($old)) {
throw new FilesystemException('Composer rollback failed: "'.$old.'" could not be read');
}

$oldFile = $rollbackDir . "/{$rollbackVersion}" . self::OLD_INSTALL_EXT;
$this->getIO()->writeError(sprintf("Rolling back to version <info>%s</info>.", $rollbackVersion));
if ($err = $this->setLocalPhar($localFilename, $oldFile)) {
$this->getIO()->writeError('<error>The backup file was corrupted ('.$err->getMessage().') and has been removed.</error>');

return 1;
}

return 0;
}

protected function setLocalPhar($localFilename, $newFilename, $backupTarget = null)
{
try {
@chmod($newFilename, fileperms($localFilename));
if (!ini_get('phar.readonly')) {

 $phar = new \Phar($newFilename);

 unset($phar);
}


 if ($backupTarget && file_exists($localFilename)) {
@copy($localFilename, $backupTarget);
}

rename($newFilename, $localFilename);
} catch (\Exception $e) {
if ($backupTarget) {
@unlink($newFilename);
}
if (!$e instanceof \UnexpectedValueException && !$e instanceof \PharException) {
throw $e;
}

return $e;
}
}

protected function getLastBackupVersion($rollbackDir)
{
$finder = $this->getOldInstallationFinder($rollbackDir);
$finder->sortByName();
$files = iterator_to_array($finder);

if (count($files)) {
return basename(end($files), self::OLD_INSTALL_EXT);
}

return false;
}

protected function getOldInstallationFinder($rollbackDir)
{
$finder = Finder::create()
->depth(0)
->files()
->name('*' . self::OLD_INSTALL_EXT)
->in($rollbackDir);

return $finder;
}
}
<?php











namespace Composer\Command;

use Composer\DependencyResolver\Pool;
use Composer\DependencyResolver\DefaultPolicy;
use Composer\Factory;
use Composer\Package\CompletePackageInterface;
use Composer\Package\Version\VersionParser;
use Composer\Plugin\CommandEvent;
use Composer\Plugin\PluginEvents;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Composer\Repository\ArrayRepository;
use Composer\Repository\CompositeRepository;
use Composer\Repository\ComposerRepository;
use Composer\Repository\PlatformRepository;
use Composer\Repository\RepositoryInterface;
use Composer\Util\SpdxLicense;





class ShowCommand extends Command
{
protected $versionParser;

protected function configure()
{
$this
->setName('show')
->setAliases(array('info'))
->setDescription('Show information about packages')
->setDefinition(array(
new InputArgument('package', InputArgument::OPTIONAL, 'Package to inspect'),
new InputArgument('version', InputArgument::OPTIONAL, 'Version or version constraint to inspect'),
new InputOption('installed', 'i', InputOption::VALUE_NONE, 'List installed packages only'),
new InputOption('platform', 'p', InputOption::VALUE_NONE, 'List platform packages only'),
new InputOption('available', 'a', InputOption::VALUE_NONE, 'List available packages only'),
new InputOption('self', 's', InputOption::VALUE_NONE, 'Show the root package information'),
new InputOption('name-only', 'N', InputOption::VALUE_NONE, 'List package names only'),
new InputOption('path', 'P', InputOption::VALUE_NONE, 'Show package paths'),
))
->setHelp(<<<EOT
The show command displays detailed information about a package, or
lists all packages available.

EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
$this->versionParser = new VersionParser;


 $platformRepo = new PlatformRepository;

$composer = $this->getComposer(false);
if ($input->getOption('self')) {
$package = $this->getComposer()->getPackage();
$repos = $installedRepo = new ArrayRepository(array($package));
} elseif ($input->getOption('platform')) {
$repos = $installedRepo = $platformRepo;
} elseif ($input->getOption('installed')) {
$repos = $installedRepo = $this->getComposer()->getRepositoryManager()->getLocalRepository();
} elseif ($input->getOption('available')) {
$installedRepo = $platformRepo;
if ($composer) {
$repos = new CompositeRepository($composer->getRepositoryManager()->getRepositories());
} else {
$defaultRepos = Factory::createDefaultRepositories($this->getIO());
$repos = new CompositeRepository($defaultRepos);
$this->getIO()->writeError('No composer.json found in the current directory, showing available packages from ' . implode(', ', array_keys($defaultRepos)));
}
} elseif ($composer) {
$localRepo = $composer->getRepositoryManager()->getLocalRepository();
$installedRepo = new CompositeRepository(array($localRepo, $platformRepo));
$repos = new CompositeRepository(array_merge(array($installedRepo), $composer->getRepositoryManager()->getRepositories()));
} else {
$defaultRepos = Factory::createDefaultRepositories($this->getIO());
$this->getIO()->writeError('No composer.json found in the current directory, showing available packages from ' . implode(', ', array_keys($defaultRepos)));
$installedRepo = $platformRepo;
$repos = new CompositeRepository(array_merge(array($installedRepo), $defaultRepos));
}

if ($composer) {
$commandEvent = new CommandEvent(PluginEvents::COMMAND, 'show', $input, $output);
$composer->getEventDispatcher()->dispatch($commandEvent->getName(), $commandEvent);
}


 if ($input->getArgument('package') || !empty($package)) {
$versions = array();
if (empty($package)) {
list($package, $versions) = $this->getPackage($installedRepo, $repos, $input->getArgument('package'), $input->getArgument('version'));

if (!$package) {
throw new \InvalidArgumentException('Package '.$input->getArgument('package').' not found');
}
} else {
$versions = array($package->getPrettyVersion() => $package->getVersion());
}

$this->printMeta($package, $versions, $installedRepo);
$this->printLinks($package, 'requires');
$this->printLinks($package, 'devRequires', 'requires (dev)');
if ($package->getSuggests()) {
$this->getIO()->write("\n<info>suggests</info>");
foreach ($package->getSuggests() as $suggested => $reason) {
$this->getIO()->write($suggested . ' <comment>' . $reason . '</comment>');
}
}
$this->printLinks($package, 'provides');
$this->printLinks($package, 'conflicts');
$this->printLinks($package, 'replaces');

return;
}


 $packages = array();

if ($repos instanceof CompositeRepository) {
$repos = $repos->getRepositories();
} elseif (!is_array($repos)) {
$repos = array($repos);
}

foreach ($repos as $repo) {
if ($repo === $platformRepo) {
$type = '<info>platform</info>:';
} elseif (
$repo === $installedRepo
|| ($installedRepo instanceof CompositeRepository && in_array($repo, $installedRepo->getRepositories(), true))
) {
$type = '<info>installed</info>:';
} else {
$type = '<comment>available</comment>:';
}
if ($repo instanceof ComposerRepository && $repo->hasProviders()) {
foreach ($repo->getProviderNames() as $name) {
$packages[$type][$name] = $name;
}
} else {
foreach ($repo->getPackages() as $package) {
if (!isset($packages[$type][$package->getName()])
|| !is_object($packages[$type][$package->getName()])
|| version_compare($packages[$type][$package->getName()]->getVersion(), $package->getVersion(), '<')
) {
$packages[$type][$package->getName()] = $package;
}
}
}
}

$tree = !$input->getOption('platform') && !$input->getOption('installed') && !$input->getOption('available');
$indent = $tree ? '  ' : '';
foreach (array('<info>platform</info>:' => true, '<comment>available</comment>:' => false, '<info>installed</info>:' => true) as $type => $showVersion) {
if (isset($packages[$type])) {
if ($tree) {
$this->getIO()->write($type);
}
ksort($packages[$type]);

$nameLength = $versionLength = 0;
foreach ($packages[$type] as $package) {
if (is_object($package)) {
$nameLength = max($nameLength, strlen($package->getPrettyName()));
$versionLength = max($versionLength, strlen($this->versionParser->formatVersion($package)));
} else {
$nameLength = max($nameLength, $package);
}
}
list($width) = $this->getApplication()->getTerminalDimensions();
if (null === $width) {

 
 $width = PHP_INT_MAX;
}
if (defined('PHP_WINDOWS_VERSION_BUILD')) {
$width--;
}

$writePath = !$input->getOption('name-only') && $input->getOption('path');
$writeVersion = !$input->getOption('name-only') && !$input->getOption('path') && $showVersion && ($nameLength + $versionLength + 3 <= $width);
$writeDescription = !$input->getOption('name-only') && !$input->getOption('path') && ($nameLength + ($showVersion ? $versionLength : 0) + 24 <= $width);
foreach ($packages[$type] as $package) {
if (is_object($package)) {
$output->write($indent . str_pad($package->getPrettyName(), $nameLength, ' '), false);

if ($writeVersion) {
$output->write(' ' . str_pad($this->versionParser->formatVersion($package), $versionLength, ' '), false);
}

if ($writeDescription) {
$description = strtok($package->getDescription(), "\r\n");
$remaining = $width - $nameLength - $versionLength - 4;
if (strlen($description) > $remaining) {
$description = substr($description, 0, $remaining - 3) . '...';
}
$output->write(' ' . $description);
}

if ($writePath) {
$path = strtok(realpath($composer->getInstallationManager()->getInstallPath($package)), "\r\n");
$output->write(' ' . $path);
}
} else {
$output->write($indent . $package);
}
$this->getIO()->write('');
}
if ($tree) {
$this->getIO()->write('');
}
}
}
}











protected function getPackage(RepositoryInterface $installedRepo, RepositoryInterface $repos, $name, $version = null)
{
$name = strtolower($name);
$constraint = null;
if ($version) {
$constraint = $this->versionParser->parseConstraints($version);
}

$policy = new DefaultPolicy();
$pool = new Pool('dev');
$pool->addRepository($repos);

$matchedPackage = null;
$versions = array();
$matches = $pool->whatProvides($name, $constraint);
foreach ($matches as $index => $package) {

 if ($package->getName() !== $name) {
unset($matches[$index]);
continue;
}


 if (null === $version && $installedRepo->hasPackage($package)) {
$matchedPackage = $package;
}

$versions[$package->getPrettyVersion()] = $package->getVersion();
$matches[$index] = $package->getId();
}


 if (!$matchedPackage && $matches && $preferred = $policy->selectPreferredPackages($pool, array(), $matches)) {
$matchedPackage = $pool->literalToPackage($preferred[0]);
}

return array($matchedPackage, $versions);
}




protected function printMeta(CompletePackageInterface $package, array $versions, RepositoryInterface $installedRepo)
{
$this->getIO()->write('<info>name</info>     : ' . $package->getPrettyName());
$this->getIO()->write('<info>descrip.</info> : ' . $package->getDescription());
$this->getIO()->write('<info>keywords</info> : ' . join(', ', $package->getKeywords() ?: array()));
$this->printVersions($package, $versions, $installedRepo);
$this->getIO()->write('<info>type</info>     : ' . $package->getType());
$this->printLicenses($package);
$this->getIO()->write('<info>source</info>   : ' . sprintf('[%s] <comment>%s</comment> %s', $package->getSourceType(), $package->getSourceUrl(), $package->getSourceReference()));
$this->getIO()->write('<info>dist</info>     : ' . sprintf('[%s] <comment>%s</comment> %s', $package->getDistType(), $package->getDistUrl(), $package->getDistReference()));
$this->getIO()->write('<info>names</info>    : ' . implode(', ', $package->getNames()));

if ($package->isAbandoned()) {
$replacement = ($package->getReplacementPackage() !== null)
? ' The author suggests using the ' . $package->getReplacementPackage(). ' package instead.'
: null;

$this->getIO()->writeError(
sprintf('<warning>Attention: This package is abandoned and no longer maintained.%s</warning>', $replacement)
);
}

if ($package->getSupport()) {
$this->getIO()->write("\n<info>support</info>");
foreach ($package->getSupport() as $type => $value) {
$this->getIO()->write('<comment>' . $type . '</comment> : '.$value);
}
}

if ($package->getAutoload()) {
$this->getIO()->write("\n<info>autoload</info>");
foreach ($package->getAutoload() as $type => $autoloads) {
$this->getIO()->write('<comment>' . $type . '</comment>');

if ($type === 'psr-0') {
foreach ($autoloads as $name => $path) {
$this->getIO()->write(($name ?: '*') . ' => ' . (is_array($path) ? implode(', ', $path) : ($path ?: '.')));
}
} elseif ($type === 'psr-4') {
foreach ($autoloads as $name => $path) {
$this->getIO()->write(($name ?: '*') . ' => ' . (is_array($path) ? implode(', ', $path) : ($path ?: '.')));
}
} elseif ($type === 'classmap') {
$this->getIO()->write(implode(', ', $autoloads));
}
}
if ($package->getIncludePaths()) {
$this->getIO()->write('<comment>include-path</comment>');
$this->getIO()->write(implode(', ', $package->getIncludePaths()));
}
}
}




protected function printVersions(CompletePackageInterface $package, array $versions, RepositoryInterface $installedRepo)
{
uasort($versions, 'version_compare');
$versions = array_keys(array_reverse($versions));


 if ($installedRepo->hasPackage($package)) {
$installedVersion = $package->getPrettyVersion();
$key = array_search($installedVersion, $versions);
if (false !== $key) {
$versions[$key] = '<info>* ' . $installedVersion . '</info>';
}
}

$versions = implode(', ', $versions);

$this->getIO()->write('<info>versions</info> : ' . $versions);
}








protected function printLinks(CompletePackageInterface $package, $linkType, $title = null)
{
$title = $title ?: $linkType;
if ($links = $package->{'get'.ucfirst($linkType)}()) {
$this->getIO()->write("\n<info>" . $title . "</info>");

foreach ($links as $link) {
$this->getIO()->write($link->getTarget() . ' <comment>' . $link->getPrettyConstraint() . '</comment>');
}
}
}






protected function printLicenses(CompletePackageInterface $package)
{
$spdxLicense = new SpdxLicense;

$licenses = $package->getLicense();

foreach ($licenses as $licenseId) {
$license = $spdxLicense->getLicenseByIdentifier($licenseId); 

if (!$license) {
$out = $licenseId;
} else {

 if ($license[1] === true) {
$out = sprintf('%s (%s) (OSI approved) %s', $license[0], $licenseId, $license[2]);
} else {
$out = sprintf('%s (%s) %s', $license[0], $licenseId, $license[2]);
}
}

$this->getIO()->write('<info>license</info>  : ' . $out);
}
}
}
<?php











namespace Composer\Command;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Composer\Downloader\ChangeReportInterface;
use Composer\Plugin\CommandEvent;
use Composer\Plugin\PluginEvents;
use Composer\Script\ScriptEvents;





class StatusCommand extends Command
{
protected function configure()
{
$this
->setName('status')
->setDescription('Show a list of locally modified packages')
->setDefinition(array(
new InputOption('verbose', 'v|vv|vvv', InputOption::VALUE_NONE, 'Show modified files for each directory that contains changes.'),
))
->setHelp(<<<EOT
The status command displays a list of dependencies that have
been modified locally.

EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{

 $composer = $this->getComposer();

$commandEvent = new CommandEvent(PluginEvents::COMMAND, 'status', $input, $output);
$composer->getEventDispatcher()->dispatch($commandEvent->getName(), $commandEvent);

$installedRepo = $composer->getRepositoryManager()->getLocalRepository();

$dm = $composer->getDownloadManager();
$im = $composer->getInstallationManager();


 $composer->getEventDispatcher()->dispatchScript(ScriptEvents::PRE_STATUS_CMD, true);

$errors = array();


 foreach ($installedRepo->getPackages() as $package) {
$downloader = $dm->getDownloaderForInstalledPackage($package);

if ($downloader instanceof ChangeReportInterface) {
$targetDir = $im->getInstallPath($package);

if ($changes = $downloader->getLocalChanges($package, $targetDir)) {
$errors[$targetDir] = $changes;
}
}
}


 if (!$errors) {
$this->getIO()->writeError('<info>No local changes</info>');
} else {
$this->getIO()->writeError('<error>You have changes in the following dependencies:</error>');
}

foreach ($errors as $path => $changes) {
if ($input->getOption('verbose')) {
$indentedChanges = implode("\n", array_map(function ($line) {
return '    ' . ltrim($line);
}, explode("\n", $changes)));
$this->getIO()->write('<info>'.$path.'</info>:');
$this->getIO()->write($indentedChanges);
} else {
$this->getIO()->write($path);
}
}

if ($errors && !$input->getOption('verbose')) {
$this->getIO()->writeError('Use --verbose (-v) to see modified files');
}


 $composer->getEventDispatcher()->dispatchScript(ScriptEvents::POST_STATUS_CMD, true);

return $errors ? 1 : 0;
}
}
<?php











namespace Composer\Command;

use Composer\Installer;
use Composer\Plugin\CommandEvent;
use Composer\Plugin\PluginEvents;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Output\OutputInterface;





class UpdateCommand extends Command
{
protected function configure()
{
$this
->setName('update')
->setDescription('Updates your dependencies to the latest version according to composer.json, and updates the composer.lock file.')
->setDefinition(array(
new InputArgument('packages', InputArgument::IS_ARRAY | InputArgument::OPTIONAL, 'Packages that should be updated, if not provided all packages are.'),
new InputOption('prefer-source', null, InputOption::VALUE_NONE, 'Forces installation from package sources when possible, including VCS information.'),
new InputOption('prefer-dist', null, InputOption::VALUE_NONE, 'Forces installation from package dist even for dev versions.'),
new InputOption('dry-run', null, InputOption::VALUE_NONE, 'Outputs the operations but will not execute anything (implicitly enables --verbose).'),
new InputOption('dev', null, InputOption::VALUE_NONE, 'Enables installation of require-dev packages (enabled by default, only present for BC).'),
new InputOption('no-dev', null, InputOption::VALUE_NONE, 'Disables installation of require-dev packages.'),
new InputOption('lock', null, InputOption::VALUE_NONE, 'Only updates the lock file hash to suppress warning about the lock file being out of date.'),
new InputOption('no-plugins', null, InputOption::VALUE_NONE, 'Disables all plugins.'),
new InputOption('no-custom-installers', null, InputOption::VALUE_NONE, 'DEPRECATED: Use no-plugins instead.'),
new InputOption('no-autoloader', null, InputOption::VALUE_NONE, 'Skips autoloader generation'),
new InputOption('no-scripts', null, InputOption::VALUE_NONE, 'Skips the execution of all scripts defined in composer.json file.'),
new InputOption('no-progress', null, InputOption::VALUE_NONE, 'Do not output download progress.'),
new InputOption('with-dependencies', null, InputOption::VALUE_NONE, 'Add also all dependencies of whitelisted packages to the whitelist.'),
new InputOption('verbose', 'v|vv|vvv', InputOption::VALUE_NONE, 'Shows more details including new commits pulled in when updating packages.'),
new InputOption('optimize-autoloader', 'o', InputOption::VALUE_NONE, 'Optimize autoloader during autoloader dump.'),
new InputOption('ignore-platform-reqs', null, InputOption::VALUE_NONE, 'Ignore platform requirements (php & ext- packages).'),
new InputOption('prefer-stable', null, InputOption::VALUE_NONE, 'Prefer stable versions of dependencies.'),
new InputOption('prefer-lowest', null, InputOption::VALUE_NONE, 'Prefer lowest versions of dependencies.'),
))
->setHelp(<<<EOT
The <info>update</info> command reads the composer.json file from the
current directory, processes it, and updates, removes or installs all the
dependencies.

<info>php composer.phar update</info>

To limit the update operation to a few packages, you can list the package(s)
you want to update as such:

<info>php composer.phar update vendor/package1 foo/mypackage [...]</info>

You may also use an asterisk (*) pattern to limit the update operation to package(s)
from a specific vendor:

<info>php composer.phar update vendor/package1 foo/* [...]</info>
EOT
)
;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
if ($input->getOption('no-custom-installers')) {
$this->getIO()->writeError('<warning>You are using the deprecated option "no-custom-installers". Use "no-plugins" instead.</warning>');
$input->setOption('no-plugins', true);
}

if ($input->getOption('dev')) {
$this->getIO()->writeError('<warning>You are using the deprecated option "dev". Dev packages are installed by default now.</warning>');
}

$composer = $this->getComposer(true, $input->getOption('no-plugins'));
$composer->getDownloadManager()->setOutputProgress(!$input->getOption('no-progress'));
$io = $this->getIO();

$commandEvent = new CommandEvent(PluginEvents::COMMAND, 'update', $input, $output);
$composer->getEventDispatcher()->dispatch($commandEvent->getName(), $commandEvent);

$install = Installer::create($io, $composer);

$preferSource = false;
$preferDist = false;

$config = $composer->getConfig();

switch ($config->get('preferred-install')) {
case 'source':
$preferSource = true;
break;
case 'dist':
$preferDist = true;
break;
case 'auto':
default:

 break;
}
if ($input->getOption('prefer-source') || $input->getOption('prefer-dist')) {
$preferSource = $input->getOption('prefer-source');
$preferDist = $input->getOption('prefer-dist');
}

$optimize = $input->getOption('optimize-autoloader') || $config->get('optimize-autoloader') || $config->get('classmap-authoritative');

$install
->setDryRun($input->getOption('dry-run'))
->setVerbose($input->getOption('verbose'))
->setPreferSource($preferSource)
->setPreferDist($preferDist)
->setDevMode(!$input->getOption('no-dev'))
->setDumpAutoloader(!$input->getOption('no-autoloader'))
->setRunScripts(!$input->getOption('no-scripts'))
->setOptimizeAutoloader($optimize)
->setUpdate(true)
->setUpdateWhitelist($input->getOption('lock') ? array('lock') : $input->getArgument('packages'))
->setWhitelistDependencies($input->getOption('with-dependencies'))
->setIgnorePlatformRequirements($input->getOption('ignore-platform-reqs'))
->setPreferStable($input->getOption('prefer-stable'))
->setPreferLowest($input->getOption('prefer-lowest'))
;

if ($input->getOption('no-plugins')) {
$install->disablePlugins();
}

return $install->run();
}
}
<?php











namespace Composer\Command;

use Composer\Package\Loader\ValidatingArrayLoader;
use Composer\Util\ConfigValidator;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;







class ValidateCommand extends Command
{



protected function configure()
{
$this
->setName('validate')
->setDescription('Validates a composer.json')
->setDefinition(array(
new InputOption('no-check-all', null, InputOption::VALUE_NONE, 'Do not make a complete validation'),
new InputOption('no-check-publish', null, InputOption::VALUE_NONE, 'Do not check for publish errors'),
new InputArgument('file', InputArgument::OPTIONAL, 'path to composer.json file', './composer.json')
))
->setHelp(<<<EOT
The validate command validates a given composer.json

EOT
);
}







protected function execute(InputInterface $input, OutputInterface $output)
{
$file = $input->getArgument('file');

if (!file_exists($file)) {
$this->getIO()->writeError('<error>' . $file . ' not found.</error>');

return 1;
}
if (!is_readable($file)) {
$this->getIO()->writeError('<error>' . $file . ' is not readable.</error>');

return 1;
}

$validator = new ConfigValidator($this->getIO());
$checkAll = $input->getOption('no-check-all') ? 0 : ValidatingArrayLoader::CHECK_ALL;
$checkPublish = !$input->getOption('no-check-publish');
list($errors, $publishErrors, $warnings) = $validator->validate($file, $checkAll);


 if (!$errors && !$publishErrors && !$warnings) {
$this->getIO()->write('<info>' . $file . ' is valid</info>');
} elseif (!$errors && !$publishErrors) {
$this->getIO()->writeError('<info>' . $file . ' is valid, but with a few warnings</info>');
$this->getIO()->writeError('<warning>See https://getcomposer.org/doc/04-schema.md for details on the schema</warning>');
} elseif (!$errors) {
$this->getIO()->writeError('<info>' . $file . ' is valid for simple usage with composer but has</info>');
$this->getIO()->writeError('<info>strict errors that make it unable to be published as a package:</info>');
$this->getIO()->writeError('<warning>See https://getcomposer.org/doc/04-schema.md for details on the schema</warning>');
} else {
$this->getIO()->writeError('<error>' . $file . ' is invalid, the following errors/warnings were found:</error>');
}

$messages = array(
'error' => $errors,
'warning' => $warnings,
);


 if ($checkPublish) {
$messages['error'] = array_merge($messages['error'], $publishErrors);
} else {
$messages['warning'] = array_merge($messages['warning'], $publishErrors);
}

foreach ($messages as $style => $msgs) {
foreach ($msgs as $msg) {
$this->getIO()->writeError('<' . $style . '>' . $msg . '</' . $style . '>');
}
}

return $errors || ($publishErrors && $checkPublish) ? 1 : 0;
}
}
<?php











namespace Composer;

use Composer\Package\RootPackageInterface;
use Composer\Package\Locker;
use Composer\Repository\RepositoryManager;
use Composer\Installer\InstallationManager;
use Composer\Plugin\PluginManager;
use Composer\Downloader\DownloadManager;
use Composer\EventDispatcher\EventDispatcher;
use Composer\Autoload\AutoloadGenerator;






class Composer
{
const VERSION = 'e64470c987fdd6bff03b85eed823eb4b865a4152';
const BRANCH_ALIAS_VERSION = '1.0-dev';
const RELEASE_DATE = '2015-05-28 14:52:12';




private $package;




private $locker;




private $repositoryManager;




private $downloadManager;




private $installationManager;




private $pluginManager;




private $config;




private $eventDispatcher;




private $autoloadGenerator;





public function setPackage(RootPackageInterface $package)
{
$this->package = $package;
}




public function getPackage()
{
return $this->package;
}




public function setConfig(Config $config)
{
$this->config = $config;
}




public function getConfig()
{
return $this->config;
}




public function setLocker(Locker $locker)
{
$this->locker = $locker;
}




public function getLocker()
{
return $this->locker;
}




public function setRepositoryManager(RepositoryManager $manager)
{
$this->repositoryManager = $manager;
}




public function getRepositoryManager()
{
return $this->repositoryManager;
}




public function setDownloadManager(DownloadManager $manager)
{
$this->downloadManager = $manager;
}




public function getDownloadManager()
{
return $this->downloadManager;
}




public function setInstallationManager(InstallationManager $manager)
{
$this->installationManager = $manager;
}




public function getInstallationManager()
{
return $this->installationManager;
}




public function setPluginManager(PluginManager $manager)
{
$this->pluginManager = $manager;
}




public function getPluginManager()
{
return $this->pluginManager;
}




public function setEventDispatcher(EventDispatcher $eventDispatcher)
{
$this->eventDispatcher = $eventDispatcher;
}




public function getEventDispatcher()
{
return $this->eventDispatcher;
}




public function setAutoloadGenerator(AutoloadGenerator $autoloadGenerator)
{
$this->autoloadGenerator = $autoloadGenerator;
}




public function getAutoloadGenerator()
{
return $this->autoloadGenerator;
}
}
<?php











namespace Composer;

use Composer\Config\ConfigSourceInterface;




class Config
{
const RELATIVE_PATHS = 1;

public static $defaultConfig = array(
'process-timeout' => 300,
'use-include-path' => false,
'preferred-install' => 'auto',
'notify-on-install' => true,
'github-protocols' => array('git', 'https', 'ssh'),
'vendor-dir' => 'vendor',
'bin-dir' => '{$vendor-dir}/bin',
'cache-dir' => '{$home}/cache',
'cache-files-dir' => '{$cache-dir}/files',
'cache-repo-dir' => '{$cache-dir}/repo',
'cache-vcs-dir' => '{$cache-dir}/vcs',
'cache-ttl' => 15552000, 
 'cache-files-ttl' => null, 
 'cache-files-maxsize' => '300MiB',
'discard-changes' => false,
'autoloader-suffix' => null,
'optimize-autoloader' => false,
'classmap-authoritative' => false,
'prepend-autoloader' => true,
'github-domains' => array('github.com'),
'github-expose-hostname' => true,
'store-auths' => 'prompt',
'platform' => array(),

 
 
 );

public static $defaultRepositories = array(
'packagist' => array(
'type' => 'composer',
'url' => 'https?://packagist.org',
'allow_ssl_downgrade' => true,
)
);

private $config;
private $baseDir;
private $repositories;
private $configSource;
private $authConfigSource;
private $useEnvironment;




public function __construct($useEnvironment = true, $baseDir = null)
{

 $this->config = static::$defaultConfig;
$this->repositories = static::$defaultRepositories;
$this->useEnvironment = (bool) $useEnvironment;
$this->baseDir = $baseDir;
}

public function setConfigSource(ConfigSourceInterface $source)
{
$this->configSource = $source;
}

public function getConfigSource()
{
return $this->configSource;
}

public function setAuthConfigSource(ConfigSourceInterface $source)
{
$this->authConfigSource = $source;
}

public function getAuthConfigSource()
{
return $this->authConfigSource;
}






public function merge($config)
{

 if (!empty($config['config']) && is_array($config['config'])) {
foreach ($config['config'] as $key => $val) {
if (in_array($key, array('github-oauth', 'http-basic')) && isset($this->config[$key])) {
$this->config[$key] = array_merge($this->config[$key], $val);
} else {
$this->config[$key] = $val;
}
}
}

if (!empty($config['repositories']) && is_array($config['repositories'])) {
$this->repositories = array_reverse($this->repositories, true);
$newRepos = array_reverse($config['repositories'], true);
foreach ($newRepos as $name => $repository) {

 if (false === $repository) {
unset($this->repositories[$name]);
continue;
}


 if (is_array($repository) && 1 === count($repository) && false === current($repository)) {
unset($this->repositories[key($repository)]);
continue;
}


 if (is_int($name)) {
$this->repositories[] = $repository;
} else {
$this->repositories[$name] = $repository;
}
}
$this->repositories = array_reverse($this->repositories, true);
}
}




public function getRepositories()
{
return $this->repositories;
}









public function get($key, $flags = 0)
{
switch ($key) {
case 'vendor-dir':
case 'bin-dir':
case 'process-timeout':
case 'cache-dir':
case 'cache-files-dir':
case 'cache-repo-dir':
case 'cache-vcs-dir':

 $env = 'COMPOSER_' . strtoupper(strtr($key, '-', '_'));

$val = rtrim($this->process($this->getComposerEnv($env) ?: $this->config[$key], $flags), '/\\');
$val = preg_replace('#^(\$HOME|~)(/|$)#', rtrim(getenv('HOME') ?: getenv('USERPROFILE'), '/\\') . '/', $val);

if (substr($key, -4) !== '-dir') {
return $val;
}

return ($flags & self::RELATIVE_PATHS == 1) ? $val : $this->realpath($val);

case 'cache-ttl':
return (int) $this->config[$key];

case 'cache-files-maxsize':
if (!preg_match('/^\s*([0-9.]+)\s*(?:([kmg])(?:i?b)?)?\s*$/i', $this->config[$key], $matches)) {
throw new \RuntimeException(
"Could not parse the value of 'cache-files-maxsize': {$this->config[$key]}"
);
}
$size = $matches[1];
if (isset($matches[2])) {
switch (strtolower($matches[2])) {
case 'g':
$size *= 1024;

 case 'm':
$size *= 1024;

 case 'k':
$size *= 1024;
break;
}
}

return $size;

case 'cache-files-ttl':
if (isset($this->config[$key])) {
return (int) $this->config[$key];
}

return (int) $this->config['cache-ttl'];

case 'home':
return rtrim($this->process($this->config[$key], $flags), '/\\');

case 'discard-changes':
if ($env = $this->getComposerEnv('COMPOSER_DISCARD_CHANGES')) {
if (!in_array($env, array('stash', 'true', 'false', '1', '0'), true)) {
throw new \RuntimeException(
"Invalid value for COMPOSER_DISCARD_CHANGES: {$env}. Expected 1, 0, true, false or stash"
);
}
if ('stash' === $env) {
return 'stash';
}


 return $env !== 'false' && (bool) $env;
}

if (!in_array($this->config[$key], array(true, false, 'stash'), true)) {
throw new \RuntimeException(
"Invalid value for 'discard-changes': {$this->config[$key]}. Expected true, false or stash"
);
}

return $this->config[$key];

case 'github-protocols':
if (reset($this->config['github-protocols']) === 'http') {
throw new \RuntimeException('The http protocol for github is not available anymore, update your config\'s github-protocols to use "https", "git" or "ssh"');
}

return $this->config[$key];

default:
if (!isset($this->config[$key])) {
return null;
}

return $this->process($this->config[$key], $flags);
}
}

public function all($flags = 0)
{
$all = array(
'repositories' => $this->getRepositories(),
);
foreach (array_keys($this->config) as $key) {
$all['config'][$key] = $this->get($key, $flags);
}

return $all;
}

public function raw()
{
return array(
'repositories' => $this->getRepositories(),
'config' => $this->config,
);
}







public function has($key)
{
return array_key_exists($key, $this->config);
}








private function process($value, $flags)
{
$config = $this;

if (!is_string($value)) {
return $value;
}

return preg_replace_callback('#\{\$(.+)\}#', function ($match) use ($config, $flags) {
return $config->get($match[1], $flags);
}, $value);
}









private function realpath($path)
{
if (substr($path, 0, 1) === '/' || substr($path, 1, 1) === ':') {
return $path;
}

return $this->baseDir . '/' . $path;
}










private function getComposerEnv($var)
{
if ($this->useEnvironment) {
return getenv($var);
}

return false;
}
}
<?php











namespace Composer\Config;







interface ConfigSourceInterface
{






public function addRepository($name, $config);






public function removeRepository($name);







public function addConfigSetting($name, $value);






public function removeConfigSetting($name);








public function addLink($type, $name, $value);







public function removeLink($type, $name);






public function getName();
}
<?php











namespace Composer\Config;

use Composer\Json\JsonFile;
use Composer\Json\JsonManipulator;







class JsonConfigSource implements ConfigSourceInterface
{



private $file;




private $authConfig;







public function __construct(JsonFile $file, $authConfig = false)
{
$this->file = $file;
$this->authConfig = $authConfig;
}




public function getName()
{
return $this->file->getPath();
}




public function addRepository($name, $config)
{
$this->manipulateJson('addRepository', $name, $config, function (&$config, $repo, $repoConfig) {
$config['repositories'][$repo] = $repoConfig;
});
}




public function removeRepository($name)
{
$this->manipulateJson('removeRepository', $name, function (&$config, $repo) {
unset($config['repositories'][$repo]);
});
}




public function addConfigSetting($name, $value)
{
$this->manipulateJson('addConfigSetting', $name, $value, function (&$config, $key, $val) {
if (preg_match('{^(github-oauth|http-basic|platform)\.}', $key)) {
list($key, $host) = explode('.', $key, 2);
if ($this->authConfig) {
$config[$key][$host] = $val;
} else {
$config['config'][$key][$host] = $val;
}
} else {
$config['config'][$key] = $val;
}
});
}




public function removeConfigSetting($name)
{
$this->manipulateJson('removeConfigSetting', $name, function (&$config, $key) {
if (preg_match('{^(github-oauth|http-basic|platform)\.}', $key)) {
list($key, $host) = explode('.', $key, 2);
if ($this->authConfig) {
unset($config[$key][$host]);
} else {
unset($config['config'][$key][$host]);
}
} else {
unset($config['config'][$key]);
}
});
}




public function addLink($type, $name, $value)
{
$this->manipulateJson('addLink', $type, $name, $value, function (&$config, $type, $name, $value) {
$config[$type][$name] = $value;
});
}




public function removeLink($type, $name)
{
$this->manipulateJson('removeSubNode', $type, $name, function (&$config, $type, $name) {
unset($config[$type][$name]);
});
}

protected function manipulateJson($method, $args, $fallback)
{
$args = func_get_args();

 array_shift($args);
$fallback = array_pop($args);

if ($this->file->exists()) {
$contents = file_get_contents($this->file->getPath());
} elseif ($this->authConfig) {
$contents = "{\n}\n";
} else {
$contents = "{\n    \"config\": {\n    }\n}\n";
}

$manipulator = new JsonManipulator($contents);

$newFile = !$this->file->exists();


 if ($this->authConfig && $method === 'addConfigSetting') {
$method = 'addSubNode';
list($mainNode, $name) = explode('.', $args[0], 2);
$args = array($mainNode, $name, $args[1]);
} elseif ($this->authConfig && $method === 'removeConfigSetting') {
$method = 'removeSubNode';
list($mainNode, $name) = explode('.', $args[0], 2);
$args = array($mainNode, $name);
}


 if (call_user_func_array(array($manipulator, $method), $args)) {
file_put_contents($this->file->getPath(), $manipulator->getContents());
} else {

 $config = $this->file->read();
$this->arrayUnshiftRef($args, $config);
call_user_func_array($fallback, $args);
$this->file->write($config);
}

if ($newFile) {
@chmod($this->file->getPath(), 0600);
}
}








private function arrayUnshiftRef(&$array, &$value)
{
$return = array_unshift($array, '');
$array[0] = &$value;

return $return;
}
}
<?php











namespace Composer\Console;

use Symfony\Component\Console\Application as BaseApplication;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\ConsoleOutputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Output\ConsoleOutput;
use Symfony\Component\Console\Formatter\OutputFormatter;
use Composer\Command;
use Composer\Composer;
use Composer\Factory;
use Composer\IO\IOInterface;
use Composer\IO\ConsoleIO;
use Composer\Json\JsonValidationException;
use Composer\Util\ErrorHandler;








class Application extends BaseApplication
{



protected $composer;




protected $io;

private static $logo = '   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
';

public function __construct()
{
if (function_exists('ini_set') && extension_loaded('xdebug')) {
ini_set('xdebug.show_exception_trace', false);
ini_set('xdebug.scream', false);
}

if (function_exists('date_default_timezone_set') && function_exists('date_default_timezone_get')) {
date_default_timezone_set(@date_default_timezone_get());
}

ErrorHandler::register();
parent::__construct('Composer', Composer::VERSION);
}




public function run(InputInterface $input = null, OutputInterface $output = null)
{
if (null === $output) {
$styles = Factory::createAdditionalStyles();
$formatter = new OutputFormatter(null, $styles);
$output = new ConsoleOutput(ConsoleOutput::VERBOSITY_NORMAL, null, $formatter);
}

return parent::run($input, $output);
}




public function doRun(InputInterface $input, OutputInterface $output)
{
$this->io = new ConsoleIO($input, $output, $this->getHelperSet());

if (PHP_VERSION_ID < 50302) {
$this->getIO()->writeError('<warning>Composer only officially supports PHP 5.3.2 and above, you will most likely encounter problems with your PHP '.PHP_VERSION.', upgrading is strongly recommended.</warning>');
}

if (defined('COMPOSER_DEV_WARNING_TIME')) {
$commandName = '';
if ($name = $this->getCommandName($input)) {
try {
$commandName = $this->find($name)->getName();
} catch (\InvalidArgumentException $e) {
}
}
if ($commandName !== 'self-update' && $commandName !== 'selfupdate') {
if (time() > COMPOSER_DEV_WARNING_TIME) {
$this->getIO()->writeError(sprintf('<warning>Warning: This development build of composer is over 60 days old. It is recommended to update it by running "%s self-update" to get the latest version.</warning>', $_SERVER['PHP_SELF']));
}
}
}

if (getenv('COMPOSER_NO_INTERACTION')) {
$input->setInteractive(false);
}


 if ($newWorkDir = $this->getNewWorkingDir($input)) {
$oldWorkingDir = getcwd();
chdir($newWorkDir);
if ($this->getIO()->isDebug() >= 4) {
$this->getIO()->writeError('Changed CWD to ' . getcwd());
}
}


 $file = Factory::getComposerFile();
if (is_file($file) && is_readable($file) && is_array($composer = json_decode(file_get_contents($file), true))) {
if (isset($composer['scripts']) && is_array($composer['scripts'])) {
foreach ($composer['scripts'] as $script => $dummy) {
if (!defined('Composer\Script\ScriptEvents::'.str_replace('-', '_', strtoupper($script)))) {
if ($this->has($script)) {
$this->getIO()->writeError('<warning>A script named '.$script.' would override a native Composer function and has been skipped</warning>');
} else {
$this->add(new Command\ScriptAliasCommand($script));
}
}
}
}
}

if ($input->hasParameterOption('--profile')) {
$startTime = microtime(true);
$this->io->enableDebugging($startTime);
}

$result = parent::doRun($input, $output);

if (isset($oldWorkingDir)) {
chdir($oldWorkingDir);
}

if (isset($startTime)) {
$this->getIO()->writeError('<info>Memory usage: '.round(memory_get_usage() / 1024 / 1024, 2).'MB (peak: '.round(memory_get_peak_usage() / 1024 / 1024, 2).'MB), time: '.round(microtime(true) - $startTime, 2).'s');
}

return $result;
}






private function getNewWorkingDir(InputInterface $input)
{
$workingDir = $input->getParameterOption(array('--working-dir', '-d'));
if (false !== $workingDir && !is_dir($workingDir)) {
throw new \RuntimeException('Invalid working directory specified.');
}

return $workingDir;
}




public function renderException($exception, $output)
{
try {
$composer = $this->getComposer(false, true);
if ($composer) {
$config = $composer->getConfig();

$minSpaceFree = 1024*1024;
if ((($df = @disk_free_space($dir = $config->get('home'))) !== false && $df < $minSpaceFree)
|| (($df = @disk_free_space($dir = $config->get('vendor-dir'))) !== false && $df < $minSpaceFree)
|| (($df = @disk_free_space($dir = sys_get_temp_dir())) !== false && $df < $minSpaceFree)
) {
$this->getIO()->writeError('<error>The disk hosting '.$dir.' is full, this may be the cause of the following exception</error>');
}
}
} catch (\Exception $e) {
}

if (defined('PHP_WINDOWS_VERSION_BUILD') && false !== strpos($exception->getMessage(), 'The system cannot find the path specified')) {
$this->getIO()->writeError('<error>The following exception may be caused by a stale entry in your cmd.exe AutoRun</error>');
$this->getIO()->writeError('<error>Check https://getcomposer.org/doc/articles/troubleshooting.md#-the-system-cannot-find-the-path-specified-windows- for details</error>');
}

if (false !== strpos($exception->getMessage(), 'fork failed - Cannot allocate memory')) {
$this->getIO()->writeError('<error>The following exception is caused by a lack of memory and not having swap configured</error>');
$this->getIO()->writeError('<error>Check https://getcomposer.org/doc/articles/troubleshooting.md#proc-open-fork-failed-errors for details</error>');
}

if ($output instanceof ConsoleOutputInterface) {
parent::renderException($exception, $output->getErrorOutput());
} else {
parent::renderException($exception, $output);
}
}







public function getComposer($required = true, $disablePlugins = false)
{
if (null === $this->composer) {
try {
$this->composer = Factory::create($this->io, null, $disablePlugins);
} catch (\InvalidArgumentException $e) {
if ($required) {
$this->io->writeError($e->getMessage());
exit(1);
}
} catch (JsonValidationException $e) {
$errors = ' - ' . implode(PHP_EOL . ' - ', $e->getErrors());
$message = $e->getMessage() . ':' . PHP_EOL . $errors;
throw new JsonValidationException($message);
}
}

return $this->composer;
}




public function resetComposer()
{
$this->composer = null;
}




public function getIO()
{
return $this->io;
}

public function getHelp()
{
return self::$logo . parent::getHelp();
}




protected function getDefaultCommands()
{
$commands = parent::getDefaultCommands();
$commands[] = new Command\AboutCommand();
$commands[] = new Command\ConfigCommand();
$commands[] = new Command\DependsCommand();
$commands[] = new Command\InitCommand();
$commands[] = new Command\InstallCommand();
$commands[] = new Command\CreateProjectCommand();
$commands[] = new Command\UpdateCommand();
$commands[] = new Command\SearchCommand();
$commands[] = new Command\ValidateCommand();
$commands[] = new Command\ShowCommand();
$commands[] = new Command\RequireCommand();
$commands[] = new Command\DumpAutoloadCommand();
$commands[] = new Command\StatusCommand();
$commands[] = new Command\ArchiveCommand();
$commands[] = new Command\DiagnoseCommand();
$commands[] = new Command\RunScriptCommand();
$commands[] = new Command\LicensesCommand();
$commands[] = new Command\GlobalCommand();
$commands[] = new Command\ClearCacheCommand();
$commands[] = new Command\RemoveCommand();
$commands[] = new Command\HomeCommand();

if ('phar:' === substr(__FILE__, 0, 5)) {
$commands[] = new Command\SelfUpdateCommand();
}

return $commands;
}




public function getLongVersion()
{
if (Composer::BRANCH_ALIAS_VERSION) {
return sprintf(
'<info>%s</info> version <comment>%s (%s)</comment> %s',
$this->getName(),
Composer::BRANCH_ALIAS_VERSION,
$this->getVersion(),
Composer::RELEASE_DATE
);
}

return parent::getLongVersion() . ' ' . Composer::RELEASE_DATE;
}




protected function getDefaultInputDefinition()
{
$definition = parent::getDefaultInputDefinition();
$definition->addOption(new InputOption('--profile', null, InputOption::VALUE_NONE, 'Display timing and memory usage information'));
$definition->addOption(new InputOption('--working-dir', '-d', InputOption::VALUE_REQUIRED, 'If specified, use the given directory as working directory.'));

return $definition;
}
}
<?php











namespace Composer\Console;

use Symfony\Component\Console\Formatter\OutputFormatter;




class HtmlOutputFormatter extends OutputFormatter
{
private static $availableForegroundColors = array(
30 => 'black',
31 => 'red',
32 => 'green',
33 => 'yellow',
34 => 'blue',
35 => 'magenta',
36 => 'cyan',
37 => 'white'
);
private static $availableBackgroundColors = array(
40 => 'black',
41 => 'red',
42 => 'green',
43 => 'yellow',
44 => 'blue',
45 => 'magenta',
46 => 'cyan',
47 => 'white'
);
private static $availableOptions = array(
1 => 'bold',
4 => 'underscore',

 
 
 );




public function __construct(array $styles = array())
{
parent::__construct(true, $styles);
}

public function format($message)
{
$formatted = parent::format($message);

return preg_replace_callback("{\033\[([0-9;]+)m(.*?)\033\[0m}s", array($this, 'formatHtml'), $formatted);
}

private function formatHtml($matches)
{
$out = '<span style="';
foreach (explode(';', $matches[1]) as $code) {
if (isset(self::$availableForegroundColors[$code])) {
$out .= 'color:'.self::$availableForegroundColors[$code].';';
} elseif (isset(self::$availableBackgroundColors[$code])) {
$out .= 'background-color:'.self::$availableBackgroundColors[$code].';';
} elseif (isset(self::$availableOptions[$code])) {
switch (self::$availableOptions[$code]) {
case 'bold':
$out .= 'font-weight:bold;';
break;

case 'underscore':
$out .= 'text-decoration:underline;';
break;
}
}
}

return $out.'">'.$matches[2].'</span>';
}
}
<?php











namespace Composer\DependencyResolver;




class DebugSolver extends Solver
{
protected function printDecisionMap()
{
echo "\nDecisionMap: \n";
foreach ($this->decisionMap as $packageId => $level) {
if ($packageId === 0) {
continue;
}
if ($level > 0) {
echo '    +' . $this->pool->packageById($packageId)."\n";
} elseif ($level < 0) {
echo '    -' . $this->pool->packageById($packageId)."\n";
} else {
echo '    ?' . $this->pool->packageById($packageId)."\n";
}
}
echo "\n";
}

protected function printDecisionQueue()
{
echo "DecisionQueue: \n";
foreach ($this->decisionQueue as $i => $literal) {
echo '    ' . $this->pool->literalToString($literal) . ' ' . $this->decisionQueueWhy[$i]." level ".$this->decisionMap[abs($literal)]."\n";
}
echo "\n";
}

protected function printWatches()
{
echo "\nWatches:\n";
foreach ($this->watches as $literalId => $watch) {
echo '  '.$this->literalFromId($literalId)."\n";
$queue = array(array('    ', $watch));

while (!empty($queue)) {
list($indent, $watch) = array_pop($queue);

echo $indent.$watch;

if ($watch) {
echo ' [id='.$watch->getId().',watch1='.$this->literalFromId($watch->watch1).',watch2='.$this->literalFromId($watch->watch2)."]";
}

echo "\n";

if ($watch && ($watch->next1 == $watch || $watch->next2 == $watch)) {
if ($watch->next1 == $watch) {
echo $indent."    1 *RECURSION*";
}
if ($watch->next2 == $watch) {
echo $indent."    2 *RECURSION*";
}
} elseif ($watch && ($watch->next1 || $watch->next2)) {
$indent = str_replace(array('1', '2'), ' ', $indent);

array_push($queue, array($indent.'    2 ', $watch->next2));
array_push($queue, array($indent.'    1 ', $watch->next1));
}
}

echo "\n";
}
}
}
<?php











namespace Composer\DependencyResolver;






class Decisions implements \Iterator, \Countable
{
const DECISION_LITERAL = 0;
const DECISION_REASON = 1;

protected $pool;
protected $decisionMap;
protected $decisionQueue = array();

public function __construct($pool)
{
$this->pool = $pool;
$this->decisionMap = array();
}

public function decide($literal, $level, $why)
{
$this->addDecision($literal, $level);
$this->decisionQueue[] = array(
self::DECISION_LITERAL => $literal,
self::DECISION_REASON => $why,
);
}

public function satisfy($literal)
{
$packageId = abs($literal);

return (
$literal > 0 && isset($this->decisionMap[$packageId]) && $this->decisionMap[$packageId] > 0 ||
$literal < 0 && isset($this->decisionMap[$packageId]) && $this->decisionMap[$packageId] < 0
);
}

public function conflict($literal)
{
$packageId = abs($literal);

return (
(isset($this->decisionMap[$packageId]) && $this->decisionMap[$packageId] > 0 && $literal < 0) ||
(isset($this->decisionMap[$packageId]) && $this->decisionMap[$packageId] < 0 && $literal > 0)
);
}

public function decided($literalOrPackageId)
{
return !empty($this->decisionMap[abs($literalOrPackageId)]);
}

public function undecided($literalOrPackageId)
{
return empty($this->decisionMap[abs($literalOrPackageId)]);
}

public function decidedInstall($literalOrPackageId)
{
$packageId = abs($literalOrPackageId);

return isset($this->decisionMap[$packageId]) && $this->decisionMap[$packageId] > 0;
}

public function decisionLevel($literalOrPackageId)
{
$packageId = abs($literalOrPackageId);
if (isset($this->decisionMap[$packageId])) {
return abs($this->decisionMap[$packageId]);
}

return 0;
}

public function decisionRule($literalOrPackageId)
{
$packageId = abs($literalOrPackageId);

foreach ($this->decisionQueue as $i => $decision) {
if ($packageId === abs($decision[self::DECISION_LITERAL])) {
return $decision[self::DECISION_REASON];
}
}

return null;
}

public function atOffset($queueOffset)
{
return $this->decisionQueue[$queueOffset];
}

public function validOffset($queueOffset)
{
return $queueOffset >= 0 && $queueOffset < count($this->decisionQueue);
}

public function lastReason()
{
return $this->decisionQueue[count($this->decisionQueue) - 1][self::DECISION_REASON];
}

public function lastLiteral()
{
return $this->decisionQueue[count($this->decisionQueue) - 1][self::DECISION_LITERAL];
}

public function reset()
{
while ($decision = array_pop($this->decisionQueue)) {
$this->decisionMap[abs($decision[self::DECISION_LITERAL])] = 0;
}
}

public function resetToOffset($offset)
{
while (count($this->decisionQueue) > $offset + 1) {
$decision = array_pop($this->decisionQueue);
$this->decisionMap[abs($decision[self::DECISION_LITERAL])] = 0;
}
}

public function revertLast()
{
$this->decisionMap[abs($this->lastLiteral())] = 0;
array_pop($this->decisionQueue);
}

public function count()
{
return count($this->decisionQueue);
}

public function rewind()
{
end($this->decisionQueue);
}

public function current()
{
return current($this->decisionQueue);
}

public function key()
{
return key($this->decisionQueue);
}

public function next()
{
return prev($this->decisionQueue);
}

public function valid()
{
return false !== current($this->decisionQueue);
}

public function isEmpty()
{
return count($this->decisionQueue) === 0;
}

protected function addDecision($literal, $level)
{
$packageId = abs($literal);

$previousDecision = isset($this->decisionMap[$packageId]) ? $this->decisionMap[$packageId] : null;
if ($previousDecision != 0) {
$literalString = $this->pool->literalToString($literal);
$package = $this->pool->literalToPackage($literal);
throw new SolverBugException(
"Trying to decide $literalString on level $level, even though $package was previously decided as ".(int) $previousDecision."."
);
}

if ($literal > 0) {
$this->decisionMap[$packageId] = $level;
} else {
$this->decisionMap[$packageId] = -$level;
}
}
}
<?php











namespace Composer\DependencyResolver;

use Composer\Package\PackageInterface;
use Composer\Package\AliasPackage;
use Composer\Package\BasePackage;
use Composer\Package\LinkConstraint\VersionConstraint;





class DefaultPolicy implements PolicyInterface
{
private $preferStable;
private $preferLowest;

public function __construct($preferStable = false, $preferLowest = false)
{
$this->preferStable = $preferStable;
$this->preferLowest = $preferLowest;
}

public function versionCompare(PackageInterface $a, PackageInterface $b, $operator)
{
if ($this->preferStable && ($stabA = $a->getStability()) !== ($stabB = $b->getStability())) {
return BasePackage::$stabilities[$stabA] < BasePackage::$stabilities[$stabB];
}

$constraint = new VersionConstraint($operator, $b->getVersion());
$version = new VersionConstraint('==', $a->getVersion());

return $constraint->matchSpecific($version, true);
}

public function findUpdatePackages(Pool $pool, array $installedMap, PackageInterface $package, $mustMatchName = false)
{
$packages = array();

foreach ($pool->whatProvides($package->getName(), null, $mustMatchName) as $candidate) {
if ($candidate !== $package) {
$packages[] = $candidate;
}
}

return $packages;
}

public function getPriority(Pool $pool, PackageInterface $package)
{
return $pool->getPriority($package->getRepository());
}




public function selectPreferedPackages(Pool $pool, array $installedMap, array $literals, $requiredPackage = null)
{
return $this->selectPreferredPackages($pool, $installedMap, $literals, $requiredPackage);
}

public function selectPreferredPackages(Pool $pool, array $installedMap, array $literals, $requiredPackage = null)
{
$packages = $this->groupLiteralsByNamePreferInstalled($pool, $installedMap, $literals);

foreach ($packages as &$literals) {
$policy = $this;
usort($literals, function ($a, $b) use ($policy, $pool, $installedMap, $requiredPackage) {
return $policy->compareByPriorityPreferInstalled($pool, $installedMap, $pool->literalToPackage($a), $pool->literalToPackage($b), $requiredPackage, true);
});
}

foreach ($packages as &$literals) {
$literals = $this->pruneToHighestPriorityOrInstalled($pool, $installedMap, $literals);

$literals = $this->pruneToBestVersion($pool, $literals);

$literals = $this->pruneRemoteAliases($pool, $literals);
}

$selected = call_user_func_array('array_merge', $packages);


 usort($selected, function ($a, $b) use ($policy, $pool, $installedMap, $requiredPackage) {
return $policy->compareByPriorityPreferInstalled($pool, $installedMap, $pool->literalToPackage($a), $pool->literalToPackage($b), $requiredPackage);
});

return $selected;
}

protected function groupLiteralsByNamePreferInstalled(Pool $pool, array $installedMap, $literals)
{
$packages = array();
foreach ($literals as $literal) {
$packageName = $pool->literalToPackage($literal)->getName();

if (!isset($packages[$packageName])) {
$packages[$packageName] = array();
}

if (isset($installedMap[abs($literal)])) {
array_unshift($packages[$packageName], $literal);
} else {
$packages[$packageName][] = $literal;
}
}

return $packages;
}




public function compareByPriorityPreferInstalled(Pool $pool, array $installedMap, PackageInterface $a, PackageInterface $b, $requiredPackage = null, $ignoreReplace = false)
{
if ($a->getRepository() === $b->getRepository()) {

 if ($a->getName() === $b->getName()) {
$aAliased = $a instanceof AliasPackage;
$bAliased = $b instanceof AliasPackage;
if ($aAliased && !$bAliased) {
return -1; 
 }
if (!$aAliased && $bAliased) {
return 1; 
 }
}

if (!$ignoreReplace) {

 if ($this->replaces($a, $b)) {
return 1; 
 }
if ($this->replaces($b, $a)) {
return -1; 
 }


 
 if ($requiredPackage && false !== ($pos = strpos($requiredPackage, '/'))) {
$requiredVendor = substr($requiredPackage, 0, $pos);

$aIsSameVendor = substr($a->getName(), 0, $pos) === $requiredVendor;
$bIsSameVendor = substr($b->getName(), 0, $pos) === $requiredVendor;

if ($bIsSameVendor !== $aIsSameVendor) {
return $aIsSameVendor ? -1 : 1;
}
}
}


 if ($a->id === $b->id) {
return 0;
}

return ($a->id < $b->id) ? -1 : 1;
}

if (isset($installedMap[$a->id])) {
return -1;
}

if (isset($installedMap[$b->id])) {
return 1;
}

return ($this->getPriority($pool, $a) > $this->getPriority($pool, $b)) ? -1 : 1;
}











protected function replaces(PackageInterface $source, PackageInterface $target)
{
foreach ($source->getReplaces() as $link) {
if ($link->getTarget() === $target->getName()


 ) {
return true;
}
}

return false;
}

protected function pruneToBestVersion(Pool $pool, $literals)
{
$operator = $this->preferLowest ? '<' : '>';
$bestLiterals = array($literals[0]);
$bestPackage = $pool->literalToPackage($literals[0]);
foreach ($literals as $i => $literal) {
if (0 === $i) {
continue;
}

$package = $pool->literalToPackage($literal);

if ($this->versionCompare($package, $bestPackage, $operator)) {
$bestPackage = $package;
$bestLiterals = array($literal);
} elseif ($this->versionCompare($package, $bestPackage, '==')) {
$bestLiterals[] = $literal;
}
}

return $bestLiterals;
}




protected function pruneToHighestPriorityOrInstalled(Pool $pool, array $installedMap, array $literals)
{
$selected = array();

$priority = null;

foreach ($literals as $literal) {
$package = $pool->literalToPackage($literal);

if (isset($installedMap[$package->id])) {
$selected[] = $literal;
continue;
}

if (null === $priority) {
$priority = $this->getPriority($pool, $package);
}

if ($this->getPriority($pool, $package) != $priority) {
break;
}

$selected[] = $literal;
}

return $selected;
}






protected function pruneRemoteAliases(Pool $pool, array $literals)
{
$hasLocalAlias = false;

foreach ($literals as $literal) {
$package = $pool->literalToPackage($literal);

if ($package instanceof AliasPackage && $package->isRootPackageAlias()) {
$hasLocalAlias = true;
break;
}
}

if (!$hasLocalAlias) {
return $literals;
}

$selected = array();
foreach ($literals as $literal) {
$package = $pool->literalToPackage($literal);

if ($package instanceof AliasPackage && $package->isRootPackageAlias()) {
$selected[] = $literal;
}
}

return $selected;
}
}
<?php











namespace Composer\DependencyResolver\Operation;

use Composer\Package\PackageInterface;






class InstallOperation extends SolverOperation
{
protected $package;







public function __construct(PackageInterface $package, $reason = null)
{
parent::__construct($reason);

$this->package = $package;
}






public function getPackage()
{
return $this->package;
}






public function getJobType()
{
return 'install';
}




public function __toString()
{
return 'Installing '.$this->package->getPrettyName().' ('.$this->formatVersion($this->package).')';
}
}
<?php











namespace Composer\DependencyResolver\Operation;

use Composer\Package\AliasPackage;






class MarkAliasInstalledOperation extends SolverOperation
{
protected $package;







public function __construct(AliasPackage $package, $reason = null)
{
parent::__construct($reason);

$this->package = $package;
}






public function getPackage()
{
return $this->package;
}






public function getJobType()
{
return 'markAliasInstalled';
}




public function __toString()
{
return 'Marking '.$this->package->getPrettyName().' ('.$this->formatVersion($this->package).') as installed, alias of '.$this->package->getAliasOf()->getPrettyName().' ('.$this->formatVersion($this->package->getAliasOf()).')';
}
}
<?php











namespace Composer\DependencyResolver\Operation;

use Composer\Package\AliasPackage;






class MarkAliasUninstalledOperation extends SolverOperation
{
protected $package;







public function __construct(AliasPackage $package, $reason = null)
{
parent::__construct($reason);

$this->package = $package;
}






public function getPackage()
{
return $this->package;
}






public function getJobType()
{
return 'markAliasUninstalled';
}




public function __toString()
{
return 'Marking '.$this->package->getPrettyName().' ('.$this->formatVersion($this->package).') as uninstalled, alias of '.$this->package->getAliasOf()->getPrettyName().' ('.$this->formatVersion($this->package->getAliasOf()).')';
}
}
<?php











namespace Composer\DependencyResolver\Operation;






interface OperationInterface
{





public function getJobType();






public function getReason();






public function __toString();
}
<?php











namespace Composer\DependencyResolver\Operation;

use Composer\Package\Version\VersionParser;
use Composer\Package\PackageInterface;






abstract class SolverOperation implements OperationInterface
{
protected $reason;






public function __construct($reason = null)
{
$this->reason = $reason;
}






public function getReason()
{
return $this->reason;
}

protected function formatVersion(PackageInterface $package)
{
return VersionParser::formatVersion($package);
}
}
<?php











namespace Composer\DependencyResolver\Operation;

use Composer\Package\PackageInterface;






class UninstallOperation extends SolverOperation
{
protected $package;







public function __construct(PackageInterface $package, $reason = null)
{
parent::__construct($reason);

$this->package = $package;
}






public function getPackage()
{
return $this->package;
}






public function getJobType()
{
return 'uninstall';
}




public function __toString()
{
return 'Uninstalling '.$this->package->getPrettyName().' ('.$this->formatVersion($this->package).')';
}
}
<?php











namespace Composer\DependencyResolver\Operation;

use Composer\Package\PackageInterface;






class UpdateOperation extends SolverOperation
{
protected $initialPackage;
protected $targetPackage;








public function __construct(PackageInterface $initial, PackageInterface $target, $reason = null)
{
parent::__construct($reason);

$this->initialPackage = $initial;
$this->targetPackage = $target;
}






public function getInitialPackage()
{
return $this->initialPackage;
}






public function getTargetPackage()
{
return $this->targetPackage;
}






public function getJobType()
{
return 'update';
}




public function __toString()
{
return 'Updating '.$this->initialPackage->getPrettyName().' ('.$this->formatVersion($this->initialPackage).') to '.
$this->targetPackage->getPrettyName(). ' ('.$this->formatVersion($this->targetPackage).')';
}
}
<?php











namespace Composer\DependencyResolver;

use Composer\Package\PackageInterface;




interface PolicyInterface
{
public function versionCompare(PackageInterface $a, PackageInterface $b, $operator);
public function findUpdatePackages(Pool $pool, array $installedMap, PackageInterface $package);
public function selectPreferredPackages(Pool $pool, array $installedMap, array $literals);
}
<?php











namespace Composer\DependencyResolver;

use Composer\Package\BasePackage;
use Composer\Package\AliasPackage;
use Composer\Package\Version\VersionParser;
use Composer\Package\LinkConstraint\LinkConstraintInterface;
use Composer\Package\LinkConstraint\VersionConstraint;
use Composer\Package\LinkConstraint\EmptyConstraint;
use Composer\Repository\RepositoryInterface;
use Composer\Repository\CompositeRepository;
use Composer\Repository\ComposerRepository;
use Composer\Repository\InstalledRepositoryInterface;
use Composer\Repository\PlatformRepository;
use Composer\Package\PackageInterface;







class Pool
{
const MATCH_NAME = -1;
const MATCH_NONE = 0;
const MATCH = 1;
const MATCH_PROVIDE = 2;
const MATCH_REPLACE = 3;
const MATCH_FILTERED = 4;

protected $repositories = array();
protected $providerRepos = array();
protected $packages = array();
protected $packageByName = array();
protected $packageByExactName = array();
protected $acceptableStabilities;
protected $stabilityFlags;
protected $versionParser;
protected $providerCache = array();
protected $filterRequires;
protected $whitelist = null;
protected $id = 1;

public function __construct($minimumStability = 'stable', array $stabilityFlags = array(), array $filterRequires = array())
{
$this->versionParser = new VersionParser;
$this->acceptableStabilities = array();
foreach (BasePackage::$stabilities as $stability => $value) {
if ($value <= BasePackage::$stabilities[$minimumStability]) {
$this->acceptableStabilities[$stability] = $value;
}
}
$this->stabilityFlags = $stabilityFlags;
$this->filterRequires = $filterRequires;
foreach ($filterRequires as $name => $constraint) {
if (preg_match(PlatformRepository::PLATFORM_PACKAGE_REGEX, $name)) {
unset($this->filterRequires[$name]);
}
}
}

public function setWhitelist($whitelist)
{
$this->whitelist = $whitelist;
$this->providerCache = array();
}







public function addRepository(RepositoryInterface $repo, $rootAliases = array())
{
if ($repo instanceof CompositeRepository) {
$repos = $repo->getRepositories();
} else {
$repos = array($repo);
}

foreach ($repos as $repo) {
$this->repositories[] = $repo;

$exempt = $repo instanceof PlatformRepository || $repo instanceof InstalledRepositoryInterface;

if ($repo instanceof ComposerRepository && $repo->hasProviders()) {
$this->providerRepos[] = $repo;
$repo->setRootAliases($rootAliases);
$repo->resetPackageIds();
} else {
foreach ($repo->getPackages() as $package) {
$names = $package->getNames();
$stability = $package->getStability();
if ($exempt || $this->isPackageAcceptable($names, $stability)) {
$package->setId($this->id++);
$this->packages[] = $package;
$this->packageByExactName[$package->getName()][$package->id] = $package;

foreach ($names as $provided) {
$this->packageByName[$provided][] = $package;
}


 $name = $package->getName();
if (isset($rootAliases[$name][$package->getVersion()])) {
$alias = $rootAliases[$name][$package->getVersion()];
if ($package instanceof AliasPackage) {
$package = $package->getAliasOf();
}
$aliasPackage = new AliasPackage($package, $alias['alias_normalized'], $alias['alias']);
$aliasPackage->setRootPackageAlias(true);
$aliasPackage->setId($this->id++);

$package->getRepository()->addPackage($aliasPackage);
$this->packages[] = $aliasPackage;
$this->packageByExactName[$aliasPackage->getName()][$aliasPackage->id] = $aliasPackage;

foreach ($aliasPackage->getNames() as $name) {
$this->packageByName[$name][] = $aliasPackage;
}
}
}
}
}
}
}

public function getPriority(RepositoryInterface $repo)
{
$priority = array_search($repo, $this->repositories, true);

if (false === $priority) {
throw new \RuntimeException("Could not determine repository priority. The repository was not registered in the pool.");
}

return -$priority;
}







public function packageById($id)
{
return $this->packages[$id - 1];
}











public function whatProvides($name, LinkConstraintInterface $constraint = null, $mustMatchName = false)
{
$key = ((int) $mustMatchName).$constraint;
if (isset($this->providerCache[$name][$key])) {
return $this->providerCache[$name][$key];
}

return $this->providerCache[$name][$key] = $this->computeWhatProvides($name, $constraint, $mustMatchName);
}




private function computeWhatProvides($name, $constraint, $mustMatchName = false)
{
$candidates = array();

foreach ($this->providerRepos as $repo) {
foreach ($repo->whatProvides($this, $name) as $candidate) {
$candidates[] = $candidate;
if ($candidate->id < 1) {
$candidate->setId($this->id++);
$this->packages[$this->id - 2] = $candidate;
}
}
}

if ($mustMatchName) {
$candidates = array_filter($candidates, function ($candidate) use ($name) {
return $candidate->getName() == $name;
});
if (isset($this->packageByExactName[$name])) {
$candidates = array_merge($candidates, $this->packageByExactName[$name]);
}
} elseif (isset($this->packageByName[$name])) {
$candidates = array_merge($candidates, $this->packageByName[$name]);
}

$matches = $provideMatches = array();
$nameMatch = false;

foreach ($candidates as $candidate) {
$aliasOfCandidate = null;


 
 if ($candidate instanceof AliasPackage) {
$aliasOfCandidate = $candidate->getAliasOf();
}

if ($this->whitelist !== null && (
(!($candidate instanceof AliasPackage) && !isset($this->whitelist[$candidate->id])) ||
($candidate instanceof AliasPackage && !isset($this->whitelist[$aliasOfCandidate->id]))
)) {
continue;
}
switch ($this->match($candidate, $name, $constraint)) {
case self::MATCH_NONE:
break;

case self::MATCH_NAME:
$nameMatch = true;
break;

case self::MATCH:
$nameMatch = true;
$matches[] = $candidate;
break;

case self::MATCH_PROVIDE:
$provideMatches[] = $candidate;
break;

case self::MATCH_REPLACE:
$matches[] = $candidate;
break;

case self::MATCH_FILTERED:
break;

default:
throw new \UnexpectedValueException('Unexpected match type');
}
}


 if ($nameMatch) {
return $matches;
}

return array_merge($matches, $provideMatches);
}

public function literalToPackage($literal)
{
$packageId = abs($literal);

return $this->packageById($packageId);
}

public function literalToString($literal)
{
return ($literal > 0 ? '+' : '-') . $this->literalToPackage($literal);
}

public function literalToPrettyString($literal, $installedMap)
{
$package = $this->literalToPackage($literal);

if (isset($installedMap[$package->id])) {
$prefix = ($literal > 0 ? 'keep' : 'remove');
} else {
$prefix = ($literal > 0 ? 'install' : 'don\'t install');
}

return $prefix.' '.$package->getPrettyString();
}

public function isPackageAcceptable($name, $stability)
{
foreach ((array) $name as $n) {

 if (!isset($this->stabilityFlags[$n]) && isset($this->acceptableStabilities[$stability])) {
return true;
}


 if (isset($this->stabilityFlags[$n]) && BasePackage::$stabilities[$stability] <= $this->stabilityFlags[$n]) {
return true;
}
}

return false;
}










private function match($candidate, $name, LinkConstraintInterface $constraint = null)
{
$candidateName = $candidate->getName();
$candidateVersion = $candidate->getVersion();
$isDev = $candidate->getStability() === 'dev';
$isAlias = $candidate instanceof AliasPackage;

if (!$isDev && !$isAlias && isset($this->filterRequires[$name])) {
$requireFilter = $this->filterRequires[$name];
} else {
$requireFilter = new EmptyConstraint;
}

if ($candidateName === $name) {
$pkgConstraint = new VersionConstraint('==', $candidateVersion);

if ($constraint === null || $constraint->matches($pkgConstraint)) {
return $requireFilter->matches($pkgConstraint) ? self::MATCH : self::MATCH_FILTERED;
}

return self::MATCH_NAME;
}

$provides = $candidate->getProvides();
$replaces = $candidate->getReplaces();


 if (isset($replaces[0]) || isset($provides[0])) {
foreach ($provides as $link) {
if ($link->getTarget() === $name && ($constraint === null || $constraint->matches($link->getConstraint()))) {
return $requireFilter->matches($link->getConstraint()) ? self::MATCH_PROVIDE : self::MATCH_FILTERED;
}
}

foreach ($replaces as $link) {
if ($link->getTarget() === $name && ($constraint === null || $constraint->matches($link->getConstraint()))) {
return $requireFilter->matches($link->getConstraint()) ? self::MATCH_REPLACE : self::MATCH_FILTERED;
}
}

return self::MATCH_NONE;
}

if (isset($provides[$name]) && ($constraint === null || $constraint->matches($provides[$name]->getConstraint()))) {
return $requireFilter->matches($provides[$name]->getConstraint()) ? self::MATCH_PROVIDE : self::MATCH_FILTERED;
}

if (isset($replaces[$name]) && ($constraint === null || $constraint->matches($replaces[$name]->getConstraint()))) {
return $requireFilter->matches($replaces[$name]->getConstraint()) ? self::MATCH_REPLACE : self::MATCH_FILTERED;
}

return self::MATCH_NONE;
}
}
<?php











namespace Composer\DependencyResolver;






class Problem
{




protected $reasonSeen;





protected $reasons = array();

protected $section = 0;

protected $pool;

public function __construct(Pool $pool)
{
$this->pool = $pool;
}






public function addRule(Rule $rule)
{
$this->addReason($rule->getId(), array(
'rule' => $rule,
'job' => $rule->getJob(),
));
}






public function getReasons()
{
return $this->reasons;
}







public function getPrettyString(array $installedMap = array())
{
$reasons = call_user_func_array('array_merge', array_reverse($this->reasons));

if (count($reasons) === 1) {
reset($reasons);
$reason = current($reasons);

$rule = $reason['rule'];
$job = $reason['job'];

if (isset($job['constraint'])) {
$packages = $this->pool->whatProvides($job['packageName'], $job['constraint']);
} else {
$packages = array();
}

if ($job && $job['cmd'] === 'install' && empty($packages)) {

 if ($job['packageName'] === 'php' || $job['packageName'] === 'php-64bit' || $job['packageName'] === 'hhvm') {
$msg = "\n    - This package requires ".$job['packageName'].$this->constraintToText($job['constraint']).' but ';

if (defined('HHVM_VERSION')) {
return $msg . 'your HHVM version does not satisfy that requirement.';
} elseif ($job['packageName'] === 'hhvm') {
return $msg . 'you are running this with PHP and not HHVM.';
}

return $msg . 'your PHP version ('. phpversion().') does not satisfy that requirement.';
}


 if (0 === stripos($job['packageName'], 'ext-')) {
$ext = substr($job['packageName'], 4);
$error = extension_loaded($ext) ? 'has the wrong version ('.(phpversion($ext) ?: '0').') installed' : 'is missing from your system';

return "\n    - The requested PHP extension ".$job['packageName'].$this->constraintToText($job['constraint']).' '.$error.'.';
}


 if (0 === stripos($job['packageName'], 'lib-')) {
if (strtolower($job['packageName']) === 'lib-icu') {
$error = extension_loaded('intl') ? 'has the wrong version installed, try upgrading the intl extension.' : 'is missing from your system, make sure the intl extension is loaded.';

return "\n    - The requested linked library ".$job['packageName'].$this->constraintToText($job['constraint']).' '.$error;
}

return "\n    - The requested linked library ".$job['packageName'].$this->constraintToText($job['constraint']).' has the wrong version installed or is missing from your system, make sure to load the extension providing it.';
}

if (!preg_match('{^[A-Za-z0-9_./-]+$}', $job['packageName'])) {
$illegalChars = preg_replace('{[A-Za-z0-9_./-]+}', '', $job['packageName']);

return "\n    - The requested package ".$job['packageName'].' could not be found, it looks like its name is invalid, "'.$illegalChars.'" is not allowed in package names.';
}

if (!$this->pool->whatProvides($job['packageName'])) {
return "\n    - The requested package ".$job['packageName'].' could not be found in any version, there may be a typo in the package name.';
}

return "\n    - The requested package ".$job['packageName'].$this->constraintToText($job['constraint']).' could not be found.';
}
}

$messages = array();

foreach ($reasons as $reason) {
$rule = $reason['rule'];
$job = $reason['job'];

if ($job) {
$messages[] = $this->jobToText($job);
} elseif ($rule) {
if ($rule instanceof Rule) {
$messages[] = $rule->getPrettyString($this->pool, $installedMap);
}
}
}

return "\n    - ".implode("\n    - ", $messages);
}







protected function addReason($id, $reason)
{
if (!isset($this->reasonSeen[$id])) {
$this->reasonSeen[$id] = true;
$this->reasons[$this->section][] = $reason;
}
}

public function nextSection()
{
$this->section++;
}







protected function jobToText($job)
{
switch ($job['cmd']) {
case 'install':
$packages = $this->pool->whatProvides($job['packageName'], $job['constraint']);
if (!$packages) {
return 'No package found to satisfy install request for '.$job['packageName'].$this->constraintToText($job['constraint']);
}

return 'Installation request for '.$job['packageName'].$this->constraintToText($job['constraint']).' -> satisfiable by '.$this->getPackageList($packages).'.';
case 'update':
return 'Update request for '.$job['packageName'].$this->constraintToText($job['constraint']).'.';
case 'remove':
return 'Removal request for '.$job['packageName'].$this->constraintToText($job['constraint']).'';
}

if (isset($job['constraint'])) {
$packages = $this->pool->whatProvides($job['packageName'], $job['constraint']);
} else {
$packages = array();
}

return 'Job(cmd='.$job['cmd'].', target='.$job['packageName'].', packages=['.$this->getPackageList($packages).'])';
}

protected function getPackageList($packages)
{
$prepared = array();
foreach ($packages as $package) {
$prepared[$package->getName()]['name'] = $package->getPrettyName();
$prepared[$package->getName()]['versions'][$package->getVersion()] = $package->getPrettyVersion();
}
foreach ($prepared as $name => $package) {
$prepared[$name] = $package['name'].'['.implode(', ', $package['versions']).']';
}

return implode(', ', $prepared);
}







protected function constraintToText($constraint)
{
return ($constraint) ? ' '.$constraint->getPrettyString() : '';
}
}
<?php











namespace Composer\DependencyResolver;

use Composer\Package\LinkConstraint\LinkConstraintInterface;




class Request
{
protected $jobs;

public function __construct()
{
$this->jobs = array();
}

public function install($packageName, LinkConstraintInterface $constraint = null)
{
$this->addJob($packageName, 'install', $constraint);
}

public function update($packageName, LinkConstraintInterface $constraint = null)
{
$this->addJob($packageName, 'update', $constraint);
}

public function remove($packageName, LinkConstraintInterface $constraint = null)
{
$this->addJob($packageName, 'remove', $constraint);
}






public function fix($packageName, LinkConstraintInterface $constraint = null)
{
$this->addJob($packageName, 'install', $constraint, true);
}

protected function addJob($packageName, $cmd, LinkConstraintInterface $constraint = null, $fixed = false)
{
$packageName = strtolower($packageName);

$this->jobs[] = array(
'cmd' => $cmd,
'packageName' => $packageName,
'constraint' => $constraint,
'fixed' => $fixed
);
}

public function updateAll()
{
$this->jobs[] = array('cmd' => 'update-all');
}

public function getJobs()
{
return $this->jobs;
}
}
<?php











namespace Composer\DependencyResolver;




class Rule
{
const RULE_INTERNAL_ALLOW_UPDATE = 1;
const RULE_JOB_INSTALL = 2;
const RULE_JOB_REMOVE = 3;
const RULE_PACKAGE_CONFLICT = 6;
const RULE_PACKAGE_REQUIRES = 7;
const RULE_PACKAGE_OBSOLETES = 8;
const RULE_INSTALLED_PACKAGE_OBSOLETES = 9;
const RULE_PACKAGE_SAME_NAME = 10;
const RULE_PACKAGE_IMPLICIT_OBSOLETES = 11;
const RULE_LEARNED = 12;
const RULE_PACKAGE_ALIAS = 13;





public $literals;

protected $disabled;
protected $type;
protected $id;
protected $reason;
protected $reasonData;

protected $job;

protected $ruleHash;

public function __construct(array $literals, $reason, $reasonData, $job = null)
{

 sort($literals);

$this->literals = $literals;
$this->reason = $reason;
$this->reasonData = $reasonData;

$this->disabled = false;

$this->job = $job;

$this->type = -1;

$this->ruleHash = substr(md5(implode(',', $this->literals)), 0, 5);
}

public function getHash()
{
return $this->ruleHash;
}

public function setId($id)
{
$this->id = $id;
}

public function getId()
{
return $this->id;
}

public function getJob()
{
return $this->job;
}

public function getReason()
{
return $this->reason;
}

public function getReasonData()
{
return $this->reasonData;
}

public function getRequiredPackage()
{
if ($this->reason === self::RULE_JOB_INSTALL) {
return $this->reasonData;
}

if ($this->reason === self::RULE_PACKAGE_REQUIRES) {
return $this->reasonData->getTarget();
}
}









public function equals(Rule $rule)
{
if ($this->ruleHash !== $rule->ruleHash) {
return false;
}

if (count($this->literals) != count($rule->literals)) {
return false;
}

for ($i = 0, $n = count($this->literals); $i < $n; $i++) {
if ($this->literals[$i] !== $rule->literals[$i]) {
return false;
}
}

return true;
}

public function setType($type)
{
$this->type = $type;
}

public function getType()
{
return $this->type;
}

public function disable()
{
$this->disabled = true;
}

public function enable()
{
$this->disabled = false;
}

public function isDisabled()
{
return $this->disabled;
}

public function isEnabled()
{
return !$this->disabled;
}




public function getLiterals()
{
return $this->literals;
}

public function isAssertion()
{
return 1 === count($this->literals);
}

public function getPrettyString(Pool $pool, array $installedMap = array())
{
$ruleText = '';
foreach ($this->literals as $i => $literal) {
if ($i != 0) {
$ruleText .= '|';
}
$ruleText .= $pool->literalToPrettyString($literal, $installedMap);
}

switch ($this->reason) {
case self::RULE_INTERNAL_ALLOW_UPDATE:
return $ruleText;

case self::RULE_JOB_INSTALL:
return "Install command rule ($ruleText)";

case self::RULE_JOB_REMOVE:
return "Remove command rule ($ruleText)";

case self::RULE_PACKAGE_CONFLICT:
$package1 = $pool->literalToPackage($this->literals[0]);
$package2 = $pool->literalToPackage($this->literals[1]);

return $package1->getPrettyString().' conflicts with '.$this->formatPackagesUnique($pool, array($package2)).'.';

case self::RULE_PACKAGE_REQUIRES:
$literals = $this->literals;
$sourceLiteral = array_shift($literals);
$sourcePackage = $pool->literalToPackage($sourceLiteral);

$requires = array();
foreach ($literals as $literal) {
$requires[] = $pool->literalToPackage($literal);
}

$text = $this->reasonData->getPrettyString($sourcePackage);
if ($requires) {
$text .= ' -> satisfiable by ' . $this->formatPackagesUnique($pool, $requires) . '.';
} else {
$targetName = $this->reasonData->getTarget();


 if ($targetName === 'php' || $targetName === 'php-64bit' || $targetName === 'hhvm') {
if (defined('HHVM_VERSION')) {
$text .= ' -> your HHVM version does not satisfy that requirement.';
} elseif ($targetName === 'hhvm') {
$text .= ' -> you are running this with PHP and not HHVM.';
} else {
$text .= ' -> your PHP version ('. phpversion().') does not satisfy that requirement.';
}
} elseif (0 === strpos($targetName, 'ext-')) {
$ext = substr($targetName, 4);
$error = extension_loaded($ext) ? 'has the wrong version ('.(phpversion($ext) ?: '0').') installed' : 'is missing from your system';

$text .= ' -> the requested PHP extension '.$ext.' '.$error.'.';
} elseif (0 === strpos($targetName, 'lib-')) {

 $lib = substr($targetName, 4);

$text .= ' -> the requested linked library '.$lib.' has the wrong version installed or is missing from your system, make sure to have the extension providing it.';
} else {
$text .= ' -> no matching package found.';
}
}

return $text;

case self::RULE_PACKAGE_OBSOLETES:
return $ruleText;
case self::RULE_INSTALLED_PACKAGE_OBSOLETES:
return $ruleText;
case self::RULE_PACKAGE_SAME_NAME:
return 'Can only install one of: ' . $this->formatPackagesUnique($pool, $this->literals) . '.';
case self::RULE_PACKAGE_IMPLICIT_OBSOLETES:
return $ruleText;
case self::RULE_LEARNED:
return 'Conclusion: '.$ruleText;
case self::RULE_PACKAGE_ALIAS:
return $ruleText;
default:
return '('.$ruleText.')';
}
}

protected function formatPackagesUnique($pool, array $packages)
{
$prepared = array();
foreach ($packages as $package) {
if (!is_object($package)) {
$package = $pool->literalToPackage($package);
}
$prepared[$package->getName()]['name'] = $package->getPrettyName();
$prepared[$package->getName()]['versions'][$package->getVersion()] = $package->getPrettyVersion();
}
foreach ($prepared as $name => $package) {
$prepared[$name] = $package['name'].'['.implode(', ', $package['versions']).']';
}

return implode(', ', $prepared);
}






public function __toString()
{
$result = ($this->isDisabled()) ? 'disabled(' : '(';

foreach ($this->literals as $i => $literal) {
if ($i != 0) {
$result .= '|';
}
$result .= $literal;
}

$result .= ')';

return $result;
}
}
<?php











namespace Composer\DependencyResolver;




class RuleSet implements \IteratorAggregate, \Countable
{

 const TYPE_PACKAGE = 0;
const TYPE_JOB = 1;
const TYPE_LEARNED = 4;






public $ruleById;

protected static $types = array(
-1 => 'UNKNOWN',
self::TYPE_PACKAGE => 'PACKAGE',
self::TYPE_JOB => 'JOB',
self::TYPE_LEARNED => 'LEARNED',
);

protected $rules;
protected $nextRuleId;

protected $rulesByHash;

public function __construct()
{
$this->nextRuleId = 0;

foreach ($this->getTypes() as $type) {
$this->rules[$type] = array();
}

$this->rulesByHash = array();
}

public function add(Rule $rule, $type)
{
if (!isset(self::$types[$type])) {
throw new \OutOfBoundsException('Unknown rule type: ' . $type);
}

if (!isset($this->rules[$type])) {
$this->rules[$type] = array();
}

$this->rules[$type][] = $rule;
$this->ruleById[$this->nextRuleId] = $rule;
$rule->setType($type);

$rule->setId($this->nextRuleId);
$this->nextRuleId++;

$hash = $rule->getHash();
if (!isset($this->rulesByHash[$hash])) {
$this->rulesByHash[$hash] = array($rule);
} else {
$this->rulesByHash[$hash][] = $rule;
}
}

public function count()
{
return $this->nextRuleId;
}

public function ruleById($id)
{
return $this->ruleById[$id];
}

public function getRules()
{
return $this->rules;
}

public function getIterator()
{
return new RuleSetIterator($this->getRules());
}

public function getIteratorFor($types)
{
if (!is_array($types)) {
$types = array($types);
}

$allRules = $this->getRules();
$rules = array();

foreach ($types as $type) {
$rules[$type] = $allRules[$type];
}

return new RuleSetIterator($rules);
}

public function getIteratorWithout($types)
{
if (!is_array($types)) {
$types = array($types);
}

$rules = $this->getRules();

foreach ($types as $type) {
unset($rules[$type]);
}

return new RuleSetIterator($rules);
}

public function getTypes()
{
$types = self::$types;
unset($types[-1]);

return array_keys($types);
}

public function containsEqual($rule)
{
if (isset($this->rulesByHash[$rule->getHash()])) {
$potentialDuplicates = $this->rulesByHash[$rule->getHash()];
foreach ($potentialDuplicates as $potentialDuplicate) {
if ($rule->equals($potentialDuplicate)) {
return true;
}
}
}

return false;
}

public function getPrettyString(Pool $pool = null)
{
$string = "\n";
foreach ($this->rules as $type => $rules) {
$string .= str_pad(self::$types[$type], 8, ' ') . ": ";
foreach ($rules as $rule) {
$string .= ($pool ? $rule->getPrettyString($pool) : $rule)."\n";
}
$string .= "\n\n";
}

return $string;
}

public function __toString()
{
return $this->getPrettyString(null);
}
}
<?php











namespace Composer\DependencyResolver;

use Composer\Package\PackageInterface;
use Composer\Package\AliasPackage;
use Composer\Repository\PlatformRepository;




class RuleSetGenerator
{
protected $policy;
protected $pool;
protected $rules;
protected $jobs;
protected $installedMap;
protected $whitelistedMap;
protected $addedMap;

public function __construct(PolicyInterface $policy, Pool $pool)
{
$this->policy = $policy;
$this->pool = $pool;
}















protected function createRequireRule(PackageInterface $package, array $providers, $reason, $reasonData = null)
{
$literals = array(-$package->id);

foreach ($providers as $provider) {

 if ($provider === $package) {
return null;
}
$literals[] = $provider->id;
}

return new Rule($literals, $reason, $reasonData);
}













protected function createInstallOneOfRule(array $packages, $reason, $job)
{
$literals = array();
foreach ($packages as $package) {
$literals[] = $package->id;
}

return new Rule($literals, $reason, $job['packageName'], $job);
}












protected function createRemoveRule(PackageInterface $package, $reason, $job)
{
return new Rule(array(-$package->id), $reason, $job['packageName'], $job);
}















protected function createConflictRule(PackageInterface $issuer, PackageInterface $provider, $reason, $reasonData = null)
{

 if ($issuer === $provider) {
return null;
}

return new Rule(array(-$issuer->id, -$provider->id), $reason, $reasonData);
}










private function addRule($type, Rule $newRule = null)
{
if (!$newRule || $this->rules->containsEqual($newRule)) {
return;
}

$this->rules->add($newRule, $type);
}

protected function whitelistFromPackage(PackageInterface $package)
{
$workQueue = new \SplQueue;
$workQueue->enqueue($package);

while (!$workQueue->isEmpty()) {
$package = $workQueue->dequeue();
if (isset($this->whitelistedMap[$package->id])) {
continue;
}

$this->whitelistedMap[$package->id] = true;

foreach ($package->getRequires() as $link) {
$possibleRequires = $this->pool->whatProvides($link->getTarget(), $link->getConstraint(), true);

foreach ($possibleRequires as $require) {
$workQueue->enqueue($require);
}
}

$obsoleteProviders = $this->pool->whatProvides($package->getName(), null, true);

foreach ($obsoleteProviders as $provider) {
if ($provider === $package) {
continue;
}

if (($package instanceof AliasPackage) && $package->getAliasOf() === $provider) {
$workQueue->enqueue($provider);
}
}
}
}

protected function addRulesForPackage(PackageInterface $package, $ignorePlatformReqs)
{
$workQueue = new \SplQueue;
$workQueue->enqueue($package);

while (!$workQueue->isEmpty()) {
$package = $workQueue->dequeue();
if (isset($this->addedMap[$package->id])) {
continue;
}

$this->addedMap[$package->id] = true;

foreach ($package->getRequires() as $link) {
if ($ignorePlatformReqs && preg_match(PlatformRepository::PLATFORM_PACKAGE_REGEX, $link->getTarget())) {
continue;
}

$possibleRequires = $this->pool->whatProvides($link->getTarget(), $link->getConstraint());

$this->addRule(RuleSet::TYPE_PACKAGE, $rule = $this->createRequireRule($package, $possibleRequires, Rule::RULE_PACKAGE_REQUIRES, $link));

foreach ($possibleRequires as $require) {
$workQueue->enqueue($require);
}
}

foreach ($package->getConflicts() as $link) {
$possibleConflicts = $this->pool->whatProvides($link->getTarget(), $link->getConstraint());

foreach ($possibleConflicts as $conflict) {
$this->addRule(RuleSet::TYPE_PACKAGE, $this->createConflictRule($package, $conflict, Rule::RULE_PACKAGE_CONFLICT, $link));
}
}


 $isInstalled = (isset($this->installedMap[$package->id]));

foreach ($package->getReplaces() as $link) {
$obsoleteProviders = $this->pool->whatProvides($link->getTarget(), $link->getConstraint());

foreach ($obsoleteProviders as $provider) {
if ($provider === $package) {
continue;
}

if (!$this->obsoleteImpossibleForAlias($package, $provider)) {
$reason = ($isInstalled) ? Rule::RULE_INSTALLED_PACKAGE_OBSOLETES : Rule::RULE_PACKAGE_OBSOLETES;
$this->addRule(RuleSet::TYPE_PACKAGE, $this->createConflictRule($package, $provider, $reason, $link));
}
}
}

$obsoleteProviders = $this->pool->whatProvides($package->getName(), null);

foreach ($obsoleteProviders as $provider) {
if ($provider === $package) {
continue;
}

if (($package instanceof AliasPackage) && $package->getAliasOf() === $provider) {
$this->addRule(RuleSet::TYPE_PACKAGE, $rule = $this->createRequireRule($package, array($provider), Rule::RULE_PACKAGE_ALIAS, $package));
} elseif (!$this->obsoleteImpossibleForAlias($package, $provider)) {
$reason = ($package->getName() == $provider->getName()) ? Rule::RULE_PACKAGE_SAME_NAME : Rule::RULE_PACKAGE_IMPLICIT_OBSOLETES;
$this->addRule(RuleSet::TYPE_PACKAGE, $rule = $this->createConflictRule($package, $provider, $reason, $package));
}
}
}
}

protected function obsoleteImpossibleForAlias($package, $provider)
{
$packageIsAlias = $package instanceof AliasPackage;
$providerIsAlias = $provider instanceof AliasPackage;

$impossible = (
($packageIsAlias && $package->getAliasOf() === $provider) ||
($providerIsAlias && $provider->getAliasOf() === $package) ||
($packageIsAlias && $providerIsAlias && $provider->getAliasOf() === $package->getAliasOf())
);

return $impossible;
}

protected function whitelistFromJobs()
{
foreach ($this->jobs as $job) {
switch ($job['cmd']) {
case 'install':
$packages = $this->pool->whatProvides($job['packageName'], $job['constraint'], true);
foreach ($packages as $package) {
$this->whitelistFromPackage($package);
}
break;
}
}
}

protected function addRulesForJobs($ignorePlatformReqs)
{
foreach ($this->jobs as $job) {
switch ($job['cmd']) {
case 'install':
if (!$job['fixed'] && $ignorePlatformReqs && preg_match(PlatformRepository::PLATFORM_PACKAGE_REGEX, $job['packageName'])) {
continue;
}

$packages = $this->pool->whatProvides($job['packageName'], $job['constraint']);
if ($packages) {
foreach ($packages as $package) {
if (!isset($this->installedMap[$package->id])) {
$this->addRulesForPackage($package, $ignorePlatformReqs);
}
}

$rule = $this->createInstallOneOfRule($packages, Rule::RULE_JOB_INSTALL, $job);
$this->addRule(RuleSet::TYPE_JOB, $rule);
}
break;
case 'remove':

 
 $packages = $this->pool->whatProvides($job['packageName'], $job['constraint']);
foreach ($packages as $package) {
$rule = $this->createRemoveRule($package, Rule::RULE_JOB_REMOVE, $job);
$this->addRule(RuleSet::TYPE_JOB, $rule);
}
break;
}
}
}

public function getRulesFor($jobs, $installedMap, $ignorePlatformReqs = false)
{
$this->jobs = $jobs;
$this->rules = new RuleSet;
$this->installedMap = $installedMap;

$this->whitelistedMap = array();
foreach ($this->installedMap as $package) {
$this->whitelistFromPackage($package);
}
$this->whitelistFromJobs();

$this->pool->setWhitelist($this->whitelistedMap);

$this->addedMap = array();
foreach ($this->installedMap as $package) {
$this->addRulesForPackage($package, $ignorePlatformReqs);
}

$this->addRulesForJobs($ignorePlatformReqs);

return $this->rules;
}
}
<?php











namespace Composer\DependencyResolver;




class RuleSetIterator implements \Iterator
{
protected $rules;
protected $types;

protected $currentOffset;
protected $currentType;
protected $currentTypeOffset;

public function __construct(array $rules)
{
$this->rules = $rules;
$this->types = array_keys($rules);
sort($this->types);

$this->rewind();
}

public function current()
{
return $this->rules[$this->currentType][$this->currentOffset];
}

public function key()
{
return $this->currentType;
}

public function next()
{
$this->currentOffset++;

if (!isset($this->rules[$this->currentType])) {
return;
}

if ($this->currentOffset >= sizeof($this->rules[$this->currentType])) {
$this->currentOffset = 0;

do {
$this->currentTypeOffset++;

if (!isset($this->types[$this->currentTypeOffset])) {
$this->currentType = -1;
break;
}

$this->currentType = $this->types[$this->currentTypeOffset];
} while (isset($this->types[$this->currentTypeOffset]) && !sizeof($this->rules[$this->currentType]));
}
}

public function rewind()
{
$this->currentOffset = 0;

$this->currentTypeOffset = -1;
$this->currentType = -1;

do {
$this->currentTypeOffset++;

if (!isset($this->types[$this->currentTypeOffset])) {
$this->currentType = -1;
break;
}

$this->currentType = $this->types[$this->currentTypeOffset];
} while (isset($this->types[$this->currentTypeOffset]) && !sizeof($this->rules[$this->currentType]));
}

public function valid()
{
return isset($this->rules[$this->currentType])
&& isset($this->rules[$this->currentType][$this->currentOffset]);
}
}
<?php











namespace Composer\DependencyResolver;









class RuleWatchChain extends \SplDoublyLinkedList
{
protected $offset = 0;






public function seek($offset)
{
$this->rewind();
for ($i = 0; $i < $offset; $i++, $this->next());
}









public function remove()
{
$offset = $this->key();
$this->offsetUnset($offset);
$this->seek($offset);
}
}
<?php











namespace Composer\DependencyResolver;











class RuleWatchGraph
{
protected $watchChains = array();













public function insert(RuleWatchNode $node)
{
if ($node->getRule()->isAssertion()) {
return;
}

foreach (array($node->watch1, $node->watch2) as $literal) {
if (!isset($this->watchChains[$literal])) {
$this->watchChains[$literal] = new RuleWatchChain;
}

$this->watchChains[$literal]->unshift($node);
}
}
























public function propagateLiteral($decidedLiteral, $level, $decisions)
{

 
 
 $literal = -$decidedLiteral;

if (!isset($this->watchChains[$literal])) {
return null;
}

$chain = $this->watchChains[$literal];

$chain->rewind();
while ($chain->valid()) {
$node = $chain->current();
$otherWatch = $node->getOtherWatch($literal);

if (!$node->getRule()->isDisabled() && !$decisions->satisfy($otherWatch)) {
$ruleLiterals = $node->getRule()->literals;

$alternativeLiterals = array_filter($ruleLiterals, function ($ruleLiteral) use ($literal, $otherWatch, $decisions) {
return $literal !== $ruleLiteral &&
$otherWatch !== $ruleLiteral &&
!$decisions->conflict($ruleLiteral);
});

if ($alternativeLiterals) {
reset($alternativeLiterals);
$this->moveWatch($literal, current($alternativeLiterals), $node);
continue;
}

if ($decisions->conflict($otherWatch)) {
return $node->getRule();
}

$decisions->decide($otherWatch, $level, $node->getRule());
}

$chain->next();
}

return null;
}










protected function moveWatch($fromLiteral, $toLiteral, $node)
{
if (!isset($this->watchChains[$toLiteral])) {
$this->watchChains[$toLiteral] = new RuleWatchChain;
}

$node->moveWatch($fromLiteral, $toLiteral);
$this->watchChains[$fromLiteral]->remove();
$this->watchChains[$toLiteral]->unshift($node);
}
}
<?php











namespace Composer\DependencyResolver;








class RuleWatchNode
{
public $watch1;
public $watch2;

protected $rule;






public function __construct($rule)
{
$this->rule = $rule;

$literals = $rule->literals;

$this->watch1 = count($literals) > 0 ? $literals[0] : 0;
$this->watch2 = count($literals) > 1 ? $literals[1] : 0;
}









public function watch2OnHighest(Decisions $decisions)
{
$literals = $this->rule->literals;


 if (count($literals) < 3) {
return;
}

$watchLevel = 0;

foreach ($literals as $literal) {
$level = $decisions->decisionLevel($literal);

if ($level > $watchLevel) {
$this->watch2 = $literal;
$watchLevel = $level;
}
}
}






public function getRule()
{
return $this->rule;
}







public function getOtherWatch($literal)
{
if ($this->watch1 == $literal) {
return $this->watch2;
} else {
return $this->watch1;
}
}







public function moveWatch($from, $to)
{
if ($this->watch1 == $from) {
$this->watch1 = $to;
} else {
$this->watch2 = $to;
}
}
}
<?php











namespace Composer\DependencyResolver;

use Composer\Repository\RepositoryInterface;
use Composer\Repository\PlatformRepository;




class Solver
{
const BRANCH_LITERALS = 0;
const BRANCH_LEVEL = 1;

protected $policy;
protected $pool;
protected $installed;
protected $rules;
protected $ruleSetGenerator;
protected $updateAll;

protected $addedMap = array();
protected $updateMap = array();
protected $watchGraph;
protected $decisions;
protected $installedMap;

protected $propagateIndex;
protected $branches = array();
protected $problems = array();
protected $learnedPool = array();
protected $learnedWhy = array();

public function __construct(PolicyInterface $policy, Pool $pool, RepositoryInterface $installed)
{
$this->policy = $policy;
$this->pool = $pool;
$this->installed = $installed;
$this->ruleSetGenerator = new RuleSetGenerator($policy, $pool);
}


 private function makeAssertionRuleDecisions()
{
$decisionStart = count($this->decisions) - 1;

$rulesCount = count($this->rules);
for ($ruleIndex = 0; $ruleIndex < $rulesCount; $ruleIndex++) {
$rule = $this->rules->ruleById[$ruleIndex];

if (!$rule->isAssertion() || $rule->isDisabled()) {
continue;
}

$literals = $rule->literals;
$literal = $literals[0];

if (!$this->decisions->decided(abs($literal))) {
$this->decisions->decide($literal, 1, $rule);
continue;
}

if ($this->decisions->satisfy($literal)) {
continue;
}


 if (RuleSet::TYPE_LEARNED === $rule->getType()) {
$rule->disable();
continue;
}

$conflict = $this->decisions->decisionRule($literal);

if ($conflict && RuleSet::TYPE_PACKAGE === $conflict->getType()) {
$problem = new Problem($this->pool);

$problem->addRule($rule);
$problem->addRule($conflict);
$this->disableProblem($rule);
$this->problems[] = $problem;
continue;
}


 $problem = new Problem($this->pool);
$problem->addRule($rule);
$problem->addRule($conflict);


 
 foreach ($this->rules->getIteratorFor(RuleSet::TYPE_JOB) as $assertRule) {
if ($assertRule->isDisabled() || !$assertRule->isAssertion()) {
continue;
}

$assertRuleLiterals = $assertRule->literals;
$assertRuleLiteral = $assertRuleLiterals[0];

if (abs($literal) !== abs($assertRuleLiteral)) {
continue;
}

$problem->addRule($assertRule);
$this->disableProblem($assertRule);
}
$this->problems[] = $problem;

$this->decisions->resetToOffset($decisionStart);
$ruleIndex = -1;
}
}

protected function setupInstalledMap()
{
$this->installedMap = array();
foreach ($this->installed->getPackages() as $package) {
$this->installedMap[$package->id] = $package;
}
}

protected function checkForRootRequireProblems($ignorePlatformReqs)
{
foreach ($this->jobs as $job) {
switch ($job['cmd']) {
case 'update':
$packages = $this->pool->whatProvides($job['packageName'], $job['constraint']);
foreach ($packages as $package) {
if (isset($this->installedMap[$package->id])) {
$this->updateMap[$package->id] = true;
}
}
break;

case 'update-all':
foreach ($this->installedMap as $package) {
$this->updateMap[$package->id] = true;
}
break;

case 'install':
if ($ignorePlatformReqs && preg_match(PlatformRepository::PLATFORM_PACKAGE_REGEX, $job['packageName'])) {
break;
}

if (!$this->pool->whatProvides($job['packageName'], $job['constraint'])) {
$problem = new Problem($this->pool);
$problem->addRule(new Rule(array(), null, null, $job));
$this->problems[] = $problem;
}
break;
}
}
}

public function solve(Request $request, $ignorePlatformReqs = false)
{
$this->jobs = $request->getJobs();

$this->setupInstalledMap();
$this->rules = $this->ruleSetGenerator->getRulesFor($this->jobs, $this->installedMap, $ignorePlatformReqs);
$this->checkForRootRequireProblems($ignorePlatformReqs);
$this->decisions = new Decisions($this->pool);
$this->watchGraph = new RuleWatchGraph;

foreach ($this->rules as $rule) {
$this->watchGraph->insert(new RuleWatchNode($rule));
}


$this->makeAssertionRuleDecisions();

$this->runSat(true);


 foreach ($this->installedMap as $packageId => $void) {
if ($this->decisions->undecided($packageId)) {
$this->decisions->decide(-$packageId, 1, null);
}
}

if ($this->problems) {
throw new SolverProblemsException($this->problems, $this->installedMap);
}

$transaction = new Transaction($this->policy, $this->pool, $this->installedMap, $this->decisions);

return $transaction->getOperations();
}

protected function literalFromId($id)
{
$package = $this->pool->packageById(abs($id));

return new Literal($package, $id > 0);
}










protected function propagate($level)
{
while ($this->decisions->validOffset($this->propagateIndex)) {
$decision = $this->decisions->atOffset($this->propagateIndex);

$conflict = $this->watchGraph->propagateLiteral(
$decision[Decisions::DECISION_LITERAL],
$level,
$this->decisions
);

$this->propagateIndex++;

if ($conflict) {
return $conflict;
}
}

return null;
}




private function revert($level)
{
while (!$this->decisions->isEmpty()) {
$literal = $this->decisions->lastLiteral();

if ($this->decisions->undecided($literal)) {
break;
}

$decisionLevel = $this->decisions->decisionLevel($literal);

if ($decisionLevel <= $level) {
break;
}

$this->decisions->revertLast();
$this->propagateIndex = count($this->decisions);
}

while (!empty($this->branches) && $this->branches[count($this->branches) - 1][self::BRANCH_LEVEL] >= $level) {
array_pop($this->branches);
}
}
















private function setPropagateLearn($level, $literal, $disableRules, Rule $rule)
{
$level++;

$this->decisions->decide($literal, $level, $rule);

while (true) {
$rule = $this->propagate($level);

if (!$rule) {
break;
}

if ($level == 1) {
return $this->analyzeUnsolvable($rule, $disableRules);
}


 list($learnLiteral, $newLevel, $newRule, $why) = $this->analyze($level, $rule);

if ($newLevel <= 0 || $newLevel >= $level) {
throw new SolverBugException(
"Trying to revert to invalid level ".(int) $newLevel." from level ".(int) $level."."
);
} elseif (!$newRule) {
throw new SolverBugException(
"No rule was learned from analyzing $rule at level $level."
);
}

$level = $newLevel;

$this->revert($level);

$this->rules->add($newRule, RuleSet::TYPE_LEARNED);

$this->learnedWhy[$newRule->getId()] = $why;

$ruleNode = new RuleWatchNode($newRule);
$ruleNode->watch2OnHighest($this->decisions);
$this->watchGraph->insert($ruleNode);

$this->decisions->decide($learnLiteral, $level, $newRule);
}

return $level;
}

private function selectAndInstall($level, array $decisionQueue, $disableRules, Rule $rule)
{

 $literals = $this->policy->selectPreferredPackages($this->pool, $this->installedMap, $decisionQueue, $rule->getRequiredPackage());

$selectedLiteral = array_shift($literals);


 if (count($literals)) {
$this->branches[] = array($literals, $level);
}

return $this->setPropagateLearn($level, $selectedLiteral, $disableRules, $rule);
}

protected function analyze($level, $rule)
{
$analyzedRule = $rule;
$ruleLevel = 1;
$num = 0;
$l1num = 0;
$seen = array();
$learnedLiterals = array(null);

$decisionId = count($this->decisions);

$this->learnedPool[] = array();

while (true) {
$this->learnedPool[count($this->learnedPool) - 1][] = $rule;

foreach ($rule->literals as $literal) {

 if ($this->decisions->satisfy($literal)) {
continue;
}

if (isset($seen[abs($literal)])) {
continue;
}
$seen[abs($literal)] = true;

$l = $this->decisions->decisionLevel($literal);

if (1 === $l) {
$l1num++;
} elseif ($level === $l) {
$num++;
} else {

 $learnedLiterals[] = $literal;

if ($l > $ruleLevel) {
$ruleLevel = $l;
}
}
}

$l1retry = true;
while ($l1retry) {
$l1retry = false;

if (!$num && !--$l1num) {

 break 2;
}

while (true) {
if ($decisionId <= 0) {
throw new SolverBugException(
"Reached invalid decision id $decisionId while looking through $rule for a literal present in the analyzed rule $analyzedRule."
);
}

$decisionId--;

$decision = $this->decisions->atOffset($decisionId);
$literal = $decision[Decisions::DECISION_LITERAL];

if (isset($seen[abs($literal)])) {
break;
}
}

unset($seen[abs($literal)]);

if ($num && 0 === --$num) {
$learnedLiterals[0] = -abs($literal);

if (!$l1num) {
break 2;
}

foreach ($learnedLiterals as $i => $learnedLiteral) {
if ($i !== 0) {
unset($seen[abs($learnedLiteral)]);
}
}

 $l1num++;
$l1retry = true;
}
}

$decision = $this->decisions->atOffset($decisionId);
$rule = $decision[Decisions::DECISION_REASON];
}

$why = count($this->learnedPool) - 1;

if (!$learnedLiterals[0]) {
throw new SolverBugException(
"Did not find a learnable literal in analyzed rule $analyzedRule."
);
}

$newRule = new Rule($learnedLiterals, Rule::RULE_LEARNED, $why);

return array($learnedLiterals[0], $ruleLevel, $newRule, $why);
}

private function analyzeUnsolvableRule($problem, $conflictRule)
{
$why = $conflictRule->getId();

if ($conflictRule->getType() == RuleSet::TYPE_LEARNED) {
$learnedWhy = $this->learnedWhy[$why];
$problemRules = $this->learnedPool[$learnedWhy];

foreach ($problemRules as $problemRule) {
$this->analyzeUnsolvableRule($problem, $problemRule);
}

return;
}

if ($conflictRule->getType() == RuleSet::TYPE_PACKAGE) {

 return;
}

$problem->nextSection();
$problem->addRule($conflictRule);
}

private function analyzeUnsolvable($conflictRule, $disableRules)
{
$problem = new Problem($this->pool);
$problem->addRule($conflictRule);

$this->analyzeUnsolvableRule($problem, $conflictRule);

$this->problems[] = $problem;

$seen = array();
$literals = $conflictRule->literals;

foreach ($literals as $literal) {

 if ($this->decisions->satisfy($literal)) {
continue;
}
$seen[abs($literal)] = true;
}

foreach ($this->decisions as $decision) {
$literal = $decision[Decisions::DECISION_LITERAL];


 if (!isset($seen[abs($literal)])) {
continue;
}

$why = $decision[Decisions::DECISION_REASON];

$problem->addRule($why);
$this->analyzeUnsolvableRule($problem, $why);

$literals = $why->literals;

foreach ($literals as $literal) {

 if ($this->decisions->satisfy($literal)) {
continue;
}
$seen[abs($literal)] = true;
}
}

if ($disableRules) {
foreach ($this->problems[count($this->problems) - 1] as $reason) {
$this->disableProblem($reason['rule']);
}

$this->resetSolver();

return 1;
}

return 0;
}

private function disableProblem($why)
{
$job = $why->getJob();

if (!$job) {
$why->disable();

return;
}


 foreach ($this->rules as $rule) {
if ($job === $rule->getJob()) {
$rule->disable();
}
}
}

private function resetSolver()
{
$this->decisions->reset();

$this->propagateIndex = 0;
$this->branches = array();

$this->enableDisableLearnedRules();
$this->makeAssertionRuleDecisions();
}








private function enableDisableLearnedRules()
{
foreach ($this->rules->getIteratorFor(RuleSet::TYPE_LEARNED) as $rule) {
$why = $this->learnedWhy[$rule->getId()];
$problemRules = $this->learnedPool[$why];

$foundDisabled = false;
foreach ($problemRules as $problemRule) {
if ($problemRule->isDisabled()) {
$foundDisabled = true;
break;
}
}

if ($foundDisabled && $rule->isEnabled()) {
$rule->disable();
} elseif (!$foundDisabled && $rule->isDisabled()) {
$rule->enable();
}
}
}

private function runSat($disableRules = true)
{
$this->propagateIndex = 0;


 
 
 
 
 
 
 
 

$decisionQueue = array();
$decisionSupplementQueue = array();
$disableRules = array();

$level = 1;
$systemLevel = $level + 1;
$installedPos = 0;

while (true) {
if (1 === $level) {
$conflictRule = $this->propagate($level);
if (null !== $conflictRule) {
if ($this->analyzeUnsolvable($conflictRule, $disableRules)) {
continue;
}

return;
}
}


 if ($level < $systemLevel) {
$iterator = $this->rules->getIteratorFor(RuleSet::TYPE_JOB);
foreach ($iterator as $rule) {
if ($rule->isEnabled()) {
$decisionQueue = array();
$noneSatisfied = true;

foreach ($rule->literals as $literal) {
if ($this->decisions->satisfy($literal)) {
$noneSatisfied = false;
break;
}
if ($literal > 0 && $this->decisions->undecided($literal)) {
$decisionQueue[] = $literal;
}
}

if ($noneSatisfied && count($decisionQueue)) {

 
 if (count($this->installed) != count($this->updateMap)) {
$prunedQueue = array();
foreach ($decisionQueue as $literal) {
if (isset($this->installedMap[abs($literal)])) {
$prunedQueue[] = $literal;
if (isset($this->updateMap[abs($literal)])) {
$prunedQueue = $decisionQueue;
break;
}
}
}
$decisionQueue = $prunedQueue;
}
}

if ($noneSatisfied && count($decisionQueue)) {
$oLevel = $level;
$level = $this->selectAndInstall($level, $decisionQueue, $disableRules, $rule);

if (0 === $level) {
return;
}
if ($level <= $oLevel) {
break;
}
}
}
}

$systemLevel = $level + 1;


 $iterator->next();
if ($iterator->valid()) {
continue;
}
}

if ($level < $systemLevel) {
$systemLevel = $level;
}

for ($i = 0, $n = 0; $n < count($this->rules); $i++, $n++) {
if ($i == count($this->rules)) {
$i = 0;
}

$rule = $this->rules->ruleById[$i];
$literals = $rule->literals;

if ($rule->isDisabled()) {
continue;
}

$decisionQueue = array();


 
 
 
 
 
 foreach ($literals as $literal) {
if ($literal <= 0) {
if (!$this->decisions->decidedInstall(abs($literal))) {
continue 2; 
 }
} else {
if ($this->decisions->decidedInstall(abs($literal))) {
continue 2; 
 }
if ($this->decisions->undecided(abs($literal))) {
$decisionQueue[] = $literal;
}
}
}


 if (count($decisionQueue) < 2) {
continue;
}

$oLevel = $level;
$level = $this->selectAndInstall($level, $decisionQueue, $disableRules, $rule);

if (0 === $level) {
return;
}


 $n = -1;
}

if ($level < $systemLevel) {
continue;
}


 if (count($this->branches)) {
$lastLiteral = null;
$lastLevel = null;
$lastBranchIndex = 0;
$lastBranchOffset = 0;
$l = 0;

for ($i = count($this->branches) - 1; $i >= 0; $i--) {
list($literals, $l) = $this->branches[$i];

foreach ($literals as $offset => $literal) {
if ($literal && $literal > 0 && $this->decisions->decisionLevel($literal) > $l + 1) {
$lastLiteral = $literal;
$lastBranchIndex = $i;
$lastBranchOffset = $offset;
$lastLevel = $l;
}
}
}

if ($lastLiteral) {
unset($this->branches[$lastBranchIndex][self::BRANCH_LITERALS][$lastBranchOffset]);

$level = $lastLevel;
$this->revert($level);

$why = $this->decisions->lastReason();

$oLevel = $level;
$level = $this->setPropagateLearn($level, $lastLiteral, $disableRules, $why);

if ($level == 0) {
return;
}

continue;
}
}

break;
}
}
}
<?php











namespace Composer\DependencyResolver;




class SolverBugException extends \RuntimeException
{
public function __construct($message)
{
parent::__construct(
$message."\nThis exception was most likely caused by a bug in Composer.\n".
"Please report the command you ran, the exact error you received, and your composer.json on https://github.com/composer/composer/issues - thank you!\n");
}
}
<?php











namespace Composer\DependencyResolver;




class SolverProblemsException extends \RuntimeException
{
protected $problems;
protected $installedMap;

public function __construct(array $problems, array $installedMap)
{
$this->problems = $problems;
$this->installedMap = $installedMap;

parent::__construct($this->createMessage(), 2);
}

protected function createMessage()
{
$text = "\n";
foreach ($this->problems as $i => $problem) {
$text .= "  Problem ".($i+1).$problem->getPrettyString($this->installedMap)."\n";
}

if (strpos($text, 'could not be found') || strpos($text, 'no matching package found')) {
$text .= "\nPotential causes:\n - A typo in the package name\n - The package is not available in a stable-enough version according to your minimum-stability setting\n   see <https://groups.google.com/d/topic/composer-dev/_g3ASeIFlrc/discussion> for more details.\n\nRead <https://getcomposer.org/doc/articles/troubleshooting.md> for further common problems.";
}

return $text;
}

public function getProblems()
{
return $this->problems;
}
}
<?php











namespace Composer\DependencyResolver;

use Composer\Package\AliasPackage;




class Transaction
{
protected $policy;
protected $pool;
protected $installedMap;
protected $decisions;
protected $transaction;

public function __construct($policy, $pool, $installedMap, $decisions)
{
$this->policy = $policy;
$this->pool = $pool;
$this->installedMap = $installedMap;
$this->decisions = $decisions;
$this->transaction = array();
}

public function getOperations()
{
$installMeansUpdateMap = $this->findUpdates();

$updateMap = array();
$installMap = array();
$uninstallMap = array();

foreach ($this->decisions as $i => $decision) {
$literal = $decision[Decisions::DECISION_LITERAL];
$reason = $decision[Decisions::DECISION_REASON];

$package = $this->pool->literalToPackage($literal);


 if (($literal > 0) == (isset($this->installedMap[$package->id]))) {
continue;
}

if ($literal > 0) {
if (isset($installMeansUpdateMap[abs($literal)]) && !$package instanceof AliasPackage) {
$source = $installMeansUpdateMap[abs($literal)];

$updateMap[$package->id] = array(
'package' => $package,
'source' => $source,
'reason' => $reason,
);


 unset($installMeansUpdateMap[abs($literal)]);
$ignoreRemove[$source->id] = true;
} else {
$installMap[$package->id] = array(
'package' => $package,
'reason' => $reason,
);
}
}
}

foreach ($this->decisions as $i => $decision) {
$literal = $decision[Decisions::DECISION_LITERAL];
$reason = $decision[Decisions::DECISION_REASON];
$package = $this->pool->literalToPackage($literal);

if ($literal <= 0 &&
isset($this->installedMap[$package->id]) &&
!isset($ignoreRemove[$package->id])) {
$uninstallMap[$package->id] = array(
'package' => $package,
'reason' => $reason,
);
}
}

$this->transactionFromMaps($installMap, $updateMap, $uninstallMap);

return $this->transaction;
}

protected function transactionFromMaps($installMap, $updateMap, $uninstallMap)
{
$queue = array_map(function ($operation) {
return $operation['package'];
},
$this->findRootPackages($installMap, $updateMap)
);

$visited = array();

while (!empty($queue)) {
$package = array_pop($queue);
$packageId = $package->id;

if (!isset($visited[$packageId])) {
array_push($queue, $package);

if ($package instanceof AliasPackage) {
array_push($queue, $package->getAliasOf());
} else {
foreach ($package->getRequires() as $link) {
$possibleRequires = $this->pool->whatProvides($link->getTarget(), $link->getConstraint());

foreach ($possibleRequires as $require) {
array_push($queue, $require);
}
}
}

$visited[$package->id] = true;
} else {
if (isset($installMap[$packageId])) {
$this->install(
$installMap[$packageId]['package'],
$installMap[$packageId]['reason']
);
unset($installMap[$packageId]);
}
if (isset($updateMap[$packageId])) {
$this->update(
$updateMap[$packageId]['source'],
$updateMap[$packageId]['package'],
$updateMap[$packageId]['reason']
);
unset($updateMap[$packageId]);
}
}
}

foreach ($uninstallMap as $uninstall) {
$this->uninstall($uninstall['package'], $uninstall['reason']);
}
}

protected function findRootPackages($installMap, $updateMap)
{
$packages = $installMap + $updateMap;
$roots = $packages;

foreach ($packages as $packageId => $operation) {
$package = $operation['package'];

if (!isset($roots[$packageId])) {
continue;
}

foreach ($package->getRequires() as $link) {
$possibleRequires = $this->pool->whatProvides($link->getTarget(), $link->getConstraint());

foreach ($possibleRequires as $require) {
unset($roots[$require->id]);
}
}
}

return $roots;
}

protected function findUpdates()
{
$installMeansUpdateMap = array();

foreach ($this->decisions as $i => $decision) {
$literal = $decision[Decisions::DECISION_LITERAL];
$package = $this->pool->literalToPackage($literal);

if ($package instanceof AliasPackage) {
continue;
}


 if ($literal <= 0 && isset($this->installedMap[$package->id])) {
$updates = $this->policy->findUpdatePackages($this->pool, $this->installedMap, $package);

$literals = array($package->id);

foreach ($updates as $update) {
$literals[] = $update->id;
}

foreach ($literals as $updateLiteral) {
if ($updateLiteral !== $literal) {
$installMeansUpdateMap[abs($updateLiteral)] = $package;
}
}
}
}

return $installMeansUpdateMap;
}

protected function install($package, $reason)
{
if ($package instanceof AliasPackage) {
return $this->markAliasInstalled($package, $reason);
}

$this->transaction[] = new Operation\InstallOperation($package, $reason);
}

protected function update($from, $to, $reason)
{
$this->transaction[] = new Operation\UpdateOperation($from, $to, $reason);
}

protected function uninstall($package, $reason)
{
if ($package instanceof AliasPackage) {
return $this->markAliasUninstalled($package, $reason);
}

$this->transaction[] = new Operation\UninstallOperation($package, $reason);
}

protected function markAliasInstalled($package, $reason)
{
$this->transaction[] = new Operation\MarkAliasInstalledOperation($package, $reason);
}

protected function markAliasUninstalled($package, $reason)
{
$this->transaction[] = new Operation\MarkAliasUninstalledOperation($package, $reason);
}
}
<?php











namespace Composer\Downloader;

use Composer\Package\PackageInterface;
use Symfony\Component\Finder\Finder;








abstract class ArchiveDownloader extends FileDownloader
{



public function download(PackageInterface $package, $path)
{
$temporaryDir = $this->config->get('vendor-dir').'/composer/'.substr(md5(uniqid('', true)), 0, 8);
$retries = 3;
while ($retries--) {
$fileName = parent::download($package, $path);

if ($this->io->isVerbose()) {
$this->io->writeError('    Extracting archive');
}

try {
$this->filesystem->ensureDirectoryExists($temporaryDir);
try {
$this->extract($fileName, $temporaryDir);
} catch (\Exception $e) {

 parent::clearCache($package, $path);
throw $e;
}

$this->filesystem->unlink($fileName);

$contentDir = $this->getFolderContent($temporaryDir);


 if (1 === count($contentDir) && is_dir(reset($contentDir))) {
$contentDir = $this->getFolderContent((string) reset($contentDir));
}


 foreach ($contentDir as $file) {
$file = (string) $file;
$this->filesystem->rename($file, $path . '/' . basename($file));
}

$this->filesystem->removeDirectory($temporaryDir);
if ($this->filesystem->isDirEmpty($this->config->get('vendor-dir').'/composer/')) {
$this->filesystem->removeDirectory($this->config->get('vendor-dir').'/composer/');
}
if ($this->filesystem->isDirEmpty($this->config->get('vendor-dir'))) {
$this->filesystem->removeDirectory($this->config->get('vendor-dir'));
}
} catch (\Exception $e) {

 $this->filesystem->removeDirectory($path);
$this->filesystem->removeDirectory($temporaryDir);


 if ($retries && $e instanceof \UnexpectedValueException && class_exists('ZipArchive') && $e->getCode() === \ZipArchive::ER_NOZIP) {
$this->io->writeError('    Invalid zip file, retrying...');
usleep(500000);
continue;
}

throw $e;
}

break;
}

$this->io->writeError('');
}




protected function getFileName(PackageInterface $package, $path)
{
return rtrim($path.'/'.md5($path.spl_object_hash($package)).'.'.pathinfo(parse_url($package->getDistUrl(), PHP_URL_PATH), PATHINFO_EXTENSION), '.');
}




protected function processUrl(PackageInterface $package, $url)
{
if ($package->getDistReference() && strpos($url, 'github.com')) {
if (preg_match('{^https?://(?:www\.)?github\.com/([^/]+)/([^/]+)/(zip|tar)ball/(.+)$}i', $url, $match)) {

 $url = 'https://api.github.com/repos/' . $match[1] . '/'. $match[2] . '/' . $match[3] . 'ball/' . $package->getDistReference();
} elseif ($package->getDistReference() && preg_match('{^https?://(?:www\.)?github\.com/([^/]+)/([^/]+)/archive/.+\.(zip|tar)(?:\.gz)?$}i', $url, $match)) {

 $url = 'https://api.github.com/repos/' . $match[1] . '/'. $match[2] . '/' . $match[3] . 'ball/' . $package->getDistReference();
} elseif ($package->getDistReference() && preg_match('{^https?://api\.github\.com/repos/([^/]+)/([^/]+)/(zip|tar)ball(?:/.+)?$}i', $url, $match)) {

 $url = 'https://api.github.com/repos/' . $match[1] . '/'. $match[2] . '/' . $match[3] . 'ball/' . $package->getDistReference();
}
}

if (!extension_loaded('openssl') && (0 === strpos($url, 'https:') || 0 === strpos($url, 'http://github.com'))) {
throw new \RuntimeException('You must enable the openssl extension to download files via https');
}

return parent::processUrl($package, $url);
}









abstract protected function extract($file, $path);







private function getFolderContent($dir)
{
$finder = Finder::create()
->ignoreVCS(false)
->ignoreDotFiles(false)
->depth(0)
->in($dir);

return iterator_to_array($finder);
}
}
<?php











namespace Composer\Downloader;

use Composer\Package\PackageInterface;






interface ChangeReportInterface
{







public function getLocalChanges(PackageInterface $package, $path);
}
<?php











namespace Composer\Downloader;

use Composer\Package\PackageInterface;
use Composer\IO\IOInterface;
use Composer\Util\Filesystem;






class DownloadManager
{
private $io;
private $preferDist = false;
private $preferSource = false;
private $filesystem;
private $downloaders = array();








public function __construct(IOInterface $io, $preferSource = false, Filesystem $filesystem = null)
{
$this->io = $io;
$this->preferSource = $preferSource;
$this->filesystem = $filesystem ?: new Filesystem();
}







public function setPreferSource($preferSource)
{
$this->preferSource = $preferSource;

return $this;
}







public function setPreferDist($preferDist)
{
$this->preferDist = $preferDist;

return $this;
}








public function setOutputProgress($outputProgress)
{
foreach ($this->downloaders as $downloader) {
$downloader->setOutputProgress($outputProgress);
}

return $this;
}








public function setDownloader($type, DownloaderInterface $downloader)
{
$type = strtolower($type);
$this->downloaders[$type] = $downloader;

return $this;
}









public function getDownloader($type)
{
$type = strtolower($type);
if (!isset($this->downloaders[$type])) {
throw new \InvalidArgumentException(sprintf('Unknown downloader type: %s. Available types: %s.', $type, implode(', ', array_keys($this->downloaders))));
}

return $this->downloaders[$type];
}











public function getDownloaderForInstalledPackage(PackageInterface $package)
{
$installationSource = $package->getInstallationSource();

if ('metapackage' === $package->getType()) {
return;
}

if ('dist' === $installationSource) {
$downloader = $this->getDownloader($package->getDistType());
} elseif ('source' === $installationSource) {
$downloader = $this->getDownloader($package->getSourceType());
} else {
throw new \InvalidArgumentException(
'Package '.$package.' seems not been installed properly'
);
}

if ($installationSource !== $downloader->getInstallationSource()) {
throw new \LogicException(sprintf(
'Downloader "%s" is a %s type downloader and can not be used to download %s',
get_class($downloader), $downloader->getInstallationSource(), $installationSource
));
}

return $downloader;
}











public function download(PackageInterface $package, $targetDir, $preferSource = null)
{
$preferSource = null !== $preferSource ? $preferSource : $this->preferSource;
$sourceType = $package->getSourceType();
$distType = $package->getDistType();

$sources = array();
if ($sourceType) {
$sources[] = 'source';
}
if ($distType) {
$sources[] = 'dist';
}

if (empty($sources)) {
throw new \InvalidArgumentException('Package '.$package.' must have a source or dist specified');
}

if ((!$package->isDev() || $this->preferDist) && !$preferSource) {
$sources = array_reverse($sources);
}

$this->filesystem->ensureDirectoryExists($targetDir);

foreach ($sources as $i => $source) {
if (isset($e)) {
$this->io->writeError('    <warning>Now trying to download from ' . $source . '</warning>');
}
$package->setInstallationSource($source);
try {
$downloader = $this->getDownloaderForInstalledPackage($package);
if ($downloader) {
$downloader->download($package, $targetDir);
}
break;
} catch (\RuntimeException $e) {
if ($i === count($sources) - 1) {
throw $e;
}

$this->io->writeError(
'    <warning>Failed to download '.
$package->getPrettyName().
' from ' . $source . ': '.
$e->getMessage().'</warning>'
);
}
}
}










public function update(PackageInterface $initial, PackageInterface $target, $targetDir)
{
$downloader = $this->getDownloaderForInstalledPackage($initial);
if (!$downloader) {
return;
}

$installationSource = $initial->getInstallationSource();

if ('dist' === $installationSource) {
$initialType = $initial->getDistType();
$targetType = $target->getDistType();
} else {
$initialType = $initial->getSourceType();
$targetType = $target->getSourceType();
}


 if ($target->isDev() && 'dist' === $installationSource) {
$downloader->remove($initial, $targetDir);
$this->download($target, $targetDir);

return;
}

if ($initialType === $targetType) {
$target->setInstallationSource($installationSource);
$downloader->update($initial, $target, $targetDir);
} else {
$downloader->remove($initial, $targetDir);
$this->download($target, $targetDir, 'source' === $installationSource);
}
}







public function remove(PackageInterface $package, $targetDir)
{
$downloader = $this->getDownloaderForInstalledPackage($package);
if ($downloader) {
$downloader->remove($package, $targetDir);
}
}
}
<?php











namespace Composer\Downloader;

use Composer\Package\PackageInterface;







interface DownloaderInterface
{





public function getInstallationSource();







public function download(PackageInterface $package, $path);








public function update(PackageInterface $initial, PackageInterface $target, $path);







public function remove(PackageInterface $package, $path);







public function setOutputProgress($outputProgress);
}
<?php











namespace Composer\Downloader;

use Composer\Config;
use Composer\Cache;
use Composer\IO\IOInterface;
use Composer\Package\PackageInterface;
use Composer\Package\Version\VersionParser;
use Composer\Plugin\PluginEvents;
use Composer\Plugin\PreFileDownloadEvent;
use Composer\EventDispatcher\EventDispatcher;
use Composer\Util\Filesystem;
use Composer\Util\RemoteFilesystem;









class FileDownloader implements DownloaderInterface
{
protected $io;
protected $config;
protected $rfs;
protected $filesystem;
protected $cache;
protected $outputProgress = true;











public function __construct(IOInterface $io, Config $config, EventDispatcher $eventDispatcher = null, Cache $cache = null, RemoteFilesystem $rfs = null, Filesystem $filesystem = null)
{
$this->io = $io;
$this->config = $config;
$this->eventDispatcher = $eventDispatcher;
$this->rfs = $rfs ?: new RemoteFilesystem($io, $config);
$this->filesystem = $filesystem ?: new Filesystem();
$this->cache = $cache;

if ($this->cache && $this->cache->gcIsNecessary()) {
$this->cache->gc($config->get('cache-files-ttl'), $config->get('cache-files-maxsize'));
}
}




public function getInstallationSource()
{
return 'dist';
}




public function download(PackageInterface $package, $path)
{
if (!$package->getDistUrl()) {
throw new \InvalidArgumentException('The given package is missing url information');
}

$this->io->writeError("  - Installing <info>" . $package->getName() . "</info> (<comment>" . VersionParser::formatVersion($package) . "</comment>)");

$urls = $package->getDistUrls();
while ($url = array_shift($urls)) {
try {
return $this->doDownload($package, $path, $url);
} catch (\Exception $e) {
if ($this->io->isDebug()) {
$this->io->writeError('');
$this->io->writeError('Failed: ['.get_class($e).'] '.$e->getCode().': '.$e->getMessage());
} elseif (count($urls)) {
$this->io->writeError('');
$this->io->writeError('    Failed, trying the next URL ('.$e->getCode().': '.$e->getMessage().')');
}

if (!count($urls)) {
throw $e;
}
}
}

$this->io->writeError('');
}

protected function doDownload(PackageInterface $package, $path, $url)
{
$this->filesystem->emptyDirectory($path);

$fileName = $this->getFileName($package, $path);

$processedUrl = $this->processUrl($package, $url);
$hostname = parse_url($processedUrl, PHP_URL_HOST);

$preFileDownloadEvent = new PreFileDownloadEvent(PluginEvents::PRE_FILE_DOWNLOAD, $this->rfs, $processedUrl);
if ($this->eventDispatcher) {
$this->eventDispatcher->dispatch($preFileDownloadEvent->getName(), $preFileDownloadEvent);
}
$rfs = $preFileDownloadEvent->getRemoteFilesystem();

try {
$checksum = $package->getDistSha1Checksum();
$cacheKey = $this->getCacheKey($package);


 if (!$this->cache || ($checksum && $checksum !== $this->cache->sha1($cacheKey)) || !$this->cache->copyTo($cacheKey, $fileName)) {
if (!$this->outputProgress) {
$this->io->writeError('    Downloading');
}


 $retries = 3;
while ($retries--) {
try {
$rfs->copy($hostname, $processedUrl, $fileName, $this->outputProgress, $package->getTransportOptions());
break;
} catch (TransportException $e) {

 if ((0 !== $e->getCode() && !in_array($e->getCode(),array(500, 502, 503, 504))) || !$retries) {
throw $e;
}
if ($this->io->isVerbose()) {
$this->io->writeError('    Download failed, retrying...');
}
usleep(500000);
}
}

if ($this->cache) {
$this->cache->copyFrom($cacheKey, $fileName);
}
} else {
$this->io->writeError('    Loading from cache');
}

if (!file_exists($fileName)) {
throw new \UnexpectedValueException($url.' could not be saved to '.$fileName.', make sure the'
.' directory is writable and you have internet connectivity');
}

if ($checksum && hash_file('sha1', $fileName) !== $checksum) {
throw new \UnexpectedValueException('The checksum verification of the file failed (downloaded from '.$url.')');
}
} catch (\Exception $e) {

 $this->filesystem->removeDirectory($path);
$this->clearCache($package, $path);
throw $e;
}

return $fileName;
}




public function setOutputProgress($outputProgress)
{
$this->outputProgress = $outputProgress;

return $this;
}

protected function clearCache(PackageInterface $package, $path)
{
if ($this->cache) {
$fileName = $this->getFileName($package, $path);
$this->cache->remove($this->getCacheKey($package));
}
}




public function update(PackageInterface $initial, PackageInterface $target, $path)
{
$this->remove($initial, $path);
$this->download($target, $path);
}




public function remove(PackageInterface $package, $path)
{
$this->io->writeError("  - Removing <info>" . $package->getName() . "</info> (<comment>" . VersionParser::formatVersion($package) . "</comment>)");
if (!$this->filesystem->removeDirectory($path)) {
throw new \RuntimeException('Could not completely delete '.$path.', aborting.');
}
}








protected function getFileName(PackageInterface $package, $path)
{
return $path.'/'.pathinfo(parse_url($package->getDistUrl(), PHP_URL_PATH), PATHINFO_BASENAME);
}










protected function processUrl(PackageInterface $package, $url)
{
if (!extension_loaded('openssl') && 0 === strpos($url, 'https:')) {
throw new \RuntimeException('You must enable the openssl extension to download files via https');
}

return $url;
}

private function getCacheKey(PackageInterface $package)
{
if (preg_match('{^[a-f0-9]{40}$}', $package->getDistReference())) {
return $package->getName().'/'.$package->getDistReference().'.'.$package->getDistType();
}

return $package->getName().'/'.$package->getVersion().'-'.$package->getDistReference().'.'.$package->getDistType();
}
}
<?php











namespace Composer\Downloader;






class FilesystemException extends \Exception
{
public function __construct($message = null, $code = null, \Exception $previous = null)
{
parent::__construct("Filesystem exception: \n".$message, $code, $previous);
}
}
<?php











namespace Composer\Downloader;

use Composer\Package\PackageInterface;
use Composer\Util\GitHub;
use Composer\Util\Git as GitUtil;
use Composer\Util\ProcessExecutor;
use Composer\IO\IOInterface;
use Composer\Util\Filesystem;
use Composer\Config;




class GitDownloader extends VcsDownloader
{
private $hasStashedChanges = false;
private $gitUtil;

public function __construct(IOInterface $io, Config $config, ProcessExecutor $process = null, Filesystem $fs = null)
{
parent::__construct($io, $config, $process, $fs);
$this->gitUtil = new GitUtil($this->io, $this->config, $this->process, $this->filesystem);
}




public function doDownload(PackageInterface $package, $path, $url)
{
GitUtil::cleanEnv();
$path = $this->normalizePath($path);

$ref = $package->getSourceReference();
$flag = defined('PHP_WINDOWS_VERSION_MAJOR') ? '/D ' : '';
$command = 'git clone --no-checkout %s %s && cd '.$flag.'%2$s && git remote add composer %1$s && git fetch composer';
$this->io->writeError("    Cloning ".$ref);

$commandCallable = function ($url) use ($ref, $path, $command) {
return sprintf($command, ProcessExecutor::escape($url), ProcessExecutor::escape($path), ProcessExecutor::escape($ref));
};

$this->gitUtil->runCommand($commandCallable, $url, $path, true);
if ($url !== $package->getSourceUrl()) {
$url = $package->getSourceUrl();
$this->process->execute(sprintf('git remote set-url origin %s', ProcessExecutor::escape($url)), $output, $path);
}
$this->setPushUrl($path, $url);

if ($newRef = $this->updateToCommit($path, $ref, $package->getPrettyVersion(), $package->getReleaseDate())) {
if ($package->getDistReference() === $package->getSourceReference()) {
$package->setDistReference($newRef);
}
$package->setSourceReference($newRef);
}
}




public function doUpdate(PackageInterface $initial, PackageInterface $target, $path, $url)
{
GitUtil::cleanEnv();
$path = $this->normalizePath($path);
if (!is_dir($path.'/.git')) {
throw new \RuntimeException('The .git directory is missing from '.$path.', see https://getcomposer.org/commit-deps for more information');
}

$ref = $target->getSourceReference();
$this->io->writeError("    Checking out ".$ref);
$command = 'git remote set-url composer %s && git fetch composer && git fetch --tags composer';

$commandCallable = function ($url) use ($command) {
return sprintf($command, ProcessExecutor::escape ($url));
};

$this->gitUtil->runCommand($commandCallable, $url, $path);
if ($newRef = $this->updateToCommit($path, $ref, $target->getPrettyVersion(), $target->getReleaseDate())) {
if ($target->getDistReference() === $target->getSourceReference()) {
$target->setDistReference($newRef);
}
$target->setSourceReference($newRef);
}
}




public function getLocalChanges(PackageInterface $package, $path)
{
GitUtil::cleanEnv();
$path = $this->normalizePath($path);
if (!is_dir($path.'/.git')) {
return;
}

$command = 'git status --porcelain --untracked-files=no';
if (0 !== $this->process->execute($command, $output, $path)) {
throw new \RuntimeException('Failed to execute ' . $command . "\n\n" . $this->process->getErrorOutput());
}

return trim($output) ?: null;
}




protected function cleanChanges(PackageInterface $package, $path, $update)
{
GitUtil::cleanEnv();
$path = $this->normalizePath($path);
if (!$changes = $this->getLocalChanges($package, $path)) {
return;
}

if (!$this->io->isInteractive()) {
$discardChanges = $this->config->get('discard-changes');
if (true === $discardChanges) {
return $this->discardChanges($path);
}
if ('stash' === $discardChanges) {
if (!$update) {
return parent::cleanChanges($package, $path, $update);
}

return $this->stashChanges($path);
}

return parent::cleanChanges($package, $path, $update);
}

$changes = array_map(function ($elem) {
return '    '.$elem;
}, preg_split('{\s*\r?\n\s*}', $changes));
$this->io->writeError('    <error>The package has modified files:</error>');
$this->io->writeError(array_slice($changes, 0, 10));
if (count($changes) > 10) {
$this->io->writeError('    <info>'.count($changes) - 10 . ' more files modified, choose "v" to view the full list</info>');
}

while (true) {
switch ($this->io->ask('    <info>Discard changes [y,n,v,'.($update ? 's,' : '').'?]?</info> ', '?')) {
case 'y':
$this->discardChanges($path);
break 2;

case 's':
if (!$update) {
goto help;
}

$this->stashChanges($path);
break 2;

case 'n':
throw new \RuntimeException('Update aborted');

case 'v':
$this->io->writeError($changes);
break;

case '?':
default:
help:
$this->io->writeError(array(
'    y - discard changes and apply the '.($update ? 'update' : 'uninstall'),
'    n - abort the '.($update ? 'update' : 'uninstall').' and let you manually clean things up',
'    v - view modified files',
));
if ($update) {
$this->io->writeError('    s - stash changes and try to reapply them after the update');
}
$this->io->writeError('    ? - print help');
break;
}
}
}




protected function reapplyChanges($path)
{
$path = $this->normalizePath($path);
if ($this->hasStashedChanges) {
$this->hasStashedChanges = false;
$this->io->writeError('    <info>Re-applying stashed changes</info>');
if (0 !== $this->process->execute('git stash pop', $output, $path)) {
throw new \RuntimeException("Failed to apply stashed changes:\n\n".$this->process->getErrorOutput());
}
}
}












protected function updateToCommit($path, $reference, $branch, $date)
{

 
 
 
 
 $template = 'git checkout %s -- && git reset --hard %1$s';
$branch = preg_replace('{(?:^dev-|(?:\.x)?-dev$)}i', '', $branch);

$branches = null;
if (0 === $this->process->execute('git branch -r', $output, $path)) {
$branches = $output;
}


 $gitRef = $reference;
if (!preg_match('{^[a-f0-9]{40}$}', $reference)
&& $branches
&& preg_match('{^\s+composer/'.preg_quote($reference).'$}m', $branches)
) {
$command = sprintf('git checkout -B %s %s && git reset --hard %2$s', ProcessExecutor::escape($branch), ProcessExecutor::escape('composer/'.$reference));
if (0 === $this->process->execute($command, $output, $path)) {
return;
}
}


 if (preg_match('{^[a-f0-9]{40}$}', $reference)) {

 if (!preg_match('{^\s+composer/'.preg_quote($branch).'$}m', $branches) && preg_match('{^\s+composer/v'.preg_quote($branch).'$}m', $branches)) {
$branch = 'v' . $branch;
}

$command = sprintf('git checkout %s --', ProcessExecutor::escape($branch));
$fallbackCommand = sprintf('git checkout -B %s %s', ProcessExecutor::escape($branch), ProcessExecutor::escape('composer/'.$branch));
if (0 === $this->process->execute($command, $output, $path)
|| 0 === $this->process->execute($fallbackCommand, $output, $path)
) {
$command = sprintf('git reset --hard %s', ProcessExecutor::escape($reference));
if (0 === $this->process->execute($command, $output, $path)) {
return;
}
}
}

$command = sprintf($template, ProcessExecutor::escape($gitRef));
if (0 === $this->process->execute($command, $output, $path)) {
return;
}


 if (false !== strpos($this->process->getErrorOutput(), $reference)) {
$this->io->writeError('    <warning>'.$reference.' is gone (history was rewritten?)</warning>');
}

throw new \RuntimeException('Failed to execute ' . GitUtil::sanitizeUrl($command) . "\n\n" . $this->process->getErrorOutput());
}

protected function setPushUrl($path, $url)
{

 if (preg_match('{^(?:https?|git)://'.GitUtil::getGitHubDomainsRegex($this->config).'/([^/]+)/([^/]+?)(?:\.git)?$}', $url, $match)) {
$protocols = $this->config->get('github-protocols');
$pushUrl = 'git@'.$match[1].':'.$match[2].'/'.$match[3].'.git';
if ($protocols[0] !== 'git') {
$pushUrl = 'https://' . $match[1] . '/'.$match[2].'/'.$match[3].'.git';
}
$cmd = sprintf('git remote set-url --push origin %s', ProcessExecutor::escape($pushUrl));
$this->process->execute($cmd, $ignoredOutput, $path);
}
}




protected function getCommitLogs($fromReference, $toReference, $path)
{
$path = $this->normalizePath($path);
$command = sprintf('git log %s..%s --pretty=format:"%%h - %%an: %%s"', $fromReference, $toReference);

if (0 !== $this->process->execute($command, $output, $path)) {
throw new \RuntimeException('Failed to execute ' . $command . "\n\n" . $this->process->getErrorOutput());
}

return $output;
}





protected function discardChanges($path)
{
$path = $this->normalizePath($path);
if (0 !== $this->process->execute('git reset --hard', $output, $path)) {
throw new \RuntimeException("Could not reset changes\n\n:".$this->process->getErrorOutput());
}
}





protected function stashChanges($path)
{
$path = $this->normalizePath($path);
if (0 !== $this->process->execute('git stash', $output, $path)) {
throw new \RuntimeException("Could not stash changes\n\n:".$this->process->getErrorOutput());
}

$this->hasStashedChanges = true;
}

protected function normalizePath($path)
{
if (defined('PHP_WINDOWS_VERSION_MAJOR') && strlen($path) > 0) {
$basePath = $path;
$removed = array();

while (!is_dir($basePath) && $basePath !== '\\') {
array_unshift($removed, basename($basePath));
$basePath = dirname($basePath);
}

if ($basePath === '\\') {
return $path;
}

$path = rtrim(realpath($basePath) . '/' . implode('/', $removed), '/');
}

return $path;
}
}
<?php











namespace Composer\Downloader;

use Composer\Config;
use Composer\Cache;
use Composer\EventDispatcher\EventDispatcher;
use Composer\Package\PackageInterface;
use Composer\Util\ProcessExecutor;
use Composer\IO\IOInterface;






class GzipDownloader extends ArchiveDownloader
{
protected $process;

public function __construct(IOInterface $io, Config $config, EventDispatcher $eventDispatcher = null, Cache $cache = null, ProcessExecutor $process = null)
{
$this->process = $process ?: new ProcessExecutor($io);
parent::__construct($io, $config, $eventDispatcher, $cache);
}

protected function extract($file, $path)
{
$targetFilepath = $path . DIRECTORY_SEPARATOR . basename(substr($file, 0, -3));


 if (!defined('PHP_WINDOWS_VERSION_BUILD')) {
$command = 'gzip -cd ' . ProcessExecutor::escape($file) . ' > ' . ProcessExecutor::escape($targetFilepath);

if (0 === $this->process->execute($command, $ignoredOutput)) {
return;
}

$processError = 'Failed to execute ' . $command . "\n\n" . $this->process->getErrorOutput();
throw new \RuntimeException($processError);
}


 $archiveFile = gzopen($file, 'rb');
$targetFile = fopen($targetFilepath, 'wb');
while ($string = gzread($archiveFile, 4096)) {
fwrite($targetFile, $string, strlen($string));
}
gzclose($archiveFile);
fclose($targetFile);
}




protected function getFileName(PackageInterface $package, $path)
{
return $path.'/'.pathinfo(parse_url($package->getDistUrl(), PHP_URL_PATH), PATHINFO_BASENAME);
}
}
<?php











namespace Composer\Downloader;

use Composer\Package\PackageInterface;
use Composer\Util\ProcessExecutor;




class HgDownloader extends VcsDownloader
{



public function doDownload(PackageInterface $package, $path, $url)
{
$url = ProcessExecutor::escape($url);
$ref = ProcessExecutor::escape($package->getSourceReference());
$this->io->writeError("    Cloning ".$package->getSourceReference());
$command = sprintf('hg clone %s %s', $url, ProcessExecutor::escape($path));
if (0 !== $this->process->execute($command, $ignoredOutput)) {
throw new \RuntimeException('Failed to execute ' . $command . "\n\n" . $this->process->getErrorOutput());
}
$command = sprintf('hg up %s', $ref);
if (0 !== $this->process->execute($command, $ignoredOutput, realpath($path))) {
throw new \RuntimeException('Failed to execute ' . $command . "\n\n" . $this->process->getErrorOutput());
}
}




public function doUpdate(PackageInterface $initial, PackageInterface $target, $path, $url)
{
$url = ProcessExecutor::escape($url);
$ref = ProcessExecutor::escape($target->getSourceReference());
$this->io->writeError("    Updating to ".$target->getSourceReference());

if (!is_dir($path.'/.hg')) {
throw new \RuntimeException('The .hg directory is missing from '.$path.', see https://getcomposer.org/commit-deps for more information');
}

$command = sprintf('hg pull %s && hg up %s', $url, $ref);
if (0 !== $this->process->execute($command, $ignoredOutput, realpath($path))) {
throw new \RuntimeException('Failed to execute ' . $command . "\n\n" . $this->process->getErrorOutput());
}
}




public function getLocalChanges(PackageInterface $package, $path)
{
if (!is_dir($path.'/.hg')) {
return;
}

$this->process->execute('hg st', $output, realpath($path));

return trim($output) ?: null;
}




protected function getCommitLogs($fromReference, $toReference, $path)
{
$command = sprintf('hg log -r %s:%s --style compact', $fromReference, $toReference);

if (0 !== $this->process->execute($command, $output, realpath($path))) {
throw new \RuntimeException('Failed to execute ' . $command . "\n\n" . $this->process->getErrorOutput());
}

return $output;
}
}
<?php











namespace Composer\Downloader;

use Composer\Util\Filesystem;










class PearPackageExtractor
{
private static $rolesWithoutPackageNamePrefix = array('php', 'script', 'www');

private $filesystem;
private $file;

public function __construct($file)
{
if (!is_file($file)) {
throw new \UnexpectedValueException('PEAR package file is not found at '.$file);
}

$this->filesystem = new Filesystem();
$this->file = $file;
}











public function extractTo($target, array $roles = array('php' => '/', 'script' => '/bin'), $vars = array())
{
$extractionPath = $target.'/tarball';

try {
$archive = new \PharData($this->file);
$archive->extractTo($extractionPath, null, true);

if (!is_file($this->combine($extractionPath, '/package.xml'))) {
throw new \RuntimeException('Invalid PEAR package. It must contain package.xml file.');
}

$fileCopyActions = $this->buildCopyActions($extractionPath, $roles, $vars);
$this->copyFiles($fileCopyActions, $extractionPath, $target, $roles, $vars);
$this->filesystem->removeDirectory($extractionPath);
} catch (\Exception $exception) {
throw new \UnexpectedValueException(sprintf('Failed to extract PEAR package %s to %s. Reason: %s', $this->file, $target, $exception->getMessage()), 0, $exception);
}
}










private function copyFiles($files, $source, $target, $roles, $vars)
{
foreach ($files as $file) {
$from = $this->combine($source, $file['from']);
$to = $this->combine($target, $roles[$file['role']]);
$to = $this->combine($to, $file['to']);
$tasks = $file['tasks'];
$this->copyFile($from, $to, $tasks, $vars);
}
}

private function copyFile($from, $to, $tasks, $vars)
{
if (!is_file($from)) {
throw new \RuntimeException('Invalid PEAR package. package.xml defines file that is not located inside tarball.');
}

$this->filesystem->ensureDirectoryExists(dirname($to));

if (0 == count($tasks)) {
$copied = copy($from, $to);
} else {
$content = file_get_contents($from);
$replacements = array();
foreach ($tasks as $task) {
$pattern = $task['from'];
$varName = $task['to'];
if (isset($vars[$varName])) {
if ($varName === 'php_bin' && false === strpos($to, '.bat')) {
$replacements[$pattern] = preg_replace('{\.bat$}', '', $vars[$varName]);
} else {
$replacements[$pattern] = $vars[$varName];
}
}
}
$content = strtr($content, $replacements);

$copied = file_put_contents($to, $content);
}

if (false === $copied) {
throw new \RuntimeException(sprintf('Failed to copy %s to %s', $from, $to));
}
}











private function buildCopyActions($source, array $roles, $vars)
{

$package = simplexml_load_file($this->combine($source, 'package.xml'));
if (false === $package) {
throw new \RuntimeException('Package definition file is not valid.');
}

$packageSchemaVersion = $package['version'];
if ('1.0' == $packageSchemaVersion) {
$children = $package->release->filelist->children();
$packageName = (string) $package->name;
$packageVersion = (string) $package->release->version;
$sourceDir = $packageName . '-' . $packageVersion;
$result = $this->buildSourceList10($children, $roles, $sourceDir, '', null, $packageName);
} elseif ('2.0' == $packageSchemaVersion || '2.1' == $packageSchemaVersion) {
$children = $package->contents->children();
$packageName = (string) $package->name;
$packageVersion = (string) $package->version->release;
$sourceDir = $packageName . '-' . $packageVersion;
$result = $this->buildSourceList20($children, $roles, $sourceDir, '', null, $packageName);

$namespaces = $package->getNamespaces();
$package->registerXPathNamespace('ns', $namespaces['']);
$releaseNodes = $package->xpath('ns:phprelease');
$this->applyRelease($result, $releaseNodes, $vars);
} else {
throw new \RuntimeException('Unsupported schema version of package definition file.');
}

return $result;
}

private function applyRelease(&$actions, $releaseNodes, $vars)
{
foreach ($releaseNodes as $releaseNode) {
$requiredOs = $releaseNode->installconditions && $releaseNode->installconditions->os && $releaseNode->installconditions->os->name ? (string) $releaseNode->installconditions->os->name : '';
if ($requiredOs && $vars['os'] != $requiredOs) {
continue;
}

if ($releaseNode->filelist) {
foreach ($releaseNode->filelist->children() as $action) {
if ('install' == $action->getName()) {
$name = (string) $action['name'];
$as = (string) $action['as'];
if (isset($actions[$name])) {
$actions[$name]['to'] = $as;
}
} elseif ('ignore' == $action->getName()) {
$name = (string) $action['name'];
unset($actions[$name]);
} else {

 }
}
}
break;
}
}

private function buildSourceList10($children, $targetRoles, $source, $target, $role, $packageName)
{
$result = array();


 foreach ($children as $child) {

if ($child->getName() == 'dir') {
$dirSource = $this->combine($source, (string) $child['name']);
$dirTarget = $child['baseinstalldir'] ?: $target;
$dirRole = $child['role'] ?: $role;
$dirFiles = $this->buildSourceList10($child->children(), $targetRoles, $dirSource, $dirTarget, $dirRole, $packageName);
$result = array_merge($result, $dirFiles);
} elseif ($child->getName() == 'file') {
$fileRole = (string) $child['role'] ?: $role;
if (isset($targetRoles[$fileRole])) {
$fileName = (string) ($child['name'] ?: $child[0]); 
 $fileSource = $this->combine($source, $fileName);
$fileTarget = $this->combine((string) $child['baseinstalldir'] ?: $target, $fileName);
if (!in_array($fileRole, self::$rolesWithoutPackageNamePrefix)) {
$fileTarget = $packageName . '/' . $fileTarget;
}
$result[(string) $child['name']] = array('from' => $fileSource, 'to' => $fileTarget, 'role' => $fileRole, 'tasks' => array());
}
}
}

return $result;
}

private function buildSourceList20($children, $targetRoles, $source, $target, $role, $packageName)
{
$result = array();


 foreach ($children as $child) {

if ('dir' == $child->getName()) {
$dirSource = $this->combine($source, $child['name']);
$dirTarget = $child['baseinstalldir'] ?: $target;
$dirRole = $child['role'] ?: $role;
$dirFiles = $this->buildSourceList20($child->children(), $targetRoles, $dirSource, $dirTarget, $dirRole, $packageName);
$result = array_merge($result, $dirFiles);
} elseif ('file' == $child->getName()) {
$fileRole = (string) $child['role'] ?: $role;
if (isset($targetRoles[$fileRole])) {
$fileSource = $this->combine($source, (string) $child['name']);
$fileTarget = $this->combine((string) ($child['baseinstalldir'] ?: $target), (string) $child['name']);
$fileTasks = array();
foreach ($child->children('http://pear.php.net/dtd/tasks-1.0') as $taskNode) {
if ('replace' == $taskNode->getName()) {
$fileTasks[] = array('from' => (string) $taskNode->attributes()->from, 'to' => (string) $taskNode->attributes()->to);
}
}
if (!in_array($fileRole, self::$rolesWithoutPackageNamePrefix)) {
$fileTarget = $packageName . '/' . $fileTarget;
}
$result[(string) $child['name']] = array('from' => $fileSource, 'to' => $fileTarget, 'role' => $fileRole, 'tasks' => $fileTasks);
}
}
}

return $result;
}

private function combine($left, $right)
{
return rtrim($left, '/') . '/' . ltrim($right, '/');
}
}
<?php











namespace Composer\Downloader;

use Composer\Package\PackageInterface;
use Composer\Repository\VcsRepository;
use Composer\Util\Perforce;




class PerforceDownloader extends VcsDownloader
{
protected $perforce;




public function doDownload(PackageInterface $package, $path, $url)
{
$ref = $package->getSourceReference();
$label = $this->getLabelFromSourceReference($ref);

$this->io->writeError('    Cloning ' . $ref);
$this->initPerforce($package, $path, $url);
$this->perforce->setStream($ref);
$this->perforce->p4Login($this->io);
$this->perforce->writeP4ClientSpec();
$this->perforce->connectClient();
$this->perforce->syncCodeBase($label);
$this->perforce->cleanupClientSpec();
}

private function getLabelFromSourceReference($ref)
{
$pos = strpos($ref,'@');
if (false !== $pos) {
return substr($ref, $pos + 1);
}

return null;
}

public function initPerforce($package, $path, $url)
{
if (!empty($this->perforce)) {
$this->perforce->initializePath($path);

return;
}

$repository = $package->getRepository();
$repoConfig = null;
if ($repository instanceof VcsRepository) {
$repoConfig = $this->getRepoConfig($repository);
}
$this->perforce = Perforce::create($repoConfig, $url, $path, $this->process, $this->io);
}

private function getRepoConfig(VcsRepository $repository)
{
return $repository->getRepoConfig();
}




public function doUpdate(PackageInterface $initial, PackageInterface $target, $path, $url)
{
$this->doDownload($target, $path, $url);
}




public function getLocalChanges(PackageInterface $package, $path)
{
$this->io->writeError('Perforce driver does not check for local changes before overriding', true);

return;
}




protected function getCommitLogs($fromReference, $toReference, $path)
{
$commitLogs = $this->perforce->getCommitLogs($fromReference, $toReference);

return $commitLogs;
}

public function setPerforce($perforce)
{
$this->perforce = $perforce;
}
}
<?php











namespace Composer\Downloader;






class PharDownloader extends ArchiveDownloader
{



protected function extract($file, $path)
{

 $archive = new \Phar($file);
$archive->extractTo($path, null, true);





}
}
<?php











namespace Composer\Downloader;

use Composer\Config;
use Composer\Cache;
use Composer\EventDispatcher\EventDispatcher;
use Composer\Util\ProcessExecutor;
use Composer\IO\IOInterface;
use RarArchive;








class RarDownloader extends ArchiveDownloader
{
protected $process;

public function __construct(IOInterface $io, Config $config, EventDispatcher $eventDispatcher = null, Cache $cache = null, ProcessExecutor $process = null)
{
$this->process = $process ?: new ProcessExecutor($io);
parent::__construct($io, $config, $eventDispatcher, $cache);
}

protected function extract($file, $path)
{
$processError = null;


 if (!defined('PHP_WINDOWS_VERSION_BUILD')) {
$command = 'unrar x ' . ProcessExecutor::escape($file) . ' ' . ProcessExecutor::escape($path) . ' && chmod -R u+w ' . ProcessExecutor::escape($path);

if (0 === $this->process->execute($command, $ignoredOutput)) {
return;
}

$processError = 'Failed to execute ' . $command . "\n\n" . $this->process->getErrorOutput();
}

if (!class_exists('RarArchive')) {

 $iniPath = php_ini_loaded_file();

if ($iniPath) {
$iniMessage = 'The php.ini used by your command-line PHP is: ' . $iniPath;
} else {
$iniMessage = 'A php.ini file does not exist. You will have to create one.';
}

$error = "Could not decompress the archive, enable the PHP rar extension or install unrar.\n"
. $iniMessage . "\n" . $processError;

if (!defined('PHP_WINDOWS_VERSION_BUILD')) {
$error = "Could not decompress the archive, enable the PHP rar extension.\n" . $iniMessage;
}

throw new \RuntimeException($error);
}

$rarArchive = RarArchive::open($file);

if (false === $rarArchive) {
throw new \UnexpectedValueException('Could not open RAR archive: ' . $file);
}

$entries = $rarArchive->getEntries();

if (false === $entries) {
throw new \RuntimeException('Could not retrieve RAR archive entries');
}

foreach ($entries as $entry) {
if (false === $entry->extract($path)) {
throw new \RuntimeException('Could not extract entry');
}
}

$rarArchive->close();
}
}
<?php











namespace Composer\Downloader;

use Composer\Package\PackageInterface;
use Composer\Util\Svn as SvnUtil;





class SvnDownloader extends VcsDownloader
{



public function doDownload(PackageInterface $package, $path, $url)
{
SvnUtil::cleanEnv();
$ref = $package->getSourceReference();

$this->io->writeError("    Checking out ".$package->getSourceReference());
$this->execute($url, "svn co", sprintf("%s/%s", $url, $ref), null, $path);
}




public function doUpdate(PackageInterface $initial, PackageInterface $target, $path, $url)
{
SvnUtil::cleanEnv();
$ref = $target->getSourceReference();

if (!is_dir($path.'/.svn')) {
throw new \RuntimeException('The .svn directory is missing from '.$path.', see https://getcomposer.org/commit-deps for more information');
}

$flags = "";
if (0 === $this->process->execute('svn --version', $output)) {
if (preg_match('{(\d+(?:\.\d+)+)}', $output, $match) && version_compare($match[1], '1.7.0', '>=')) {
$flags .= ' --ignore-ancestry';
}
}

$this->io->writeError("    Checking out " . $ref);
$this->execute($url, "svn switch" . $flags, sprintf("%s/%s", $url, $ref), $path);
}




public function getLocalChanges(PackageInterface $package, $path)
{
if (!is_dir($path.'/.svn')) {
return;
}

$this->process->execute('svn status --ignore-externals', $output, $path);

return preg_match('{^ *[^X ] +}m', $output) ? $output : null;
}













protected function execute($baseUrl, $command, $url, $cwd = null, $path = null)
{
$util = new SvnUtil($baseUrl, $this->io, $this->config);
try {
return $util->execute($command, $url, $cwd, $path, $this->io->isVerbose());
} catch (\RuntimeException $e) {
throw new \RuntimeException(
'Package could not be downloaded, '.$e->getMessage()
);
}
}




protected function cleanChanges(PackageInterface $package, $path, $update)
{
if (!$changes = $this->getLocalChanges($package, $path)) {
return;
}

if (!$this->io->isInteractive()) {
if (true === $this->config->get('discard-changes')) {
return $this->discardChanges($path);
}

return parent::cleanChanges($package, $path, $update);
}

$changes = array_map(function ($elem) {
return '    '.$elem;
}, preg_split('{\s*\r?\n\s*}', $changes));
$this->io->writeError('    <error>The package has modified files:</error>');
$this->io->writeError(array_slice($changes, 0, 10));
if (count($changes) > 10) {
$this->io->writeError('    <info>'.count($changes) - 10 . ' more files modified, choose "v" to view the full list</info>');
}

while (true) {
switch ($this->io->ask('    <info>Discard changes [y,n,v,?]?</info> ', '?')) {
case 'y':
$this->discardChanges($path);
break 2;

case 'n':
throw new \RuntimeException('Update aborted');

case 'v':
$this->io->writeError($changes);
break;

case '?':
default:
$this->io->writeError(array(
'    y - discard changes and apply the '.($update ? 'update' : 'uninstall'),
'    n - abort the '.($update ? 'update' : 'uninstall').' and let you manually clean things up',
'    v - view modified files',
'    ? - print help',
));
break;
}
}
}




protected function getCommitLogs($fromReference, $toReference, $path)
{
if (preg_match('{.*@(\d+)$}', $fromReference) && preg_match('{.*@(\d+)$}', $toReference) ) {

 $fromRevision = preg_replace('{.*@(\d+)$}', '$1', $fromReference);
$toRevision = preg_replace('{.*@(\d+)$}', '$1', $toReference);

$command = sprintf('svn log -r%s:%s --incremental', $fromRevision, $toRevision);

if (0 !== $this->process->execute($command, $output, $path)) {
throw new \RuntimeException(
'Failed to execute ' . $command . "\n\n" . $this->process->getErrorOutput()
);
}
} else {
$output = "Could not retrieve changes between $fromReference and $toReference due to missing revision information";
}

return $output;
}

protected function discardChanges($path)
{
if (0 !== $this->process->execute('svn revert -R .', $output, $path)) {
throw new \RuntimeException("Could not reset changes\n\n:".$this->process->getErrorOutput());
}
}
}
<?php











namespace Composer\Downloader;






class TarDownloader extends ArchiveDownloader
{



protected function extract($file, $path)
{

 $archive = new \PharData($file);
$archive->extractTo($path, null, true);
}
}
<?php











namespace Composer\Downloader;




class TransportException extends \RuntimeException
{
protected $headers;
protected $response;

public function setHeaders($headers)
{
$this->headers = $headers;
}

public function getHeaders()
{
return $this->headers;
}

public function setResponse($response)
{
$this->response = $response;
}

public function getResponse()
{
return $this->response;
}
}
<?php











namespace Composer\Downloader;

use Composer\Config;
use Composer\Package\PackageInterface;
use Composer\Package\Version\VersionParser;
use Composer\Util\ProcessExecutor;
use Composer\IO\IOInterface;
use Composer\Util\Filesystem;




abstract class VcsDownloader implements DownloaderInterface, ChangeReportInterface
{
protected $io;
protected $config;
protected $process;
protected $filesystem;

public function __construct(IOInterface $io, Config $config, ProcessExecutor $process = null, Filesystem $fs = null)
{
$this->io = $io;
$this->config = $config;
$this->process = $process ?: new ProcessExecutor($io);
$this->filesystem = $fs ?: new Filesystem;
}




public function getInstallationSource()
{
return 'source';
}




public function download(PackageInterface $package, $path)
{
if (!$package->getSourceReference()) {
throw new \InvalidArgumentException('Package '.$package->getPrettyName().' is missing reference information');
}

$this->io->writeError("  - Installing <info>" . $package->getName() . "</info> (<comment>" . VersionParser::formatVersion($package) . "</comment>)");
$this->filesystem->emptyDirectory($path);

$urls = $package->getSourceUrls();
while ($url = array_shift($urls)) {
try {
if (Filesystem::isLocalPath($url)) {
$url = realpath($url);
}
$this->doDownload($package, $path, $url);
break;
} catch (\Exception $e) {
if ($this->io->isDebug()) {
$this->io->writeError('Failed: ['.get_class($e).'] '.$e->getMessage());
} elseif (count($urls)) {
$this->io->writeError('    Failed, trying the next URL');
}
if (!count($urls)) {
throw $e;
}
}
}

$this->io->writeError('');
}




public function update(PackageInterface $initial, PackageInterface $target, $path)
{
if (!$target->getSourceReference()) {
throw new \InvalidArgumentException('Package '.$target->getPrettyName().' is missing reference information');
}

$name = $target->getName();
if ($initial->getPrettyVersion() == $target->getPrettyVersion()) {
if ($target->getSourceType() === 'svn') {
$from = $initial->getSourceReference();
$to = $target->getSourceReference();
} else {
$from = substr($initial->getSourceReference(), 0, 7);
$to = substr($target->getSourceReference(), 0, 7);
}
$name .= ' '.$initial->getPrettyVersion();
} else {
$from = VersionParser::formatVersion($initial);
$to = VersionParser::formatVersion($target);
}

$this->io->writeError("  - Updating <info>" . $name . "</info> (<comment>" . $from . "</comment> => <comment>" . $to . "</comment>)");

$this->cleanChanges($initial, $path, true);
$urls = $target->getSourceUrls();
while ($url = array_shift($urls)) {
try {
if (Filesystem::isLocalPath($url)) {
$url = realpath($url);
}
$this->doUpdate($initial, $target, $path, $url);
break;
} catch (\Exception $e) {
if ($this->io->isDebug()) {
$this->io->writeError('Failed: ['.get_class($e).'] '.$e->getMessage());
} elseif (count($urls)) {
$this->io->writeError('    Failed, trying the next URL');
} else {

 $this->reapplyChanges($path);

throw $e;
}
}
}

$this->reapplyChanges($path);


 if ($this->io->isVerbose()) {
$message = 'Pulling in changes:';
$logs = $this->getCommitLogs($initial->getSourceReference(), $target->getSourceReference(), $path);

if (!trim($logs)) {
$message = 'Rolling back changes:';
$logs = $this->getCommitLogs($target->getSourceReference(), $initial->getSourceReference(), $path);
}

if (trim($logs)) {
$logs = implode("\n", array_map(function ($line) {
return '      ' . $line;
}, explode("\n", $logs)));

$this->io->writeError('    '.$message);
$this->io->writeError($logs);
}
}

$this->io->writeError('');
}




public function remove(PackageInterface $package, $path)
{
$this->io->writeError("  - Removing <info>" . $package->getName() . "</info> (<comment>" . $package->getPrettyVersion() . "</comment>)");
$this->cleanChanges($package, $path, false);
if (!$this->filesystem->removeDirectory($path)) {
throw new \RuntimeException('Could not completely delete '.$path.', aborting.');
}
}





public function setOutputProgress($outputProgress)
{
return $this;
}










protected function cleanChanges(PackageInterface $package, $path, $update)
{

 if (null !== $this->getLocalChanges($package, $path)) {
throw new \RuntimeException('Source directory ' . $path . ' has uncommitted changes.');
}
}







protected function reapplyChanges($path)
{
}








abstract protected function doDownload(PackageInterface $package, $path, $url);









abstract protected function doUpdate(PackageInterface $initial, PackageInterface $target, $path, $url);









abstract protected function getCommitLogs($fromReference, $toReference, $path);
}
<?php











namespace Composer\Downloader;

use Composer\Config;
use Composer\Cache;
use Composer\EventDispatcher\EventDispatcher;
use Composer\Util\ProcessExecutor;
use Composer\IO\IOInterface;
use ZipArchive;




class ZipDownloader extends ArchiveDownloader
{
protected $process;

public function __construct(IOInterface $io, Config $config, EventDispatcher $eventDispatcher = null, Cache $cache = null, ProcessExecutor $process = null)
{
$this->process = $process ?: new ProcessExecutor($io);
parent::__construct($io, $config, $eventDispatcher, $cache);
}

protected function extract($file, $path)
{
$processError = null;


 if (!defined('PHP_WINDOWS_VERSION_BUILD')) {
$command = 'unzip '.ProcessExecutor::escape($file).' -d '.ProcessExecutor::escape($path) . ' && chmod -R u+w ' . ProcessExecutor::escape($path);
try {
if (0 === $this->process->execute($command, $ignoredOutput)) {
return;
}

$processError = 'Failed to execute ' . $command . "\n\n" . $this->process->getErrorOutput();
} catch (\Exception $e) {
$processError = 'Failed to execute ' . $command . "\n\n" . $e->getMessage();
}
}

if (!class_exists('ZipArchive')) {

 $iniPath = php_ini_loaded_file();

if ($iniPath) {
$iniMessage = 'The php.ini used by your command-line PHP is: ' . $iniPath;
} else {
$iniMessage = 'A php.ini file does not exist. You will have to create one.';
}

$error = "Could not decompress the archive, enable the PHP zip extension or install unzip.\n"
. $iniMessage . "\n" . $processError;

if (!defined('PHP_WINDOWS_VERSION_BUILD')) {
$error = "Could not decompress the archive, enable the PHP zip extension.\n" . $iniMessage;
}

throw new \RuntimeException($error);
}

$zipArchive = new ZipArchive();

if (true !== ($retval = $zipArchive->open($file))) {
throw new \UnexpectedValueException($this->getErrorMessage($retval, $file), $retval);
}

if (true !== $zipArchive->extractTo($path)) {
throw new \RuntimeException("There was an error extracting the ZIP file. Corrupt file?");
}

$zipArchive->close();
}








protected function getErrorMessage($retval, $file)
{
switch ($retval) {
case ZipArchive::ER_EXISTS:
return sprintf("File '%s' already exists.", $file);
case ZipArchive::ER_INCONS:
return sprintf("Zip archive '%s' is inconsistent.", $file);
case ZipArchive::ER_INVAL:
return sprintf("Invalid argument (%s)", $file);
case ZipArchive::ER_MEMORY:
return sprintf("Malloc failure (%s)", $file);
case ZipArchive::ER_NOENT:
return sprintf("No such zip file: '%s'", $file);
case ZipArchive::ER_NOZIP:
return sprintf("'%s' is not a zip archive.", $file);
case ZipArchive::ER_OPEN:
return sprintf("Can't open zip file: %s", $file);
case ZipArchive::ER_READ:
return sprintf("Zip read error (%s)", $file);
case ZipArchive::ER_SEEK:
return sprintf("Zip seek error (%s)", $file);
default:
return sprintf("'%s' is not a valid zip archive, got error code: %s", $file, $retval);
}
}
}
<?php











namespace Composer\EventDispatcher;






class Event
{



protected $name;




protected $args;




protected $flags;




private $propagationStopped = false;








public function __construct($name, array $args = array(), array $flags = array())
{
$this->name = $name;
$this->args = $args;
$this->flags = $flags;
}






public function getName()
{
return $this->name;
}






public function getArguments()
{
return $this->args;
}






public function getFlags()
{
return $this->flags;
}






public function isPropagationStopped()
{
return $this->propagationStopped;
}




public function stopPropagation()
{
$this->propagationStopped = true;
}
}
<?php











namespace Composer\EventDispatcher;

use Composer\DependencyResolver\PolicyInterface;
use Composer\DependencyResolver\Pool;
use Composer\DependencyResolver\Request;
use Composer\Installer\InstallerEvent;
use Composer\IO\IOInterface;
use Composer\Composer;
use Composer\DependencyResolver\Operation\OperationInterface;
use Composer\Repository\CompositeRepository;
use Composer\Script;
use Composer\Script\PackageEvent;
use Composer\Util\ProcessExecutor;














class EventDispatcher
{
protected $composer;
protected $io;
protected $loader;
protected $process;
protected $listeners;








public function __construct(Composer $composer, IOInterface $io, ProcessExecutor $process = null)
{
$this->composer = $composer;
$this->io = $io;
$this->process = $process ?: new ProcessExecutor($io);
}









public function dispatch($eventName, Event $event = null)
{
if (null == $event) {
$event = new Event($eventName);
}

return $this->doDispatch($event);
}











public function dispatchScript($eventName, $devMode = false, $additionalArgs = array(), $flags = array())
{
return $this->doDispatch(new Script\Event($eventName, $this->composer, $this->io, $devMode, $additionalArgs, $flags));
}
















public function dispatchPackageEvent($eventName, $devMode, PolicyInterface $policy, Pool $pool, CompositeRepository $installedRepo, Request $request, array $operations, OperationInterface $operation)
{
return $this->doDispatch(new PackageEvent($eventName, $this->composer, $this->io, $devMode, $policy, $pool, $installedRepo, $request, $operations, $operation));
}















public function dispatchInstallerEvent($eventName, $devMode, PolicyInterface $policy, Pool $pool, CompositeRepository $installedRepo, Request $request, array $operations = array())
{
return $this->doDispatch(new InstallerEvent($eventName, $this->composer, $this->io, $devMode, $policy, $pool, $installedRepo, $request, $operations));
}











protected function doDispatch(Event $event)
{
$listeners = $this->getListeners($event);

$return = 0;
foreach ($listeners as $callable) {
if (!is_string($callable) && is_callable($callable)) {
$event = $this->checkListenerExpectedEvent($callable, $event);
$return = false === call_user_func($callable, $event) ? 1 : 0;
} elseif ($this->isPhpScript($callable)) {
$className = substr($callable, 0, strpos($callable, '::'));
$methodName = substr($callable, strpos($callable, '::') + 2);

if (!class_exists($className)) {
$this->io->writeError('<warning>Class '.$className.' is not autoloadable, can not call '.$event->getName().' script</warning>');
continue;
}
if (!is_callable($callable)) {
$this->io->writeError('<warning>Method '.$callable.' is not callable, can not call '.$event->getName().' script</warning>');
continue;
}

try {
$return = false === $this->executeEventPhpScript($className, $methodName, $event) ? 1 : 0;
} catch (\Exception $e) {
$message = "Script %s handling the %s event terminated with an exception";
$this->io->writeError('<error>'.sprintf($message, $callable, $event->getName()).'</error>');
throw $e;
}
} else {
$args = implode(' ', array_map(array('Composer\Util\ProcessExecutor','escape'), $event->getArguments()));
if (0 !== ($exitCode = $this->process->execute($callable . ($args === '' ? '' : ' '.$args)))) {
$this->io->writeError(sprintf('<error>Script %s handling the %s event returned with an error</error>', $callable, $event->getName()));

throw new \RuntimeException('Error Output: '.$this->process->getErrorOutput(), $exitCode);
}
}

if ($event->isPropagationStopped()) {
break;
}
}

return $return;
}






protected function executeEventPhpScript($className, $methodName, Event $event)
{
$event = $this->checkListenerExpectedEvent(array($className, $methodName), $event);

return $className::$methodName($event);
}






protected function checkListenerExpectedEvent($target, Event $event)
{
try {
$reflected = new \ReflectionParameter($target, 0);
} catch (\Exception $e) {
return $event;
}

$typehint = $reflected->getClass();

if (!$typehint instanceof \ReflectionClass) {
return $event;
}

$expected = $typehint->getName();


 if (!$event instanceof $expected && $expected === 'Composer\Script\CommandEvent') {
$event = new \Composer\Script\CommandEvent(
$event->getName(), $event->getComposer(), $event->getIO(), $event->isDevMode(), $event->getArguments()
);
}
if (!$event instanceof $expected && $expected === 'Composer\Script\PackageEvent') {
$event = new \Composer\Script\PackageEvent(
$event->getName(), $event->getComposer(), $event->getIO(), $event->isDevMode(),
$event->getPolicy(), $event->getPool(), $event->getInstalledRepo(), $event->getRequest(),
$event->getOperations(), $event->getOperation()
);
}
if (!$event instanceof $expected && $expected === 'Composer\Script\Event') {
$event = new \Composer\Script\Event(
$event->getName(), $event->getComposer(), $event->getIO(), $event->isDevMode(),
$event->getArguments(), $event->getFlags()
);
}

return $event;
}








protected function addListener($eventName, $listener, $priority = 0)
{
$this->listeners[$eventName][$priority][] = $listener;
}








public function addSubscriber(EventSubscriberInterface $subscriber)
{
foreach ($subscriber->getSubscribedEvents() as $eventName => $params) {
if (is_string($params)) {
$this->addListener($eventName, array($subscriber, $params));
} elseif (is_string($params[0])) {
$this->addListener($eventName, array($subscriber, $params[0]), isset($params[1]) ? $params[1] : 0);
} else {
foreach ($params as $listener) {
$this->addListener($eventName, array($subscriber, $listener[0]), isset($listener[1]) ? $listener[1] : 0);
}
}
}
}







protected function getListeners(Event $event)
{
$scriptListeners = $this->getScriptListeners($event);

if (!isset($this->listeners[$event->getName()][0])) {
$this->listeners[$event->getName()][0] = array();
}
krsort($this->listeners[$event->getName()]);

$listeners = $this->listeners;
$listeners[$event->getName()][0] = array_merge($listeners[$event->getName()][0], $scriptListeners);

return call_user_func_array('array_merge', $listeners[$event->getName()]);
}







public function hasEventListeners(Event $event)
{
$listeners = $this->getListeners($event);

return count($listeners) > 0;
}







protected function getScriptListeners(Event $event)
{
$package = $this->composer->getPackage();
$scripts = $package->getScripts();

if (empty($scripts[$event->getName()])) {
return array();
}

if ($this->loader) {
$this->loader->unregister();
}

$generator = $this->composer->getAutoloadGenerator();
$packages = $this->composer->getRepositoryManager()->getLocalRepository()->getCanonicalPackages();
$packageMap = $generator->buildPackageMap($this->composer->getInstallationManager(), $package, $packages);
$map = $generator->parseAutoloads($packageMap, $package);
$this->loader = $generator->createLoader($map);
$this->loader->register();

return $scripts[$event->getName()];
}







protected function isPhpScript($callable)
{
return false === strpos($callable, ' ') && false !== strpos($callable, '::');
}
}
<?php











namespace Composer\EventDispatcher;













interface EventSubscriberInterface
{


















public static function getSubscribedEvents();
}
<?php











namespace Composer;

use Composer\Config\JsonConfigSource;
use Composer\Json\JsonFile;
use Composer\IO\IOInterface;
use Composer\Package\Archiver;
use Composer\Repository\RepositoryManager;
use Composer\Repository\WritableRepositoryInterface;
use Composer\Util\ProcessExecutor;
use Composer\Util\RemoteFilesystem;
use Symfony\Component\Console\Formatter\OutputFormatterStyle;
use Composer\EventDispatcher\EventDispatcher;
use Composer\Autoload\AutoloadGenerator;
use Composer\Package\Version\VersionParser;









class Factory
{




protected static function getHomeDir()
{
$home = getenv('COMPOSER_HOME');
if (!$home) {
if (defined('PHP_WINDOWS_VERSION_MAJOR')) {
if (!getenv('APPDATA')) {
throw new \RuntimeException('The APPDATA or COMPOSER_HOME environment variable must be set for composer to run correctly');
}
$home = strtr(getenv('APPDATA'), '\\', '/') . '/Composer';
} else {
if (!getenv('HOME')) {
throw new \RuntimeException('The HOME or COMPOSER_HOME environment variable must be set for composer to run correctly');
}
$home = rtrim(getenv('HOME'), '/') . '/.composer';
}
}

return $home;
}






protected static function getCacheDir($home)
{
$cacheDir = getenv('COMPOSER_CACHE_DIR');
if (!$cacheDir) {
if (defined('PHP_WINDOWS_VERSION_MAJOR')) {
if ($cacheDir = getenv('LOCALAPPDATA')) {
$cacheDir .= '/Composer';
} else {
$cacheDir = $home . '/cache';
}
$cacheDir = strtr($cacheDir, '\\', '/');
} else {
$cacheDir = $home.'/cache';
}
}

return $cacheDir;
}





public static function createConfig(IOInterface $io = null, $cwd = null)
{
$cwd = $cwd ?: getcwd();


 $home = self::getHomeDir();
$cacheDir = self::getCacheDir($home);


 
 
 foreach (array($home, $cacheDir) as $dir) {
if (!file_exists($dir . '/.htaccess')) {
if (!is_dir($dir)) {
@mkdir($dir, 0777, true);
}
@file_put_contents($dir . '/.htaccess', 'Deny from all');
}
}

$config = new Config(true, $cwd);


 $config->merge(array('config' => array('home' => $home, 'cache-dir' => $cacheDir)));


 $file = new JsonFile($config->get('home').'/config.json');
if ($file->exists()) {
if ($io && $io->isDebug()) {
$io->writeError('Loading config file ' . $file->getPath());
}
$config->merge($file->read());
}
$config->setConfigSource(new JsonConfigSource($file));


 $file = new JsonFile($config->get('home').'/auth.json');
if ($file->exists()) {
if ($io && $io->isDebug()) {
$io->writeError('Loading config file ' . $file->getPath());
}
$config->merge(array('config' => $file->read()));
}
$config->setAuthConfigSource(new JsonConfigSource($file, true));

return $config;
}

public static function getComposerFile()
{
return trim(getenv('COMPOSER')) ?: './composer.json';
}

public static function createAdditionalStyles()
{
return array(
'highlight' => new OutputFormatterStyle('red'),
'warning' => new OutputFormatterStyle('black', 'yellow'),
);
}

public static function createDefaultRepositories(IOInterface $io = null, Config $config = null, RepositoryManager $rm = null)
{
$repos = array();

if (!$config) {
$config = static::createConfig($io);
}
if (!$rm) {
if (!$io) {
throw new \InvalidArgumentException('This function requires either an IOInterface or a RepositoryManager');
}
$factory = new static;
$rm = $factory->createRepositoryManager($io, $config);
}

foreach ($config->getRepositories() as $index => $repo) {
if (is_string($repo)) {
throw new \UnexpectedValueException('"repositories" should be an array of repository definitions, only a single repository was given');
}
if (!is_array($repo)) {
throw new \UnexpectedValueException('Repository "'.$index.'" ('.json_encode($repo).') should be an array, '.gettype($repo).' given');
}
if (!isset($repo['type'])) {
throw new \UnexpectedValueException('Repository "'.$index.'" ('.json_encode($repo).') must have a type defined');
}
$name = is_int($index) && isset($repo['url']) ? preg_replace('{^https?://}i', '', $repo['url']) : $index;
while (isset($repos[$name])) {
$name .= '2';
}
$repos[$name] = $rm->createRepository($repo['type'], $repo);
}

return $repos;
}













public function createComposer(IOInterface $io, $localConfig = null, $disablePlugins = false, $cwd = null, $fullLoad = true)
{
$cwd = $cwd ?: getcwd();


 if (null === $localConfig) {
$localConfig = static::getComposerFile();
}

if (is_string($localConfig)) {
$composerFile = $localConfig;
$file = new JsonFile($localConfig, new RemoteFilesystem($io));

if (!$file->exists()) {
if ($localConfig === './composer.json' || $localConfig === 'composer.json') {
$message = 'Composer could not find a composer.json file in '.$cwd;
} else {
$message = 'Composer could not find the config file: '.$localConfig;
}
$instructions = 'To initialize a project, please create a composer.json file as described in the https://getcomposer.org/ "Getting Started" section';
throw new \InvalidArgumentException($message.PHP_EOL.$instructions);
}

$file->validateSchema(JsonFile::LAX_SCHEMA);
$localConfig = $file->read();
}


 $config = static::createConfig($io, $cwd);
$config->merge($localConfig);
if (isset($composerFile)) {
if ($io && $io->isDebug()) {
$io->writeError('Loading config file ' . $composerFile);
}
$localAuthFile = new JsonFile(dirname(realpath($composerFile)) . '/auth.json');
if ($localAuthFile->exists()) {
if ($io && $io->isDebug()) {
$io->writeError('Loading config file ' . $localAuthFile->getPath());
}
$config->merge(array('config' => $localAuthFile->read()));
$config->setAuthConfigSource(new JsonConfigSource($localAuthFile, true));
}
}

$vendorDir = $config->get('vendor-dir');
$binDir = $config->get('bin-dir');


 $composer = new Composer();
$composer->setConfig($config);

if ($fullLoad) {

 $io->loadConfiguration($config);
}


 $dispatcher = new EventDispatcher($composer, $io);
$composer->setEventDispatcher($dispatcher);


 $rm = $this->createRepositoryManager($io, $config, $dispatcher);
$composer->setRepositoryManager($rm);


 $this->addLocalRepository($rm, $vendorDir);


 $parser = new VersionParser;
$loader = new Package\Loader\RootPackageLoader($rm, $config, $parser, new ProcessExecutor($io));
$package = $loader->load($localConfig);
$composer->setPackage($package);


 $im = $this->createInstallationManager();
$composer->setInstallationManager($im);

if ($fullLoad) {

 $dm = $this->createDownloadManager($io, $config, $dispatcher);
$composer->setDownloadManager($dm);


 $generator = new AutoloadGenerator($dispatcher, $io);
$composer->setAutoloadGenerator($generator);
}


 $this->createDefaultInstallers($im, $composer, $io);

if ($fullLoad) {
$globalComposer = $this->createGlobalComposer($io, $config, $disablePlugins);
$pm = $this->createPluginManager($io, $composer, $globalComposer);
$composer->setPluginManager($pm);

if (!$disablePlugins) {
$pm->loadInstalledPlugins();
}


 
 if ($rm->getLocalRepository()) {
$this->purgePackages($rm->getLocalRepository(), $im);
}
}


 if ($fullLoad && isset($composerFile)) {
$lockFile = "json" === pathinfo($composerFile, PATHINFO_EXTENSION)
? substr($composerFile, 0, -4).'lock'
: $composerFile . '.lock';
$locker = new Package\Locker($io, new JsonFile($lockFile, new RemoteFilesystem($io, $config)), $rm, $im, md5_file($composerFile));
$composer->setLocker($locker);
}

return $composer;
}







protected function createRepositoryManager(IOInterface $io, Config $config, EventDispatcher $eventDispatcher = null)
{
$rm = new RepositoryManager($io, $config, $eventDispatcher);
$rm->setRepositoryClass('composer', 'Composer\Repository\ComposerRepository');
$rm->setRepositoryClass('vcs', 'Composer\Repository\VcsRepository');
$rm->setRepositoryClass('package', 'Composer\Repository\PackageRepository');
$rm->setRepositoryClass('pear', 'Composer\Repository\PearRepository');
$rm->setRepositoryClass('git', 'Composer\Repository\VcsRepository');
$rm->setRepositoryClass('svn', 'Composer\Repository\VcsRepository');
$rm->setRepositoryClass('perforce', 'Composer\Repository\VcsRepository');
$rm->setRepositoryClass('hg', 'Composer\Repository\VcsRepository');
$rm->setRepositoryClass('artifact', 'Composer\Repository\ArtifactRepository');

return $rm;
}





protected function addLocalRepository(RepositoryManager $rm, $vendorDir)
{
$rm->setLocalRepository(new Repository\InstalledFilesystemRepository(new JsonFile($vendorDir.'/composer/installed.json')));
}





protected function createGlobalComposer(IOInterface $io, Config $config, $disablePlugins)
{
if (realpath($config->get('home')) === getcwd()) {
return;
}

$composer = null;
try {
$composer = self::createComposer($io, $config->get('home') . '/composer.json', $disablePlugins, $config->get('home'), false);
} catch (\Exception $e) {
if ($io->isDebug()) {
$io->writeError('Failed to initialize global composer: '.$e->getMessage());
}
}

return $composer;
}







public function createDownloadManager(IOInterface $io, Config $config, EventDispatcher $eventDispatcher = null)
{
$cache = null;
if ($config->get('cache-files-ttl') > 0) {
$cache = new Cache($io, $config->get('cache-files-dir'), 'a-z0-9_./');
}

$dm = new Downloader\DownloadManager($io);
switch ($config->get('preferred-install')) {
case 'dist':
$dm->setPreferDist(true);
break;
case 'source':
$dm->setPreferSource(true);
break;
case 'auto':
default:

 break;
}

$dm->setDownloader('git', new Downloader\GitDownloader($io, $config));
$dm->setDownloader('svn', new Downloader\SvnDownloader($io, $config));
$dm->setDownloader('hg', new Downloader\HgDownloader($io, $config));
$dm->setDownloader('perforce', new Downloader\PerforceDownloader($io, $config));
$dm->setDownloader('zip', new Downloader\ZipDownloader($io, $config, $eventDispatcher, $cache));
$dm->setDownloader('rar', new Downloader\RarDownloader($io, $config, $eventDispatcher, $cache));
$dm->setDownloader('tar', new Downloader\TarDownloader($io, $config, $eventDispatcher, $cache));
$dm->setDownloader('gzip', new Downloader\GzipDownloader($io, $config, $eventDispatcher, $cache));
$dm->setDownloader('phar', new Downloader\PharDownloader($io, $config, $eventDispatcher, $cache));
$dm->setDownloader('file', new Downloader\FileDownloader($io, $config, $eventDispatcher, $cache));

return $dm;
}







public function createArchiveManager(Config $config, Downloader\DownloadManager $dm = null)
{
if (null === $dm) {
$io = new IO\NullIO();
$io->loadConfiguration($config);
$dm = $this->createDownloadManager($io, $config);
}

$am = new Archiver\ArchiveManager($dm);
$am->addArchiver(new Archiver\PharArchiver);

return $am;
}







protected function createPluginManager(IOInterface $io, Composer $composer, Composer $globalComposer = null)
{
return new Plugin\PluginManager($io, $composer, $globalComposer);
}




protected function createInstallationManager()
{
return new Installer\InstallationManager();
}






protected function createDefaultInstallers(Installer\InstallationManager $im, Composer $composer, IOInterface $io)
{
$im->addInstaller(new Installer\LibraryInstaller($io, $composer, null));
$im->addInstaller(new Installer\PearInstaller($io, $composer, 'pear-library'));
$im->addInstaller(new Installer\PluginInstaller($io, $composer));
$im->addInstaller(new Installer\MetapackageInstaller($io));
}





protected function purgePackages(WritableRepositoryInterface $repo, Installer\InstallationManager $im)
{
foreach ($repo->getPackages() as $package) {
if (!$im->isPackageInstalled($repo, $package)) {
$repo->removePackage($package);
}
}
}








public static function create(IOInterface $io, $config = null, $disablePlugins = false)
{
$factory = new static();

return $factory->createComposer($io, $config, $disablePlugins);
}
}
<?php











namespace Composer\IO;

use Composer\Config;
use Composer\Util\ProcessExecutor;

abstract class BaseIO implements IOInterface
{
protected $authentications = array();




public function getAuthentications()
{
return $this->authentications;
}




public function hasAuthentication($repositoryName)
{
return isset($this->authentications[$repositoryName]);
}




public function getAuthentication($repositoryName)
{
if (isset($this->authentications[$repositoryName])) {
return $this->authentications[$repositoryName];
}

return array('username' => null, 'password' => null);
}




public function setAuthentication($repositoryName, $username, $password = null)
{
$this->authentications[$repositoryName] = array('username' => $username, 'password' => $password);
}




public function loadConfiguration(Config $config)
{

 if ($tokens = $config->get('github-oauth')) {
foreach ($tokens as $domain => $token) {
if (!preg_match('{^[a-z0-9]+$}', $token)) {
throw new \UnexpectedValueException('Your github oauth token for '.$domain.' contains invalid characters: "'.$token.'"');
}
$this->setAuthentication($domain, $token, 'x-oauth-basic');
}
}


 if ($creds = $config->get('http-basic')) {
foreach ($creds as $domain => $cred) {
$this->setAuthentication($domain, $cred['username'], $cred['password']);
}
}


 ProcessExecutor::setTimeout((int) $config->get('process-timeout'));
}
}
<?php











namespace Composer\IO;

use Symfony\Component\Console\Output\StreamOutput;
use Symfony\Component\Console\Formatter\OutputFormatterInterface;
use Symfony\Component\Console\Input\StringInput;
use Symfony\Component\Console\Helper\HelperSet;




class BufferIO extends ConsoleIO
{





public function __construct(
$input = '',
$verbosity = StreamOutput::VERBOSITY_NORMAL,
OutputFormatterInterface $formatter = null
) {
$input = new StringInput($input);
$input->setInteractive(false);

$output = new StreamOutput(fopen('php://memory', 'rw'), $verbosity, !empty($formatter), $formatter);

parent::__construct($input, $output, new HelperSet(array()));
}

public function getOutput()
{
fseek($this->output->getStream(), 0);

$output = stream_get_contents($this->output->getStream());

$output = preg_replace_callback("{(?<=^|\n|\x08)(.+?)(\x08+)}", function ($matches) {
$pre = strip_tags($matches[1]);

if (strlen($pre) === strlen($matches[2])) {
return '';
}


 return rtrim($matches[1])."\n";
}, $output);

return $output;
}
}
<?php











namespace Composer\IO;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\ConsoleOutputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Helper\HelperSet;
use Symfony\Component\Console\Question\ConfirmationQuestion;
use Symfony\Component\Console\Question\Question;
use Symfony\Component\Process\ExecutableFinder;







class ConsoleIO extends BaseIO
{
protected $input;
protected $output;
protected $helperSet;
protected $lastMessage;
protected $lastMessageErr;
private $startTime;








public function __construct(InputInterface $input, OutputInterface $output, HelperSet $helperSet)
{
$this->input = $input;
$this->output = $output;
$this->helperSet = $helperSet;
}

public function enableDebugging($startTime)
{
$this->startTime = $startTime;
}




public function isInteractive()
{
return $this->input->isInteractive();
}




public function isDecorated()
{
return $this->output->isDecorated();
}




public function isVerbose()
{
return $this->output->getVerbosity() >= OutputInterface::VERBOSITY_VERBOSE;
}




public function isVeryVerbose()
{
return $this->output->getVerbosity() >= OutputInterface::VERBOSITY_VERY_VERBOSE;
}




public function isDebug()
{
return $this->output->getVerbosity() >= OutputInterface::VERBOSITY_DEBUG;
}




public function write($messages, $newline = true)
{
$this->doWrite($messages, $newline, false);
}




public function writeError($messages, $newline = true)
{
$this->doWrite($messages, $newline, true);
}






private function doWrite($messages, $newline, $stderr)
{
if (null !== $this->startTime) {
$memoryUsage = memory_get_usage() / 1024 / 1024;
$timeSpent = microtime(true) - $this->startTime;
$messages = array_map(function ($message) use ($memoryUsage, $timeSpent) {
return sprintf('[%.1fMB/%.2fs] %s', $memoryUsage, $timeSpent, $message);
}, (array) $messages);
}

if (true === $stderr && $this->output instanceof ConsoleOutputInterface) {
$this->output->getErrorOutput()->write($messages, $newline);
$this->lastMessageErr = join($newline ? "\n" : '', (array) $messages);

return;
}

$this->output->write($messages, $newline);
$this->lastMessage = join($newline ? "\n" : '', (array) $messages);
}




public function overwrite($messages, $newline = true, $size = null)
{
$this->doOverwrite($messages, $newline, $size, false);
}




public function overwriteError($messages, $newline = true, $size = null)
{
$this->doOverwrite($messages, $newline, $size, true);
}







private function doOverwrite($messages, $newline, $size, $stderr)
{

 $messages = join($newline ? "\n" : '', (array) $messages);


 if (!isset($size)) {

 $size = strlen(strip_tags($stderr ? $this->lastMessageErr : $this->lastMessage));
}

 $this->doWrite(str_repeat("\x08", $size), false, $stderr);


 $this->doWrite($messages, false, $stderr);

$fill = $size - strlen(strip_tags($messages));
if ($fill > 0) {

 $this->doWrite(str_repeat(' ', $fill), false, $stderr);

 $this->doWrite(str_repeat("\x08", $fill), false, $stderr);
}

if ($newline) {
$this->doWrite('', true, $stderr);
}

if ($stderr) {
$this->lastMessageErr = $messages;
} else {
$this->lastMessage = $messages;
}
}




public function ask($question, $default = null)
{
$output = $this->output;

if ($output instanceof ConsoleOutputInterface) {
$output = $output->getErrorOutput();
}


$helper = $this->helperSet->get('question');
$question = new Question($question, $default);

return $helper->ask($this->input, $output, $question);
}




public function askConfirmation($question, $default = true)
{
$output = $this->output;

if ($output instanceof ConsoleOutputInterface) {
$output = $output->getErrorOutput();
}


$helper = $this->helperSet->get('question');
$question = new ConfirmationQuestion($question, $default);

return $helper->ask($this->input, $output, $question);
}




public function askAndValidate($question, $validator, $attempts = null, $default = null)
{
$output = $this->output;

if ($output instanceof ConsoleOutputInterface) {
$output = $output->getErrorOutput();
}


$helper = $this->helperSet->get('question');
$question = new Question($question, $default);
$question->setValidator($validator);
$question->setMaxAttempts($attempts);

return $helper->ask($this->input, $output, $question);
}




public function askAndHideAnswer($question)
{
$this->writeError($question, false);

return \Seld\CliPrompt\CliPrompt::hiddenPrompt(true);
}
}
<?php











namespace Composer\IO;

use Composer\Config;






interface IOInterface
{





public function isInteractive();






public function isVerbose();






public function isVeryVerbose();






public function isDebug();






public function isDecorated();







public function write($messages, $newline = true);







public function writeError($messages, $newline = true);








public function overwrite($messages, $newline = true, $size = null);








public function overwriteError($messages, $newline = true, $size = null);











public function ask($question, $default = null);











public function askConfirmation($question, $default = true);

















public function askAndValidate($question, $validator, $attempts = null, $default = null);








public function askAndHideAnswer($question);






public function getAuthentications();








public function hasAuthentication($repositoryName);








public function getAuthentication($repositoryName);








public function setAuthentication($repositoryName, $username, $password = null);






public function loadConfiguration(Config $config);
}
<?php











namespace Composer\IO;






class NullIO extends BaseIO
{



public function isInteractive()
{
return false;
}




public function isVerbose()
{
return false;
}




public function isVeryVerbose()
{
return false;
}




public function isDebug()
{
return false;
}




public function isDecorated()
{
return false;
}




public function write($messages, $newline = true)
{
}




public function writeError($messages, $newline = true)
{
}




public function overwrite($messages, $newline = true, $size = 80)
{
}




public function overwriteError($messages, $newline = true, $size = 80)
{
}




public function ask($question, $default = null)
{
return $default;
}




public function askConfirmation($question, $default = true)
{
return $default;
}




public function askAndValidate($question, $validator, $attempts = false, $default = null)
{
return $default;
}




public function askAndHideAnswer($question)
{
return null;
}
}
<?php











namespace Composer;

use Composer\Autoload\AutoloadGenerator;
use Composer\DependencyResolver\DefaultPolicy;
use Composer\DependencyResolver\Operation\UpdateOperation;
use Composer\DependencyResolver\Operation\InstallOperation;
use Composer\DependencyResolver\Operation\UninstallOperation;
use Composer\DependencyResolver\Operation\OperationInterface;
use Composer\DependencyResolver\Pool;
use Composer\DependencyResolver\Request;
use Composer\DependencyResolver\Rule;
use Composer\DependencyResolver\Solver;
use Composer\DependencyResolver\SolverProblemsException;
use Composer\Downloader\DownloadManager;
use Composer\EventDispatcher\EventDispatcher;
use Composer\Installer\InstallationManager;
use Composer\Installer\InstallerEvents;
use Composer\Installer\NoopInstaller;
use Composer\IO\IOInterface;
use Composer\Json\JsonFile;
use Composer\Package\AliasPackage;
use Composer\Package\CompletePackage;
use Composer\Package\Link;
use Composer\Package\LinkConstraint\VersionConstraint;
use Composer\Package\Locker;
use Composer\Package\PackageInterface;
use Composer\Package\RootPackageInterface;
use Composer\Repository\CompositeRepository;
use Composer\Repository\InstalledArrayRepository;
use Composer\Repository\InstalledFilesystemRepository;
use Composer\Repository\PlatformRepository;
use Composer\Repository\RepositoryInterface;
use Composer\Repository\RepositoryManager;
use Composer\Script\ScriptEvents;







class Installer
{



protected $io;




protected $config;




protected $package;




protected $downloadManager;




protected $repositoryManager;




protected $locker;




protected $installationManager;




protected $eventDispatcher;




protected $autoloadGenerator;

protected $preferSource = false;
protected $preferDist = false;
protected $optimizeAutoloader = false;
protected $devMode = false;
protected $dryRun = false;
protected $verbose = false;
protected $update = false;
protected $dumpAutoloader = true;
protected $runScripts = true;
protected $ignorePlatformReqs = false;
protected $preferStable = false;
protected $preferLowest = false;





protected $updateWhitelist = null;
protected $whitelistDependencies = false;




protected $suggestedPackages;




protected $additionalInstalledRepository;














public function __construct(IOInterface $io, Config $config, RootPackageInterface $package, DownloadManager $downloadManager, RepositoryManager $repositoryManager, Locker $locker, InstallationManager $installationManager, EventDispatcher $eventDispatcher, AutoloadGenerator $autoloadGenerator)
{
$this->io = $io;
$this->config = $config;
$this->package = $package;
$this->downloadManager = $downloadManager;
$this->repositoryManager = $repositoryManager;
$this->locker = $locker;
$this->installationManager = $installationManager;
$this->eventDispatcher = $eventDispatcher;
$this->autoloadGenerator = $autoloadGenerator;
}








public function run()
{
gc_collect_cycles();
gc_disable();

if ($this->dryRun) {
$this->verbose = true;
$this->runScripts = false;
$this->installationManager->addInstaller(new NoopInstaller);
$this->mockLocalRepositories($this->repositoryManager);
}


 
 $devRepo = new InstalledFilesystemRepository(new JsonFile($this->config->get('vendor-dir').'/composer/installed_dev.json'));
if ($devRepo->getPackages()) {
$this->io->writeError('<warning>BC Notice: Removing old dev packages to migrate to the new require-dev handling.</warning>');
foreach ($devRepo->getPackages() as $package) {
if ($this->installationManager->isPackageInstalled($devRepo, $package)) {
$this->installationManager->uninstall($devRepo, new UninstallOperation($package));
}
}
unlink($this->config->get('vendor-dir').'/composer/installed_dev.json');
}
unset($devRepo, $package);


if ($this->runScripts) {

 $eventName = $this->update ? ScriptEvents::PRE_UPDATE_CMD : ScriptEvents::PRE_INSTALL_CMD;
$this->eventDispatcher->dispatchScript($eventName, $this->devMode);
}

$this->downloadManager->setPreferSource($this->preferSource);
$this->downloadManager->setPreferDist($this->preferDist);


 
 
 $installedRootPackage = clone $this->package;
$installedRootPackage->setRequires(array());
$installedRootPackage->setDevRequires(array());


 $localRepo = $this->repositoryManager->getLocalRepository();
if (!$this->update && $this->locker->isLocked()) {
$platformOverrides = $this->locker->getPlatformOverrides();
} else {
$platformOverrides = $this->config->get('platform') ?: array();
}
$platformRepo = new PlatformRepository(array(), $platformOverrides);
$repos = array(
$localRepo,
new InstalledArrayRepository(array($installedRootPackage)),
$platformRepo,
);
$installedRepo = new CompositeRepository($repos);
if ($this->additionalInstalledRepository) {
$installedRepo->addRepository($this->additionalInstalledRepository);
}

$aliases = $this->getRootAliases();
$this->aliasPlatformPackages($platformRepo, $aliases);

try {
$this->suggestedPackages = array();
$res = $this->doInstall($localRepo, $installedRepo, $platformRepo, $aliases, $this->devMode);
if ($res !== 0) {
return $res;
}
} catch (\Exception $e) {
$this->installationManager->notifyInstalls();

throw $e;
}
$this->installationManager->notifyInstalls();


 if ($this->devMode) {
foreach ($this->suggestedPackages as $suggestion) {
$target = $suggestion['target'];
foreach ($installedRepo->getPackages() as $package) {
if (in_array($target, $package->getNames())) {
continue 2;
}
}

$this->io->writeError($suggestion['source'].' suggests installing '.$suggestion['target'].' ('.$suggestion['reason'].')');
}
}


 foreach ($localRepo->getPackages() as $package) {
if (!$package instanceof CompletePackage || !$package->isAbandoned()) {
continue;
}

$replacement = (is_string($package->getReplacementPackage()))
? 'Use ' . $package->getReplacementPackage() . ' instead'
: 'No replacement was suggested';

$this->io->writeError(
sprintf(
"<warning>Package %s is abandoned, you should avoid using it. %s.</warning>",
$package->getPrettyName(),
$replacement
)
);
}

if (!$this->dryRun) {

 if ($this->update || !$this->locker->isLocked()) {
$localRepo->reload();


 
 $devPackages = ($this->devMode || !$this->package->getDevRequires()) ? array() : null;


 if ($this->devMode && $this->package->getDevRequires()) {
$policy = $this->createPolicy();
$pool = $this->createPool(true);
$pool->addRepository($installedRepo, $aliases);


 $request = $this->createRequest($this->package, $platformRepo);
$request->updateAll();
foreach ($this->package->getRequires() as $link) {
$request->install($link->getTarget(), $link->getConstraint());
}

$this->eventDispatcher->dispatchInstallerEvent(InstallerEvents::PRE_DEPENDENCIES_SOLVING, false, $policy, $pool, $installedRepo, $request);
$solver = new Solver($policy, $pool, $installedRepo);
$ops = $solver->solve($request, $this->ignorePlatformReqs);
$this->eventDispatcher->dispatchInstallerEvent(InstallerEvents::POST_DEPENDENCIES_SOLVING, false, $policy, $pool, $installedRepo, $request, $ops);
foreach ($ops as $op) {
if ($op->getJobType() === 'uninstall') {
$devPackages[] = $op->getPackage();
}
}
}

$platformReqs = $this->extractPlatformRequirements($this->package->getRequires());
$platformDevReqs = $this->devMode ? $this->extractPlatformRequirements($this->package->getDevRequires()) : array();

$updatedLock = $this->locker->setLockData(
array_diff($localRepo->getCanonicalPackages(), (array) $devPackages),
$devPackages,
$platformReqs,
$platformDevReqs,
$aliases,
$this->package->getMinimumStability(),
$this->package->getStabilityFlags(),
$this->preferStable || $this->package->getPreferStable(),
$this->preferLowest,
$this->config->get('platform') ?: array()
);
if ($updatedLock) {
$this->io->writeError('<info>Writing lock file</info>');
}
}

if ($this->dumpAutoloader) {

 if ($this->optimizeAutoloader) {
$this->io->writeError('<info>Generating optimized autoload files</info>');
} else {
$this->io->writeError('<info>Generating autoload files</info>');
}

$this->autoloadGenerator->setDevMode($this->devMode);
$this->autoloadGenerator->dump($this->config, $localRepo, $this->package, $this->installationManager, 'composer', $this->optimizeAutoloader);
}

if ($this->runScripts) {

 $eventName = $this->update ? ScriptEvents::POST_UPDATE_CMD : ScriptEvents::POST_INSTALL_CMD;
$this->eventDispatcher->dispatchScript($eventName, $this->devMode);
}

$vendorDir = $this->config->get('vendor-dir');
if (is_dir($vendorDir)) {
touch($vendorDir);
}
}

return 0;
}

protected function doInstall($localRepo, $installedRepo, $platformRepo, $aliases, $withDevReqs)
{

 $lockedRepository = null;
$repositories = null;


 $installFromLock = !$this->update && $this->locker->isLocked();


 
 
 if ($installFromLock || (!empty($this->updateWhitelist) && $this->locker->isLocked())) {
try {
$lockedRepository = $this->locker->getLockedRepository($withDevReqs);
} catch (\RuntimeException $e) {

 if ($this->package->getDevRequires()) {
throw $e;
}

 $lockedRepository = $this->locker->getLockedRepository();
}
}

$this->whitelistUpdateDependencies(
$localRepo,
$withDevReqs,
$this->package->getRequires(),
$this->package->getDevRequires()
);

$this->io->writeError('<info>Loading composer repositories with package information</info>');


 $policy = $this->createPolicy();
$pool = $this->createPool($withDevReqs, $installFromLock ? $lockedRepository : null);
$pool->addRepository($installedRepo, $aliases);
if (!$installFromLock) {
$repositories = $this->repositoryManager->getRepositories();
foreach ($repositories as $repository) {
$pool->addRepository($repository, $aliases);
}
}

 
 
 if ($lockedRepository) {
$pool->addRepository($lockedRepository, $aliases);
}


 $request = $this->createRequest($this->package, $platformRepo);

if (!$installFromLock) {

 $removedUnstablePackages = array();
foreach ($localRepo->getPackages() as $package) {
if (
!$pool->isPackageAcceptable($package->getNames(), $package->getStability())
&& $this->installationManager->isPackageInstalled($localRepo, $package)
) {
$removedUnstablePackages[$package->getName()] = true;
$request->remove($package->getName(), new VersionConstraint('=', $package->getVersion()));
}
}
}

if ($this->update) {
$this->io->writeError('<info>Updating dependencies'.($withDevReqs ? ' (including require-dev)' : '').'</info>');

$request->updateAll();

if ($withDevReqs) {
$links = array_merge($this->package->getRequires(), $this->package->getDevRequires());
} else {
$links = $this->package->getRequires();
}

foreach ($links as $link) {
$request->install($link->getTarget(), $link->getConstraint());
}


 
 if ($this->updateWhitelist) {
$currentPackages = $this->getCurrentPackages($withDevReqs, $installedRepo);


 $candidates = array();
foreach ($links as $link) {
$candidates[$link->getTarget()] = true;
}
foreach ($localRepo->getPackages() as $package) {
$candidates[$package->getName()] = true;
}


 foreach ($candidates as $candidate => $dummy) {
foreach ($currentPackages as $curPackage) {
if ($curPackage->getName() === $candidate) {
if (!$this->isUpdateable($curPackage) && !isset($removedUnstablePackages[$curPackage->getName()])) {
$constraint = new VersionConstraint('=', $curPackage->getVersion());
$request->install($curPackage->getName(), $constraint);
}
break;
}
}
}
}
} elseif ($installFromLock) {
$this->io->writeError('<info>Installing dependencies'.($withDevReqs ? ' (including require-dev)' : '').' from lock file</info>');

if (!$this->locker->isFresh()) {
$this->io->writeError('<warning>Warning: The lock file is not up to date with the latest changes in composer.json. You may be getting outdated dependencies. Run update to update them.</warning>');
}

foreach ($lockedRepository->getPackages() as $package) {
$version = $package->getVersion();
if (isset($aliases[$package->getName()][$version])) {
$version = $aliases[$package->getName()][$version]['alias_normalized'];
}
$constraint = new VersionConstraint('=', $version);
$constraint->setPrettyString($package->getPrettyVersion());
$request->install($package->getName(), $constraint);
}

foreach ($this->locker->getPlatformRequirements($withDevReqs) as $link) {
$request->install($link->getTarget(), $link->getConstraint());
}
} else {
$this->io->writeError('<info>Installing dependencies'.($withDevReqs ? ' (including require-dev)' : '').'</info>');

if ($withDevReqs) {
$links = array_merge($this->package->getRequires(), $this->package->getDevRequires());
} else {
$links = $this->package->getRequires();
}

foreach ($links as $link) {
$request->install($link->getTarget(), $link->getConstraint());
}
}


 $this->processDevPackages($localRepo, $pool, $policy, $repositories, $installedRepo, $lockedRepository, $installFromLock, $withDevReqs, 'force-links');


 $this->eventDispatcher->dispatchInstallerEvent(InstallerEvents::PRE_DEPENDENCIES_SOLVING, $this->devMode, $policy, $pool, $installedRepo, $request);
$solver = new Solver($policy, $pool, $installedRepo);
try {
$operations = $solver->solve($request, $this->ignorePlatformReqs);
$this->eventDispatcher->dispatchInstallerEvent(InstallerEvents::POST_DEPENDENCIES_SOLVING, $this->devMode, $policy, $pool, $installedRepo, $request, $operations);
} catch (SolverProblemsException $e) {
$this->io->writeError('<error>Your requirements could not be resolved to an installable set of packages.</error>');
$this->io->writeError($e->getMessage());

return max(1, $e->getCode());
}


 $operations = $this->processDevPackages($localRepo, $pool, $policy, $repositories, $installedRepo, $lockedRepository, $installFromLock, $withDevReqs, 'force-updates', $operations);


 if (!$operations) {
$this->io->writeError('Nothing to install or update');
}

$operations = $this->movePluginsToFront($operations);
$operations = $this->moveUninstallsToFront($operations);

foreach ($operations as $operation) {

 if ('install' === $operation->getJobType()) {
foreach ($operation->getPackage()->getSuggests() as $target => $reason) {
$this->suggestedPackages[] = array(
'source' => $operation->getPackage()->getPrettyName(),
'target' => $target,
'reason' => $reason,
);
}
}


 if (!$installFromLock) {
$package = null;
if ('update' === $operation->getJobType()) {
$package = $operation->getTargetPackage();
} elseif ('install' === $operation->getJobType()) {
$package = $operation->getPackage();
}
if ($package && $package->isDev()) {
$references = $this->package->getReferences();
if (isset($references[$package->getName()])) {
$package->setSourceReference($references[$package->getName()]);
$package->setDistReference($references[$package->getName()]);
}
}
if ('update' === $operation->getJobType()
&& $operation->getTargetPackage()->isDev()
&& $operation->getTargetPackage()->getVersion() === $operation->getInitialPackage()->getVersion()
&& $operation->getTargetPackage()->getSourceReference() === $operation->getInitialPackage()->getSourceReference()
) {
if ($this->io->isDebug()) {
$this->io->writeError('  - Skipping update of '. $operation->getTargetPackage()->getPrettyName().' to the same reference-locked version');
$this->io->writeError('');
}

continue;
}
}

$event = 'Composer\Installer\PackageEvents::PRE_PACKAGE_'.strtoupper($operation->getJobType());
if (defined($event) && $this->runScripts) {
$this->eventDispatcher->dispatchPackageEvent(constant($event), $this->devMode, $policy, $pool, $installedRepo, $request, $operations, $operation);
}


 if ($this->dryRun && false === strpos($operation->getJobType(), 'Alias')) {
$this->io->writeError('  - ' . $operation);
$this->io->writeError('');
} elseif ($this->io->isDebug() && false !== strpos($operation->getJobType(), 'Alias')) {
$this->io->writeError('  - ' . $operation);
$this->io->writeError('');
}

$this->installationManager->execute($localRepo, $operation);


 if ($this->verbose && $this->io->isVeryVerbose() && in_array($operation->getJobType(), array('install', 'update'))) {
$reason = $operation->getReason();
if ($reason instanceof Rule) {
switch ($reason->getReason()) {
case Rule::RULE_JOB_INSTALL:
$this->io->writeError('    REASON: Required by root: '.$reason->getPrettyString($pool));
$this->io->writeError('');
break;
case Rule::RULE_PACKAGE_REQUIRES:
$this->io->writeError('    REASON: '.$reason->getPrettyString($pool));
$this->io->writeError('');
break;
}
}
}

$event = 'Composer\Installer\PackageEvents::POST_PACKAGE_'.strtoupper($operation->getJobType());
if (defined($event) && $this->runScripts) {
$this->eventDispatcher->dispatchPackageEvent(constant($event), $this->devMode, $policy, $pool, $installedRepo, $request, $operations, $operation);
}

if (!$this->dryRun) {
$localRepo->write();
}
}

if (!$this->dryRun) {

 $operations = $this->processPackageUrls($pool, $policy, $localRepo, $repositories);
$localRepo->write();
}

return 0;
}














private function movePluginsToFront(array $operations)
{
$installerOps = array();
foreach ($operations as $idx => $op) {
if ($op instanceof InstallOperation) {
$package = $op->getPackage();
} elseif ($op instanceof UpdateOperation) {
$package = $op->getTargetPackage();
} else {
continue;
}

if ($package->getType() === 'composer-plugin' || $package->getType() === 'composer-installer') {

 $requires = array_keys($package->getRequires());
foreach ($requires as $index => $req) {
if ($req === 'composer-plugin-api' || preg_match(PlatformRepository::PLATFORM_PACKAGE_REGEX, $req)) {
unset($requires[$index]);
}
}

 if (!count($requires)) {
$installerOps[] = $op;
unset($operations[$idx]);
}
}
}

return array_merge($installerOps, $operations);
}








private function moveUninstallsToFront(array $operations)
{
$uninstOps = array();
foreach ($operations as $idx => $op) {
if ($op instanceof UninstallOperation) {
$uninstOps[] = $op;
unset($operations[$idx]);
}
}

return array_merge($uninstOps, $operations);
}

private function createPool($withDevReqs, RepositoryInterface $lockedRepository = null)
{
if (!$this->update && $this->locker->isLocked()) { 
 $minimumStability = $this->locker->getMinimumStability();
$stabilityFlags = $this->locker->getStabilityFlags();

$requires = array();
foreach ($lockedRepository->getPackages() as $package) {
$constraint = new VersionConstraint('=', $package->getVersion());
$constraint->setPrettyString($package->getPrettyVersion());
$requires[$package->getName()] = $constraint;
}
} else {
$minimumStability = $this->package->getMinimumStability();
$stabilityFlags = $this->package->getStabilityFlags();

$requires = $this->package->getRequires();
if ($withDevReqs) {
$requires = array_merge($requires, $this->package->getDevRequires());
}
}

$rootConstraints = array();
foreach ($requires as $req => $constraint) {

 if ($this->ignorePlatformReqs && preg_match(PlatformRepository::PLATFORM_PACKAGE_REGEX, $req)) {
continue;
}
if ($constraint instanceof Link) {
$rootConstraints[$req] = $constraint->getConstraint();
} else {
$rootConstraints[$req] = $constraint;
}
}

return new Pool($minimumStability, $stabilityFlags, $rootConstraints);
}

private function createPolicy()
{
$preferStable = null;
$preferLowest = null;
if (!$this->update && $this->locker->isLocked()) {
$preferStable = $this->locker->getPreferStable();
$preferLowest = $this->locker->getPreferLowest();
}

 
 if (null === $preferStable) {
$preferStable = $this->preferStable || $this->package->getPreferStable();
}
if (null === $preferLowest) {
$preferLowest = $this->preferLowest;
}

return new DefaultPolicy($preferStable, $preferLowest);
}

private function createRequest(RootPackageInterface $rootPackage, PlatformRepository $platformRepo)
{
$request = new Request();

$constraint = new VersionConstraint('=', $rootPackage->getVersion());
$constraint->setPrettyString($rootPackage->getPrettyVersion());
$request->install($rootPackage->getName(), $constraint);

$fixedPackages = $platformRepo->getPackages();
if ($this->additionalInstalledRepository) {
$additionalFixedPackages = $this->additionalInstalledRepository->getPackages();
$fixedPackages = array_merge($fixedPackages, $additionalFixedPackages);
}


 
 $provided = $rootPackage->getProvides();
foreach ($fixedPackages as $package) {
$constraint = new VersionConstraint('=', $package->getVersion());
$constraint->setPrettyString($package->getPrettyVersion());


 if ($package->getRepository() !== $platformRepo
|| !isset($provided[$package->getName()])
|| !$provided[$package->getName()]->getConstraint()->matches($constraint)
) {
$request->fix($package->getName(), $constraint);
}
}

return $request;
}

private function processDevPackages($localRepo, $pool, $policy, $repositories, $installedRepo, $lockedRepository, $installFromLock, $withDevReqs, $task, array $operations = null)
{
if ($task === 'force-updates' && null === $operations) {
throw new \InvalidArgumentException('Missing operations argument');
}
if ($task === 'force-links') {
$operations = array();
}

if (!$installFromLock && $this->updateWhitelist) {
$currentPackages = $this->getCurrentPackages($withDevReqs, $installedRepo);
}

foreach ($localRepo->getCanonicalPackages() as $package) {

 if (!$package->isDev()) {
continue;
}


 foreach ($operations as $operation) {
if (('update' === $operation->getJobType() && $operation->getInitialPackage()->equals($package))
|| ('uninstall' === $operation->getJobType() && $operation->getPackage()->equals($package))
) {
continue 2;
}
}


 if ($installFromLock) {
foreach ($lockedRepository->findPackages($package->getName()) as $lockedPackage) {
if ($lockedPackage->isDev() && $lockedPackage->getVersion() === $package->getVersion()) {
if ($task === 'force-links') {
$package->setRequires($lockedPackage->getRequires());
$package->setConflicts($lockedPackage->getConflicts());
$package->setProvides($lockedPackage->getProvides());
$package->setReplaces($lockedPackage->getReplaces());
} elseif ($task === 'force-updates') {
if (($lockedPackage->getSourceReference() && $lockedPackage->getSourceReference() !== $package->getSourceReference())
|| ($lockedPackage->getDistReference() && $lockedPackage->getDistReference() !== $package->getDistReference())
) {
$operations[] = new UpdateOperation($package, $lockedPackage);
}
}

break;
}
}
} else {

 if ($this->update) {

 if ($this->updateWhitelist && !$this->isUpdateable($package)) {

 foreach ($currentPackages as $curPackage) {
if ($curPackage->isDev() && $curPackage->getName() === $package->getName() && $curPackage->getVersion() === $package->getVersion()) {
if ($task === 'force-links') {
$package->setRequires($curPackage->getRequires());
$package->setConflicts($curPackage->getConflicts());
$package->setProvides($curPackage->getProvides());
$package->setReplaces($curPackage->getReplaces());
} elseif ($task === 'force-updates') {
if (($curPackage->getSourceReference() && $curPackage->getSourceReference() !== $package->getSourceReference())
|| ($curPackage->getDistReference() && $curPackage->getDistReference() !== $package->getDistReference())
) {
$operations[] = new UpdateOperation($package, $curPackage);
}
}

break;
}
}

continue;
}


 $matches = $pool->whatProvides($package->getName(), new VersionConstraint('=', $package->getVersion()));
foreach ($matches as $index => $match) {

 if (!in_array($match->getRepository(), $repositories, true)) {
unset($matches[$index]);
continue;
}


 if ($match->getName() !== $package->getName()) {
unset($matches[$index]);
continue;
}

$matches[$index] = $match->getId();
}


 if ($matches && $matches = $policy->selectPreferredPackages($pool, array(), $matches)) {
$newPackage = $pool->literalToPackage($matches[0]);

if ($task === 'force-links' && $newPackage) {
$package->setRequires($newPackage->getRequires());
$package->setConflicts($newPackage->getConflicts());
$package->setProvides($newPackage->getProvides());
$package->setReplaces($newPackage->getReplaces());
}

if ($task === 'force-updates' && $newPackage && (
(($newPackage->getSourceReference() && $newPackage->getSourceReference() !== $package->getSourceReference())
|| ($newPackage->getDistReference() && $newPackage->getDistReference() !== $package->getDistReference())
)
)) {
$operations[] = new UpdateOperation($package, $newPackage);
}
}
}

if ($task === 'force-updates') {

 $references = $this->package->getReferences();

if (isset($references[$package->getName()]) && $references[$package->getName()] !== $package->getSourceReference()) {

 $operations[] = new UpdateOperation($package, clone $package);
}
}
}
}

return $operations;
}




private function getCurrentPackages($withDevReqs, $installedRepo)
{
if ($this->locker->isLocked()) {
try {
return $this->locker->getLockedRepository($withDevReqs)->getPackages();
} catch (\RuntimeException $e) {

 return $this->locker->getLockedRepository()->getPackages();
}
}

return $installedRepo->getPackages();
}

private function getRootAliases()
{
if (!$this->update && $this->locker->isLocked()) {
$aliases = $this->locker->getAliases();
} else {
$aliases = $this->package->getAliases();
}

$normalizedAliases = array();

foreach ($aliases as $alias) {
$normalizedAliases[$alias['package']][$alias['version']] = array(
'alias' => $alias['alias'],
'alias_normalized' => $alias['alias_normalized']
);
}

return $normalizedAliases;
}

private function processPackageUrls($pool, $policy, $localRepo, $repositories)
{
if (!$this->update) {
return;
}

foreach ($localRepo->getCanonicalPackages() as $package) {

 $matches = $pool->whatProvides($package->getName(), new VersionConstraint('=', $package->getVersion()));
foreach ($matches as $index => $match) {

 if (!in_array($match->getRepository(), $repositories, true)) {
unset($matches[$index]);
continue;
}


 if ($match->getName() !== $package->getName()) {
unset($matches[$index]);
continue;
}

$matches[$index] = $match->getId();
}


 if ($matches && $matches = $policy->selectPreferredPackages($pool, array(), $matches)) {
$newPackage = $pool->literalToPackage($matches[0]);


 $package->setSourceUrl($newPackage->getSourceUrl());

 
 if (preg_match('{^https?://(api\.)?github\.com/}', $newPackage->getDistUrl())) {
$package->setDistUrl($newPackage->getDistUrl());
}
}
}
}

private function aliasPlatformPackages(PlatformRepository $platformRepo, $aliases)
{
foreach ($aliases as $package => $versions) {
foreach ($versions as $version => $alias) {
$packages = $platformRepo->findPackages($package, $version);
foreach ($packages as $package) {
$aliasPackage = new AliasPackage($package, $alias['alias_normalized'], $alias['alias']);
$aliasPackage->setRootPackageAlias(true);
$platformRepo->addPackage($aliasPackage);
}
}
}
}

private function isUpdateable(PackageInterface $package)
{
if (!$this->updateWhitelist) {
throw new \LogicException('isUpdateable should only be called when a whitelist is present');
}

foreach ($this->updateWhitelist as $whiteListedPattern => $void) {
$patternRegexp = $this->packageNameToRegexp($whiteListedPattern);
if (preg_match($patternRegexp, $package->getName())) {
return true;
}
}

return false;
}







private function packageNameToRegexp($whiteListedPattern)
{
$cleanedWhiteListedPattern = str_replace('\\*', '.*', preg_quote($whiteListedPattern));

return "{^" . $cleanedWhiteListedPattern . "$}i";
}

private function extractPlatformRequirements($links)
{
$platformReqs = array();
foreach ($links as $link) {
if (preg_match(PlatformRepository::PLATFORM_PACKAGE_REGEX, $link->getTarget())) {
$platformReqs[$link->getTarget()] = $link->getPrettyConstraint();
}
}

return $platformReqs;
}













private function whitelistUpdateDependencies($localRepo, $devMode, array $rootRequires, array $rootDevRequires)
{
if (!$this->updateWhitelist) {
return;
}

$requiredPackageNames = array();
foreach (array_merge($rootRequires, $rootDevRequires) as $require) {
$requiredPackageNames[] = $require->getTarget();
}

if ($devMode) {
$rootRequires = array_merge($rootRequires, $rootDevRequires);
}

$skipPackages = array();
foreach ($rootRequires as $require) {
$skipPackages[$require->getTarget()] = true;
}

$pool = new Pool;
$pool->addRepository($localRepo);

$seen = array();

$rootRequiredPackageNames = array_keys($rootRequires);

foreach ($this->updateWhitelist as $packageName => $void) {
$packageQueue = new \SplQueue;

$depPackages = $pool->whatProvides($packageName);

$nameMatchesRequiredPackage = in_array($packageName, $requiredPackageNames, true);


 if (!$nameMatchesRequiredPackage) {
$whitelistPatternRegexp = $this->packageNameToRegexp($packageName);
foreach ($rootRequiredPackageNames as $rootRequiredPackageName) {
if (preg_match($whitelistPatternRegexp, $rootRequiredPackageName)) {
$nameMatchesRequiredPackage = true;
break;
}
}
}

if (count($depPackages) == 0 && !$nameMatchesRequiredPackage && !in_array($packageName, array('nothing', 'lock'))) {
$this->io->writeError('<warning>Package "' . $packageName . '" listed for update is not installed. Ignoring.</warning>');
}

foreach ($depPackages as $depPackage) {
$packageQueue->enqueue($depPackage);
}

while (!$packageQueue->isEmpty()) {
$package = $packageQueue->dequeue();
if (isset($seen[$package->getId()])) {
continue;
}

$seen[$package->getId()] = true;
$this->updateWhitelist[$package->getName()] = true;

if (!$this->whitelistDependencies) {
continue;
}

$requires = $package->getRequires();

foreach ($requires as $require) {
$requirePackages = $pool->whatProvides($require->getTarget());

foreach ($requirePackages as $requirePackage) {
if (isset($skipPackages[$requirePackage->getName()])) {
continue;
}
$packageQueue->enqueue($requirePackage);
}
}
}
}
}








private function mockLocalRepositories(RepositoryManager $rm)
{
$packages = array();
foreach ($rm->getLocalRepository()->getPackages() as $package) {
$packages[(string) $package] = clone $package;
}
foreach ($packages as $key => $package) {
if ($package instanceof AliasPackage) {
$alias = (string) $package->getAliasOf();
$packages[$key] = new AliasPackage($packages[$alias], $package->getVersion(), $package->getPrettyVersion());
}
}
$rm->setLocalRepository(
new InstalledArrayRepository($packages)
);
}








public static function create(IOInterface $io, Composer $composer)
{
return new static(
$io,
$composer->getConfig(),
$composer->getPackage(),
$composer->getDownloadManager(),
$composer->getRepositoryManager(),
$composer->getLocker(),
$composer->getInstallationManager(),
$composer->getEventDispatcher(),
$composer->getAutoloadGenerator()
);
}

public function setAdditionalInstalledRepository(RepositoryInterface $additionalInstalledRepository)
{
$this->additionalInstalledRepository = $additionalInstalledRepository;

return $this;
}







public function setDryRun($dryRun = true)
{
$this->dryRun = (boolean) $dryRun;

return $this;
}






public function isDryRun()
{
return $this->dryRun;
}







public function setPreferSource($preferSource = true)
{
$this->preferSource = (boolean) $preferSource;

return $this;
}







public function setPreferDist($preferDist = true)
{
$this->preferDist = (boolean) $preferDist;

return $this;
}







public function setOptimizeAutoloader($optimizeAutoloader = false)
{
$this->optimizeAutoloader = (boolean) $optimizeAutoloader;

return $this;
}







public function setUpdate($update = true)
{
$this->update = (boolean) $update;

return $this;
}







public function setDevMode($devMode = true)
{
$this->devMode = (boolean) $devMode;

return $this;
}







public function setDumpAutoloader($dumpAutoloader = true)
{
$this->dumpAutoloader = (boolean) $dumpAutoloader;

return $this;
}







public function setRunScripts($runScripts = true)
{
$this->runScripts = (boolean) $runScripts;

return $this;
}







public function setConfig(Config $config)
{
$this->config = $config;

return $this;
}







public function setVerbose($verbose = true)
{
$this->verbose = (boolean) $verbose;

return $this;
}






public function isVerbose()
{
return $this->verbose;
}







public function setIgnorePlatformRequirements($ignorePlatformReqs = false)
{
$this->ignorePlatformReqs = (boolean) $ignorePlatformReqs;

return $this;
}








public function setUpdateWhitelist(array $packages)
{
$this->updateWhitelist = array_flip(array_map('strtolower', $packages));

return $this;
}







public function setWhitelistDependencies($updateDependencies = true)
{
$this->whitelistDependencies = (boolean) $updateDependencies;

return $this;
}







public function setPreferStable($preferStable = true)
{
$this->preferStable = (boolean) $preferStable;

return $this;
}







public function setPreferLowest($preferLowest = true)
{
$this->preferLowest = (boolean) $preferLowest;

return $this;
}










public function disablePlugins()
{
$this->installationManager->disablePlugins();

return $this;
}
}
<?php











namespace Composer\Installer;

use Composer\Package\PackageInterface;
use Composer\Package\AliasPackage;
use Composer\Repository\RepositoryInterface;
use Composer\Repository\InstalledRepositoryInterface;
use Composer\DependencyResolver\Operation\OperationInterface;
use Composer\DependencyResolver\Operation\InstallOperation;
use Composer\DependencyResolver\Operation\UpdateOperation;
use Composer\DependencyResolver\Operation\UninstallOperation;
use Composer\DependencyResolver\Operation\MarkAliasInstalledOperation;
use Composer\DependencyResolver\Operation\MarkAliasUninstalledOperation;
use Composer\Util\StreamContextFactory;








class InstallationManager
{
private $installers = array();
private $cache = array();
private $notifiablePackages = array();

public function reset()
{
$this->notifiablePackages = array();
}






public function addInstaller(InstallerInterface $installer)
{
array_unshift($this->installers, $installer);
$this->cache = array();
}






public function removeInstaller(InstallerInterface $installer)
{
if (false !== ($key = array_search($installer, $this->installers, true))) {
array_splice($this->installers, $key, 1);
$this->cache = array();
}
}








public function disablePlugins()
{
foreach ($this->installers as $i => $installer) {
if (!$installer instanceof PluginInstaller) {
continue;
}

unset($this->installers[$i]);
}
}










public function getInstaller($type)
{
$type = strtolower($type);

if (isset($this->cache[$type])) {
return $this->cache[$type];
}

foreach ($this->installers as $installer) {
if ($installer->supports($type)) {
return $this->cache[$type] = $installer;
}
}

throw new \InvalidArgumentException('Unknown installer type: '.$type);
}









public function isPackageInstalled(InstalledRepositoryInterface $repo, PackageInterface $package)
{
if ($package instanceof AliasPackage) {
return $repo->hasPackage($package) && $this->isPackageInstalled($repo, $package->getAliasOf());
}

return $this->getInstaller($package->getType())->isInstalled($repo, $package);
}







public function execute(RepositoryInterface $repo, OperationInterface $operation)
{
$method = $operation->getJobType();
$this->$method($repo, $operation);
}







public function install(RepositoryInterface $repo, InstallOperation $operation)
{
$package = $operation->getPackage();
$installer = $this->getInstaller($package->getType());
$installer->install($repo, $package);
$this->markForNotification($package);
}







public function update(RepositoryInterface $repo, UpdateOperation $operation)
{
$initial = $operation->getInitialPackage();
$target = $operation->getTargetPackage();

$initialType = $initial->getType();
$targetType = $target->getType();

if ($initialType === $targetType) {
$installer = $this->getInstaller($initialType);
$installer->update($repo, $initial, $target);
$this->markForNotification($target);
} else {
$this->getInstaller($initialType)->uninstall($repo, $initial);
$this->getInstaller($targetType)->install($repo, $target);
}
}







public function uninstall(RepositoryInterface $repo, UninstallOperation $operation)
{
$package = $operation->getPackage();
$installer = $this->getInstaller($package->getType());
$installer->uninstall($repo, $package);
}







public function markAliasInstalled(RepositoryInterface $repo, MarkAliasInstalledOperation $operation)
{
$package = $operation->getPackage();

if (!$repo->hasPackage($package)) {
$repo->addPackage(clone $package);
}
}







public function markAliasUninstalled(RepositoryInterface $repo, MarkAliasUninstalledOperation $operation)
{
$package = $operation->getPackage();

$repo->removePackage($package);
}







public function getInstallPath(PackageInterface $package)
{
$installer = $this->getInstaller($package->getType());

return $installer->getInstallPath($package);
}

public function notifyInstalls()
{
foreach ($this->notifiablePackages as $repoUrl => $packages) {

 if (strpos($repoUrl, '%package%')) {
foreach ($packages as $package) {
$url = str_replace('%package%', $package->getPrettyName(), $repoUrl);

$params = array(
'version' => $package->getPrettyVersion(),
'version_normalized' => $package->getVersion(),
);
$opts = array('http' =>
array(
'method' => 'POST',
'header' => array('Content-type: application/x-www-form-urlencoded'),
'content' => http_build_query($params, '', '&'),
'timeout' => 3,
)
);

$context = StreamContextFactory::getContext($url, $opts);
@file_get_contents($url, false, $context);
}

continue;
}

$postData = array('downloads' => array());
foreach ($packages as $package) {
$postData['downloads'][] = array(
'name' => $package->getPrettyName(),
'version' => $package->getVersion(),
);
}

$opts = array('http' =>
array(
'method' => 'POST',
'header' => array('Content-Type: application/json'),
'content' => json_encode($postData),
'timeout' => 6,
)
);

$context = StreamContextFactory::getContext($repoUrl, $opts);
@file_get_contents($repoUrl, false, $context);
}

$this->reset();
}

private function markForNotification(PackageInterface $package)
{
if ($package->getNotificationUrl()) {
$this->notifiablePackages[$package->getNotificationUrl()][$package->getName()] = $package;
}
}
}
<?php











namespace Composer\Installer;

use Composer\Composer;
use Composer\DependencyResolver\PolicyInterface;
use Composer\DependencyResolver\Operation\OperationInterface;
use Composer\DependencyResolver\Pool;
use Composer\DependencyResolver\Request;
use Composer\EventDispatcher\Event;
use Composer\IO\IOInterface;
use Composer\Repository\CompositeRepository;






class InstallerEvent extends Event
{



private $composer;




private $io;




private $devMode;




private $policy;




private $pool;




private $installedRepo;




private $request;




private $operations;














public function __construct($eventName, Composer $composer, IOInterface $io, $devMode, PolicyInterface $policy, Pool $pool, CompositeRepository $installedRepo, Request $request, array $operations = array())
{
parent::__construct($eventName);

$this->composer = $composer;
$this->io = $io;
$this->devMode = $devMode;
$this->policy = $policy;
$this->pool = $pool;
$this->installedRepo = $installedRepo;
$this->request = $request;
$this->operations = $operations;
}




public function getComposer()
{
return $this->composer;
}




public function getIO()
{
return $this->io;
}




public function isDevMode()
{
return $this->devMode;
}




public function getPolicy()
{
return $this->policy;
}




public function getPool()
{
return $this->pool;
}




public function getInstalledRepo()
{
return $this->installedRepo;
}




public function getRequest()
{
return $this->request;
}




public function getOperations()
{
return $this->operations;
}
}
<?php











namespace Composer\Installer;






class InstallerEvents
{









const PRE_DEPENDENCIES_SOLVING = 'pre-dependencies-solving';










const POST_DEPENDENCIES_SOLVING = 'post-dependencies-solving';
}
<?php











namespace Composer\Installer;

use Composer\Package\PackageInterface;
use Composer\Repository\InstalledRepositoryInterface;







interface InstallerInterface
{






public function supports($packageType);









public function isInstalled(InstalledRepositoryInterface $repo, PackageInterface $package);







public function install(InstalledRepositoryInterface $repo, PackageInterface $package);










public function update(InstalledRepositoryInterface $repo, PackageInterface $initial, PackageInterface $target);







public function uninstall(InstalledRepositoryInterface $repo, PackageInterface $package);







public function getInstallPath(PackageInterface $package);
}
<?php











namespace Composer\Installer;

use Composer\Composer;
use Composer\IO\IOInterface;
use Composer\Repository\InstalledRepositoryInterface;
use Composer\Package\PackageInterface;
use Composer\Util\Filesystem;
use Composer\Util\ProcessExecutor;







class LibraryInstaller implements InstallerInterface
{
protected $composer;
protected $vendorDir;
protected $binDir;
protected $downloadManager;
protected $io;
protected $type;
protected $filesystem;









public function __construct(IOInterface $io, Composer $composer, $type = 'library', Filesystem $filesystem = null)
{
$this->composer = $composer;
$this->downloadManager = $composer->getDownloadManager();
$this->io = $io;
$this->type = $type;

$this->filesystem = $filesystem ?: new Filesystem();
$this->vendorDir = rtrim($composer->getConfig()->get('vendor-dir'), '/');
$this->binDir = rtrim($composer->getConfig()->get('bin-dir'), '/');
}




public function supports($packageType)
{
return $packageType === $this->type || null === $this->type;
}




public function isInstalled(InstalledRepositoryInterface $repo, PackageInterface $package)
{
return $repo->hasPackage($package) && is_readable($this->getInstallPath($package));
}




public function install(InstalledRepositoryInterface $repo, PackageInterface $package)
{
$this->initializeVendorDir();
$downloadPath = $this->getInstallPath($package);


 if (!is_readable($downloadPath) && $repo->hasPackage($package)) {
$this->removeBinaries($package);
}

$this->installCode($package);
$this->installBinaries($package);
if (!$repo->hasPackage($package)) {
$repo->addPackage(clone $package);
}
}




public function update(InstalledRepositoryInterface $repo, PackageInterface $initial, PackageInterface $target)
{
if (!$repo->hasPackage($initial)) {
throw new \InvalidArgumentException('Package is not installed: '.$initial);
}

$this->initializeVendorDir();

$this->removeBinaries($initial);
$this->updateCode($initial, $target);
$this->installBinaries($target);
$repo->removePackage($initial);
if (!$repo->hasPackage($target)) {
$repo->addPackage(clone $target);
}
}




public function uninstall(InstalledRepositoryInterface $repo, PackageInterface $package)
{
if (!$repo->hasPackage($package)) {
throw new \InvalidArgumentException('Package is not installed: '.$package);
}

$this->removeCode($package);
$this->removeBinaries($package);
$repo->removePackage($package);

$downloadPath = $this->getPackageBasePath($package);
if (strpos($package->getName(), '/')) {
$packageVendorDir = dirname($downloadPath);
if (is_dir($packageVendorDir) && $this->filesystem->isDirEmpty($packageVendorDir)) {
@rmdir($packageVendorDir);
}
}
}




public function getInstallPath(PackageInterface $package)
{
$targetDir = $package->getTargetDir();

return $this->getPackageBasePath($package) . ($targetDir ? '/'.$targetDir : '');
}

protected function getPackageBasePath(PackageInterface $package)
{
$this->initializeVendorDir();

return ($this->vendorDir ? $this->vendorDir.'/' : '') . $package->getPrettyName();
}

protected function installCode(PackageInterface $package)
{
$downloadPath = $this->getInstallPath($package);
$this->downloadManager->download($package, $downloadPath);
}

protected function updateCode(PackageInterface $initial, PackageInterface $target)
{
$initialDownloadPath = $this->getInstallPath($initial);
$targetDownloadPath = $this->getInstallPath($target);
if ($targetDownloadPath !== $initialDownloadPath) {

 
 if (substr($initialDownloadPath, 0, strlen($targetDownloadPath)) === $targetDownloadPath
|| substr($targetDownloadPath, 0, strlen($initialDownloadPath)) === $initialDownloadPath
) {
$this->removeCode($initial);
$this->installCode($target);

return;
}

$this->filesystem->rename($initialDownloadPath, $targetDownloadPath);
}
$this->downloadManager->update($initial, $target, $targetDownloadPath);
}

protected function removeCode(PackageInterface $package)
{
$downloadPath = $this->getPackageBasePath($package);
$this->downloadManager->remove($package, $downloadPath);
}

protected function getBinaries(PackageInterface $package)
{
return $package->getBinaries();
}

protected function installBinaries(PackageInterface $package)
{
$binaries = $this->getBinaries($package);
if (!$binaries) {
return;
}
foreach ($binaries as $bin) {
$binPath = $this->getInstallPath($package).'/'.$bin;
if (!file_exists($binPath)) {
$this->io->writeError('    <warning>Skipped installation of bin '.$bin.' for package '.$package->getName().': file not found in package</warning>');
continue;
}


 
 
 
 $binPath = realpath($binPath);

$this->initializeBinDir();
$link = $this->binDir.'/'.basename($bin);
if (file_exists($link)) {
if (is_link($link)) {

 
 
 @chmod($link, 0777 & ~umask());
}
$this->io->writeError('    Skipped installation of bin '.$bin.' for package '.$package->getName().': name conflicts with an existing file');
continue;
}
if (defined('PHP_WINDOWS_VERSION_BUILD')) {

 if ('.bat' !== substr($binPath, -4)) {
file_put_contents($link, $this->generateUnixyProxyCode($binPath, $link));
@chmod($link, 0777 & ~umask());
$link .= '.bat';
if (file_exists($link)) {
$this->io->writeError('    Skipped installation of bin '.$bin.'.bat proxy for package '.$package->getName().': a .bat proxy was already installed');
}
}
if (!file_exists($link)) {
file_put_contents($link, $this->generateWindowsProxyCode($binPath, $link));
}
} else {
$cwd = getcwd();
try {

 
 $relativeBin = $this->filesystem->findShortestPath($link, $binPath);
chdir(dirname($link));
if (false === @symlink($relativeBin, $link)) {
throw new \ErrorException();
}
} catch (\ErrorException $e) {
file_put_contents($link, $this->generateUnixyProxyCode($binPath, $link));
}
chdir($cwd);
}
@chmod($link, 0777 & ~umask());
}
}

protected function removeBinaries(PackageInterface $package)
{
$binaries = $this->getBinaries($package);
if (!$binaries) {
return;
}
foreach ($binaries as $bin) {
$link = $this->binDir.'/'.basename($bin);
if (is_link($link) || file_exists($link)) {
$this->filesystem->unlink($link);
}
if (file_exists($link.'.bat')) {
$this->filesystem->unlink($link.'.bat');
}
}
}

protected function initializeVendorDir()
{
$this->filesystem->ensureDirectoryExists($this->vendorDir);
$this->vendorDir = realpath($this->vendorDir);
}

protected function initializeBinDir()
{
$this->filesystem->ensureDirectoryExists($this->binDir);
$this->binDir = realpath($this->binDir);
}

protected function generateWindowsProxyCode($bin, $link)
{
$binPath = $this->filesystem->findShortestPath($link, $bin);
if ('.bat' === substr($bin, -4) || '.exe' === substr($bin, -4)) {
$caller = 'call';
} else {
$handle = fopen($bin, 'r');
$line = fgets($handle);
fclose($handle);
if (preg_match('{^#!/(?:usr/bin/env )?(?:[^/]+/)*(.+)$}m', $line, $match)) {
$caller = trim($match[1]);
} else {
$caller = 'php';
}
}

return "@ECHO OFF\r\n".
"SET BIN_TARGET=%~dp0/".trim(ProcessExecutor::escape($binPath), '"')."\r\n".
"{$caller} \"%BIN_TARGET%\" %*\r\n";
}

protected function generateUnixyProxyCode($bin, $link)
{
$binPath = $this->filesystem->findShortestPath($link, $bin);

return "#!/usr/bin/env sh\n".
'SRC_DIR="`pwd`"'."\n".
'cd "`dirname "$0"`"'."\n".
'cd '.ProcessExecutor::escape(dirname($binPath))."\n".
'BIN_TARGET="`pwd`/'.basename($binPath)."\"\n".
'cd "$SRC_DIR"'."\n".
'"$BIN_TARGET" "$@"'."\n";
}
}
<?php











namespace Composer\Installer;

use Composer\Repository\InstalledRepositoryInterface;
use Composer\Package\PackageInterface;






class MetapackageInstaller implements InstallerInterface
{



public function supports($packageType)
{
return $packageType === 'metapackage';
}




public function isInstalled(InstalledRepositoryInterface $repo, PackageInterface $package)
{
return $repo->hasPackage($package);
}




public function install(InstalledRepositoryInterface $repo, PackageInterface $package)
{
$repo->addPackage(clone $package);
}




public function update(InstalledRepositoryInterface $repo, PackageInterface $initial, PackageInterface $target)
{
if (!$repo->hasPackage($initial)) {
throw new \InvalidArgumentException('Package is not installed: '.$initial);
}

$repo->removePackage($initial);
$repo->addPackage(clone $target);
}




public function uninstall(InstalledRepositoryInterface $repo, PackageInterface $package)
{
if (!$repo->hasPackage($package)) {
throw new \InvalidArgumentException('Package is not installed: '.$package);
}

$repo->removePackage($package);
}




public function getInstallPath(PackageInterface $package)
{
return '';
}
}
<?php











namespace Composer\Installer;

use Composer\Repository\InstalledRepositoryInterface;
use Composer\Package\PackageInterface;








class NoopInstaller implements InstallerInterface
{



public function supports($packageType)
{
return true;
}




public function isInstalled(InstalledRepositoryInterface $repo, PackageInterface $package)
{
return $repo->hasPackage($package);
}




public function install(InstalledRepositoryInterface $repo, PackageInterface $package)
{
if (!$repo->hasPackage($package)) {
$repo->addPackage(clone $package);
}
}




public function update(InstalledRepositoryInterface $repo, PackageInterface $initial, PackageInterface $target)
{
if (!$repo->hasPackage($initial)) {
throw new \InvalidArgumentException('Package is not installed: '.$initial);
}

$repo->removePackage($initial);
if (!$repo->hasPackage($target)) {
$repo->addPackage(clone $target);
}
}




public function uninstall(InstalledRepositoryInterface $repo, PackageInterface $package)
{
if (!$repo->hasPackage($package)) {
throw new \InvalidArgumentException('Package is not installed: '.$package);
}
$repo->removePackage($package);
}




public function getInstallPath(PackageInterface $package)
{
$targetDir = $package->getTargetDir();

return $package->getPrettyName() . ($targetDir ? '/'.$targetDir : '');
}
}
<?php











namespace Composer\Installer;

use Composer\Composer;
use Composer\IO\IOInterface;
use Composer\DependencyResolver\Operation\OperationInterface;
use Composer\DependencyResolver\PolicyInterface;
use Composer\DependencyResolver\Pool;
use Composer\DependencyResolver\Request;
use Composer\EventDispatcher\Event;
use Composer\Repository\CompositeRepository;






class PackageEvent extends InstallerEvent
{



private $operation;















public function __construct($eventName, Composer $composer, IOInterface $io, $devMode, PolicyInterface $policy, Pool $pool, CompositeRepository $installedRepo, Request $request, array $operations, OperationInterface $operation)
{
parent::__construct($eventName, $composer, $io, $devMode, $policy, $pool, $installedRepo, $request, $operations);

$this->operation = $operation;
}






public function getOperation()
{
return $this->operation;
}
}
<?php











namespace Composer\Installer;






class PackageEvents
{







const PRE_PACKAGE_INSTALL = 'pre-package-install';








const POST_PACKAGE_INSTALL = 'post-package-install';








const PRE_PACKAGE_UPDATE = 'pre-package-update';








const POST_PACKAGE_UPDATE = 'post-package-update';








const PRE_PACKAGE_UNINSTALL = 'pre-package-uninstall';








const POST_PACKAGE_UNINSTALL = 'post-package-uninstall';
}
<?php











namespace Composer\Installer;

use Composer\IO\IOInterface;
use Composer\Composer;
use Composer\Downloader\PearPackageExtractor;
use Composer\Repository\InstalledRepositoryInterface;
use Composer\Package\PackageInterface;
use Composer\Util\ProcessExecutor;







class PearInstaller extends LibraryInstaller
{







public function __construct(IOInterface $io, Composer $composer, $type = 'pear-library')
{
parent::__construct($io, $composer, $type);
}




public function update(InstalledRepositoryInterface $repo, PackageInterface $initial, PackageInterface $target)
{
$this->uninstall($repo, $initial);
$this->install($repo, $target);
}

protected function installCode(PackageInterface $package)
{
parent::installCode($package);
parent::initializeBinDir();

$isWindows = defined('PHP_WINDOWS_VERSION_BUILD');
$php_bin = $this->binDir . ($isWindows ? '/composer-php.bat' : '/composer-php');

if (!$isWindows) {
$php_bin = '/usr/bin/env ' . $php_bin;
}

$installPath = $this->getInstallPath($package);
$vars = array(
'os' => $isWindows ? 'windows' : 'linux',
'php_bin' => $php_bin,
'pear_php' => $installPath,
'php_dir' => $installPath,
'bin_dir' => $installPath . '/bin',
'data_dir' => $installPath . '/data',
'version' => $package->getPrettyVersion(),
);

$packageArchive = $this->getInstallPath($package).'/'.pathinfo($package->getDistUrl(), PATHINFO_BASENAME);
$pearExtractor = new PearPackageExtractor($packageArchive);
$pearExtractor->extractTo($this->getInstallPath($package), array('php' => '/', 'script' => '/bin', 'data' => '/data'), $vars);

if ($this->io->isVerbose()) {
$this->io->writeError('    Cleaning up');
}
$this->filesystem->unlink($packageArchive);
}

protected function getBinaries(PackageInterface $package)
{
$binariesPath = $this->getInstallPath($package) . '/bin/';
$binaries = array();
if (file_exists($binariesPath)) {
foreach (new \FilesystemIterator($binariesPath, \FilesystemIterator::KEY_AS_FILENAME | \FilesystemIterator::CURRENT_AS_FILEINFO) as $fileName => $value) {
if (!$value->isDir()) {
$binaries[] = 'bin/'.$fileName;
}
}
}

return $binaries;
}

protected function initializeBinDir()
{
parent::initializeBinDir();
file_put_contents($this->binDir.'/composer-php', $this->generateUnixyPhpProxyCode());
@chmod($this->binDir.'/composer-php', 0777);
file_put_contents($this->binDir.'/composer-php.bat', $this->generateWindowsPhpProxyCode());
@chmod($this->binDir.'/composer-php.bat', 0777);
}

protected function generateWindowsProxyCode($bin, $link)
{
$binPath = $this->filesystem->findShortestPath($link, $bin);
if ('.bat' === substr($bin, -4)) {
$caller = 'call';
} else {
$handle = fopen($bin, 'r');
$line = fgets($handle);
fclose($handle);
if (preg_match('{^#!/(?:usr/bin/env )?(?:[^/]+/)*(.+)$}m', $line, $match)) {
$caller = trim($match[1]);
} else {
$caller = 'php';
}

if ($caller === 'php') {
return "@echo off\r\n".
"pushd .\r\n".
"cd %~dp0\r\n".
"set PHP_PROXY=%CD%\\composer-php.bat\r\n".
"cd ".ProcessExecutor::escape(dirname($binPath))."\r\n".
"set BIN_TARGET=%CD%\\".basename($binPath)."\r\n".
"popd\r\n".
"%PHP_PROXY% \"%BIN_TARGET%\" %*\r\n";
}
}

return "@echo off\r\n".
"pushd .\r\n".
"cd %~dp0\r\n".
"cd ".ProcessExecutor::escape(dirname($binPath))."\r\n".
"set BIN_TARGET=%CD%\\".basename($binPath)."\r\n".
"popd\r\n".
$caller." \"%BIN_TARGET%\" %*\r\n";
}

private function generateWindowsPhpProxyCode()
{
$binToVendor = $this->filesystem->findShortestPath($this->binDir, $this->vendorDir, true);

return
"@echo off\r\n" .
"setlocal enabledelayedexpansion\r\n" .
"set BIN_DIR=%~dp0\r\n" .
"set VENDOR_DIR=%BIN_DIR%\\".$binToVendor."\r\n" .
"set DIRS=.\r\n" .
"FOR /D %%V IN (%VENDOR_DIR%\\*) DO (\r\n" .
"    FOR /D %%P IN (%%V\\*) DO (\r\n" .
"        set DIRS=!DIRS!;%%~fP\r\n" .
"    )\r\n" .
")\r\n" .
"php.exe -d include_path=!DIRS! %*\r\n";
}

private function generateUnixyPhpProxyCode()
{
$binToVendor = $this->filesystem->findShortestPath($this->binDir, $this->vendorDir, true);

return
"#!/usr/bin/env sh\n".
"SRC_DIR=`pwd`\n".
"BIN_DIR=`dirname $0`\n".
"VENDOR_DIR=\$BIN_DIR/".escapeshellarg($binToVendor)."\n".
"DIRS=\"\"\n".
"for vendor in \$VENDOR_DIR/*; do\n".
"    if [ -d \"\$vendor\" ]; then\n".
"        for package in \$vendor/*; do\n".
"            if [ -d \"\$package\" ]; then\n".
"                DIRS=\"\${DIRS}:\${package}\"\n".
"            fi\n".
"        done\n".
"    fi\n".
"done\n".
"php -d include_path=\".\$DIRS\" $@\n";
}
}
<?php











namespace Composer\Installer;

use Composer\Composer;
use Composer\Package\Package;
use Composer\IO\IOInterface;
use Composer\Repository\InstalledRepositoryInterface;
use Composer\Package\PackageInterface;







class PluginInstaller extends LibraryInstaller
{
private $installationManager;
private static $classCounter = 0;








public function __construct(IOInterface $io, Composer $composer, $type = 'library')
{
parent::__construct($io, $composer, 'composer-plugin');
$this->installationManager = $composer->getInstallationManager();
}




public function supports($packageType)
{
return $packageType === 'composer-plugin' || $packageType === 'composer-installer';
}




public function install(InstalledRepositoryInterface $repo, PackageInterface $package)
{
$extra = $package->getExtra();
if (empty($extra['class'])) {
throw new \UnexpectedValueException('Error while installing '.$package->getPrettyName().', composer-plugin packages should have a class defined in their extra key to be usable.');
}

parent::install($repo, $package);
$this->composer->getPluginManager()->registerPackage($package, true);
}




public function update(InstalledRepositoryInterface $repo, PackageInterface $initial, PackageInterface $target)
{
$extra = $target->getExtra();
if (empty($extra['class'])) {
throw new \UnexpectedValueException('Error while installing '.$target->getPrettyName().', composer-plugin packages should have a class defined in their extra key to be usable.');
}

parent::update($repo, $initial, $target);
$this->composer->getPluginManager()->registerPackage($target, true);
}
}
<?php











namespace Composer\Installer;

use Composer\Package\PackageInterface;
use Composer\Downloader\DownloadManager;
use Composer\Repository\InstalledRepositoryInterface;
use Composer\Util\Filesystem;







class ProjectInstaller implements InstallerInterface
{
private $installPath;
private $downloadManager;
private $filesystem;

public function __construct($installPath, DownloadManager $dm)
{
$this->installPath = rtrim(strtr($installPath, '\\', '/'), '/').'/';
$this->downloadManager = $dm;
$this->filesystem = new Filesystem;
}







public function supports($packageType)
{
return true;
}




public function isInstalled(InstalledRepositoryInterface $repo, PackageInterface $package)
{
return false;
}




public function install(InstalledRepositoryInterface $repo, PackageInterface $package)
{
$installPath = $this->installPath;
if (file_exists($installPath) && !$this->filesystem->isDirEmpty($installPath)) {
throw new \InvalidArgumentException("Project directory $installPath is not empty.");
}
if (!is_dir($installPath)) {
mkdir($installPath, 0777, true);
}
$this->downloadManager->download($package, $installPath);
}




public function update(InstalledRepositoryInterface $repo, PackageInterface $initial, PackageInterface $target)
{
throw new \InvalidArgumentException("not supported");
}




public function uninstall(InstalledRepositoryInterface $repo, PackageInterface $package)
{
throw new \InvalidArgumentException("not supported");
}







public function getInstallPath(PackageInterface $package)
{
return $this->installPath;
}
}
<?php











namespace Composer\Json;

use JsonSchema\Validator;
use Seld\JsonLint\JsonParser;
use Seld\JsonLint\ParsingException;
use Composer\Util\RemoteFilesystem;
use Composer\Downloader\TransportException;







class JsonFile
{
const LAX_SCHEMA = 1;
const STRICT_SCHEMA = 2;

const JSON_UNESCAPED_SLASHES = 64;
const JSON_PRETTY_PRINT = 128;
const JSON_UNESCAPED_UNICODE = 256;

private $path;
private $rfs;








public function __construct($path, RemoteFilesystem $rfs = null)
{
$this->path = $path;

if (null === $rfs && preg_match('{^https?://}i', $path)) {
throw new \InvalidArgumentException('http urls require a RemoteFilesystem instance to be passed');
}
$this->rfs = $rfs;
}




public function getPath()
{
return $this->path;
}






public function exists()
{
return is_file($this->path);
}







public function read()
{
try {
if ($this->rfs) {
$json = $this->rfs->getContents($this->path, $this->path, false);
} else {
$json = file_get_contents($this->path);
}
} catch (TransportException $e) {
throw new \RuntimeException($e->getMessage(), 0, $e);
} catch (\Exception $e) {
throw new \RuntimeException('Could not read '.$this->path."\n\n".$e->getMessage());
}

return static::parseJson($json, $this->path);
}








public function write(array $hash, $options = 448)
{
$dir = dirname($this->path);
if (!is_dir($dir)) {
if (file_exists($dir)) {
throw new \UnexpectedValueException(
$dir.' exists and is not a directory.'
);
}
if (!@mkdir($dir, 0777, true)) {
throw new \UnexpectedValueException(
$dir.' does not exist and could not be created.'
);
}
}

$retries = 3;
while ($retries--) {
try {
file_put_contents($this->path, static::encode($hash, $options). ($options & self::JSON_PRETTY_PRINT ? "\n" : ''));
break;
} catch (\Exception $e) {
if ($retries) {
usleep(500000);
continue;
}

throw $e;
}
}
}








public function validateSchema($schema = self::STRICT_SCHEMA)
{
$content = file_get_contents($this->path);
$data = json_decode($content);

if (null === $data && 'null' !== $content) {
self::validateSyntax($content, $this->path);
}

$schemaFile = __DIR__ . '/../../../res/composer-schema.json';
$schemaData = json_decode(file_get_contents($schemaFile));

if ($schema === self::LAX_SCHEMA) {
$schemaData->additionalProperties = true;
$schemaData->required = array();
}

$validator = new Validator();
$validator->check($data, $schemaData);



if (!$validator->isValid()) {
$errors = array();
foreach ((array) $validator->getErrors() as $error) {
$errors[] = ($error['property'] ? $error['property'].' : ' : '').$error['message'];
}
throw new JsonValidationException('"'.$this->path.'" does not match the expected JSON schema', $errors);
}

return true;
}








public static function encode($data, $options = 448)
{
if (PHP_VERSION_ID >= 50400) {
$json = json_encode($data, $options);
if (false === $json) {
self::throwEncodeError(json_last_error());
}


 if (PHP_VERSION_ID < 50428 || (PHP_VERSION_ID >= 50500 && PHP_VERSION_ID < 50512) || (defined('JSON_C_VERSION') && version_compare(phpversion('json'), '1.3.6', '<'))) {
$json = preg_replace('/\[\s+\]/', '[]', $json);
$json = preg_replace('/\{\s+\}/', '{}', $json);
}

return $json;
}

$json = json_encode($data);
if (false === $json) {
self::throwEncodeError(json_last_error());
}

$prettyPrint = (bool) ($options & self::JSON_PRETTY_PRINT);
$unescapeUnicode = (bool) ($options & self::JSON_UNESCAPED_UNICODE);
$unescapeSlashes = (bool) ($options & self::JSON_UNESCAPED_SLASHES);

if (!$prettyPrint && !$unescapeUnicode && !$unescapeSlashes) {
return $json;
}

$result = JsonFormatter::format($json, $unescapeUnicode, $unescapeSlashes);

return $result;
}







private static function throwEncodeError($code)
{
switch ($code) {
case JSON_ERROR_DEPTH:
$msg = 'Maximum stack depth exceeded';
break;
case JSON_ERROR_STATE_MISMATCH:
$msg = 'Underflow or the modes mismatch';
break;
case JSON_ERROR_CTRL_CHAR:
$msg = 'Unexpected control character found';
break;
case JSON_ERROR_UTF8:
$msg = 'Malformed UTF-8 characters, possibly incorrectly encoded';
break;
default:
$msg = 'Unknown error';
}

throw new \RuntimeException('JSON encoding failed: '.$msg);
}









public static function parseJson($json, $file = null)
{
if (null === $json) {
return;
}
$data = json_decode($json, true);
if (null === $data && JSON_ERROR_NONE !== json_last_error()) {
self::validateSyntax($json, $file);
}

return $data;
}











protected static function validateSyntax($json, $file = null)
{
$parser = new JsonParser();
$result = $parser->lint($json);
if (null === $result) {
if (defined('JSON_ERROR_UTF8') && JSON_ERROR_UTF8 === json_last_error()) {
throw new \UnexpectedValueException('"'.$file.'" is not UTF-8, could not parse as JSON');
}

return true;
}

throw new ParsingException('"'.$file.'" does not contain valid JSON'."\n".$result->getMessage(), $result->getDetails());
}
}
<?php











namespace Composer\Json;









class JsonFormatter
{













public static function format($json, $unescapeUnicode, $unescapeSlashes)
{
$result = '';
$pos = 0;
$strLen = strlen($json);
$indentStr = '    ';
$newLine = "\n";
$outOfQuotes = true;
$buffer = '';
$noescape = true;

for ($i = 0; $i < $strLen; $i++) {

 $char = substr($json, $i, 1);


 if ('"' === $char && $noescape) {
$outOfQuotes = !$outOfQuotes;
}

if (!$outOfQuotes) {
$buffer .= $char;
$noescape = '\\' === $char ? !$noescape : true;
continue;
} elseif ('' !== $buffer) {
if ($unescapeSlashes) {
$buffer = str_replace('\\/', '/', $buffer);
}

if ($unescapeUnicode && function_exists('mb_convert_encoding')) {

 $buffer = preg_replace_callback('/(\\\\+)u([0-9a-f]{4})/i', function ($match) {
$l = strlen($match[1]);

if ($l % 2) {
return str_repeat('\\', $l - 1) . mb_convert_encoding(
pack('H*', $match[2]),
'UTF-8',
'UCS-2BE'
);
}

return $match[0];
}, $buffer);
}

$result .= $buffer.$char;
$buffer = '';
continue;
}

if (':' === $char) {

 $char .= ' ';
} elseif (('}' === $char || ']' === $char)) {
$pos--;
$prevChar = substr($json, $i - 1, 1);

if ('{' !== $prevChar && '[' !== $prevChar) {

 
 $result .= $newLine;
for ($j = 0; $j < $pos; $j++) {
$result .= $indentStr;
}
} else {

 $result = rtrim($result);
}
}

$result .= $char;


 
 if (',' === $char || '{' === $char || '[' === $char) {
$result .= $newLine;

if ('{' === $char || '[' === $char) {
$pos++;
}

for ($j = 0; $j < $pos; $j++) {
$result .= $indentStr;
}
}
}

return $result;
}
}
<?php











namespace Composer\Json;

use Composer\Repository\PlatformRepository;




class JsonManipulator
{
private static $RECURSE_BLOCKS;
private static $RECURSE_ARRAYS;
private static $JSON_VALUE;
private static $JSON_STRING;

private $contents;
private $newline;
private $indent;

public function __construct($contents)
{
if (!self::$RECURSE_BLOCKS) {
self::$RECURSE_BLOCKS = '(?:[^{}]*|\{(?:[^{}]*|\{(?:[^{}]*|\{(?:[^{}]*|\{[^{}]*\})*\})*\})*\})*';
self::$RECURSE_ARRAYS = '(?:[^\]]*|\[(?:[^\]]*|\[(?:[^\]]*|\[(?:[^\]]*|\[[^\]]*\])*\])*\])*\]|'.self::$RECURSE_BLOCKS.')*';
self::$JSON_STRING = '"(?:[^\0-\x09\x0a-\x1f\\\\"]+|\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4})*"';
self::$JSON_VALUE = '(?:[0-9.]+|null|true|false|'.self::$JSON_STRING.'|\['.self::$RECURSE_ARRAYS.'\]|\{'.self::$RECURSE_BLOCKS.'\})';
}

$contents = trim($contents);
if ($contents === '') {
$contents = '{}';
}
if (!$this->pregMatch('#^\{(.*)\}$#s', $contents)) {
throw new \InvalidArgumentException('The json file must be an object ({})');
}
$this->newline = false !== strpos($contents, "\r\n") ? "\r\n" : "\n";
$this->contents = $contents === '{}' ? '{' . $this->newline . '}' : $contents;
$this->detectIndenting();
}

public function getContents()
{
return $this->contents . $this->newline;
}

public function addLink($type, $package, $constraint, $sortPackages = false)
{
$decoded = JsonFile::parseJson($this->contents);


 if (!isset($decoded[$type])) {
return $this->addMainKey($type, array($package => $constraint));
}

$regex = '{^(\s*\{\s*(?:'.self::$JSON_STRING.'\s*:\s*'.self::$JSON_VALUE.'\s*,\s*)*?)'.
'('.preg_quote(JsonFile::encode($type)).'\s*:\s*)('.self::$JSON_VALUE.')(.*)}s';
if (!$this->pregMatch($regex, $this->contents, $matches)) {
return false;
}

$links = $matches[3];

if (isset($decoded[$type][$package])) {

 $packageRegex = str_replace('/', '\\\\?/', preg_quote($package));

 $links = preg_replace('{"'.$packageRegex.'"(\s*:\s*)'.self::$JSON_STRING.'}i', addcslashes(JsonFile::encode($package).'${1}"'.$constraint.'"', '\\'), $links);
} else {
if ($this->pregMatch('#^\s*\{\s*\S+.*?(\s*\}\s*)$#s', $links, $match)) {

 $links = preg_replace(
'{'.preg_quote($match[1]).'$}',
addcslashes(',' . $this->newline . $this->indent . $this->indent . JsonFile::encode($package).': '.JsonFile::encode($constraint) . $match[1], '\\'),
$links
);
} else {

 $links = '{' . $this->newline .
$this->indent . $this->indent . JsonFile::encode($package).': '.JsonFile::encode($constraint) . $this->newline .
$this->indent . '}';
}
}

if (true === $sortPackages) {
$requirements = json_decode($links, true);
$this->sortPackages($requirements);
$links = $this->format($requirements);
}

$this->contents = $matches[1] . $matches[2] . $links . $matches[4];

return true;
}








private function sortPackages(array &$packages = array())
{
$prefix = function ($requirement) {
if (preg_match(PlatformRepository::PLATFORM_PACKAGE_REGEX, $requirement)) {
return preg_replace(
array(
'/^php/',
'/^hhvm/',
'/^ext/',
'/^lib/',
'/^\D/',
),
array(
'0-$0',
'1-$0',
'2-$0',
'3-$0',
'4-$0',
),
$requirement
);
}

return '5-'.$requirement;
};

uksort($packages, function ($a, $b) use ($prefix) {
return strnatcmp($prefix($a), $prefix($b));
});
}

public function addRepository($name, $config)
{
return $this->addSubNode('repositories', $name, $config);
}

public function removeRepository($name)
{
return $this->removeSubNode('repositories', $name);
}

public function addConfigSetting($name, $value)
{
return $this->addSubNode('config', $name, $value);
}

public function removeConfigSetting($name)
{
return $this->removeSubNode('config', $name);
}

public function addSubNode($mainNode, $name, $value)
{
$decoded = JsonFile::parseJson($this->contents);

$subName = null;
if (in_array($mainNode, array('config', 'repositories')) && false !== strpos($name, '.')) {
list($name, $subName) = explode('.', $name, 2);
}


 if (!isset($decoded[$mainNode])) {
if ($subName !== null) {
$this->addMainKey($mainNode, array($name => array($subName => $value)));
} else {
$this->addMainKey($mainNode, array($name => $value));
}

return true;
}


 $nodeRegex = '{^(\s*\{\s*(?:'.self::$JSON_STRING.'\s*:\s*'.self::$JSON_VALUE.'\s*,\s*)*?)'.
'('.preg_quote(JsonFile::encode($mainNode)).'\s*:\s*\{)('.self::$RECURSE_BLOCKS.')(\})(.*)}s';
try {
if (!$this->pregMatch($nodeRegex, $this->contents, $match)) {
return false;
}
} catch (\RuntimeException $e) {
if ($e->getCode() === PREG_BACKTRACK_LIMIT_ERROR) {
return false;
}
throw $e;
}

$children = $match[3];


 if (!@json_decode('{'.$children.'}')) {
return false;
}

$that = $this;


 if ($this->pregMatch('{("'.preg_quote($name).'"\s*:\s*)('.self::$JSON_VALUE.')(,?)}', $children, $matches)) {
$children = preg_replace_callback('{("'.preg_quote($name).'"\s*:\s*)('.self::$JSON_VALUE.')(,?)}', function ($matches) use ($name, $subName, $value, $that) {
if ($subName !== null) {
$curVal = json_decode($matches[2], true);
$curVal[$subName] = $value;
$value = $curVal;
}

return $matches[1] . $that->format($value, 1) . $matches[3];
}, $children);
} elseif ($this->pregMatch('#[^\s](\s*)$#', $children, $match)) {
if ($subName !== null) {
$value = array($subName => $value);
}


 $children = preg_replace(
'#'.$match[1].'$#',
addcslashes(',' . $this->newline . $this->indent . $this->indent . JsonFile::encode($name).': '.$this->format($value, 1) . $match[1], '\\'),
$children
);
} else {
if ($subName !== null) {
$value = array($subName => $value);
}


 $children = $this->newline . $this->indent . $this->indent . JsonFile::encode($name).': '.$this->format($value, 1) . $children;
}

$this->contents = preg_replace($nodeRegex, addcslashes('${1}${2}'.$children.'${4}${5}', '\\'), $this->contents);

return true;
}

public function removeSubNode($mainNode, $name)
{
$decoded = JsonFile::parseJson($this->contents);


 if (empty($decoded[$mainNode])) {
return true;
}


 $nodeRegex = '{^(\s*\{\s*(?:'.self::$JSON_STRING.'\s*:\s*'.self::$JSON_VALUE.'\s*,\s*)*?)'.
'('.preg_quote(JsonFile::encode($mainNode)).'\s*:\s*\{)('.self::$RECURSE_BLOCKS.')(\})(.*)}s';
try {
if (!$this->pregMatch($nodeRegex, $this->contents, $match)) {
return false;
}
} catch (\RuntimeException $e) {
if ($e->getCode() === PREG_BACKTRACK_LIMIT_ERROR) {
return false;
}
throw $e;
}

$children = $match[3];


 if (!@json_decode('{'.$children.'}', true)) {
return false;
}

$subName = null;
if (in_array($mainNode, array('config', 'repositories')) && false !== strpos($name, '.')) {
list($name, $subName) = explode('.', $name, 2);
}


 if (!isset($decoded[$mainNode][$name]) || ($subName && !isset($decoded[$mainNode][$name][$subName]))) {
return true;
}


 if ($this->pregMatch('{"'.preg_quote($name).'"\s*:}i', $children)) {

 if (preg_match_all('{"'.preg_quote($name).'"\s*:\s*(?:'.self::$JSON_VALUE.')}', $children, $matches)) {
$bestMatch = '';
foreach ($matches[0] as $match) {
if (strlen($bestMatch) < strlen($match)) {
$bestMatch = $match;
}
}
$childrenClean = preg_replace('{,\s*'.preg_quote($bestMatch).'}i', '', $children, -1, $count);
if (1 !== $count) {
$childrenClean = preg_replace('{'.preg_quote($bestMatch).'\s*,?\s*}i', '', $childrenClean, -1, $count);
if (1 !== $count) {
return false;
}
}
}
} else {
$childrenClean = $children;
}


 if (!trim($childrenClean)) {
$this->contents = preg_replace($nodeRegex, '$1$2'.$this->newline.$this->indent.'$4$5', $this->contents);


 if ($subName !== null) {
$curVal = json_decode('{'.$children.'}', true);
unset($curVal[$name][$subName]);
$this->addSubNode($mainNode, $name, $curVal[$name]);
}

return true;
}

$that = $this;
$this->contents = preg_replace_callback($nodeRegex, function ($matches) use ($that, $name, $subName, $childrenClean) {
if ($subName !== null) {
$curVal = json_decode('{'.$matches[3].'}', true);
unset($curVal[$name][$subName]);
$childrenClean = substr($that->format($curVal, 0), 1, -1);
}

return $matches[1] . $matches[2] . $childrenClean . $matches[4] . $matches[5];
}, $this->contents);

return true;
}

public function addMainKey($key, $content)
{
$decoded = JsonFile::parseJson($this->contents);
$content = $this->format($content);


 $regex = '{^(\s*\{\s*(?:'.self::$JSON_STRING.'\s*:\s*'.self::$JSON_VALUE.'\s*,\s*)*?)'.
'('.preg_quote(JsonFile::encode($key)).'\s*:\s*'.self::$JSON_VALUE.')(.*)}s';
if (isset($decoded[$key]) && $this->pregMatch($regex, $this->contents, $matches)) {

 if (!@json_decode('{'.$matches[2].'}')) {
return false;
}

$this->contents = $matches[1] . JsonFile::encode($key).': '.$content . $matches[3];

return true;
}


 if ($this->pregMatch('#[^{\s](\s*)\}$#', $this->contents, $match)) {
$this->contents = preg_replace(
'#'.$match[1].'\}$#',
addcslashes(',' . $this->newline . $this->indent . JsonFile::encode($key). ': '. $content . $this->newline . '}', '\\'),
$this->contents
);

return true;
}


 $this->contents = preg_replace(
'#\}$#',
addcslashes($this->indent . JsonFile::encode($key). ': '.$content . $this->newline . '}', '\\'),
$this->contents
);

return true;
}

public function format($data, $depth = 0)
{
if (is_array($data)) {
reset($data);

if (is_numeric(key($data))) {
foreach ($data as $key => $val) {
$data[$key] = $this->format($val, $depth + 1);
}

return '['.implode(', ', $data).']';
}

$out = '{' . $this->newline;
$elems = array();
foreach ($data as $key => $val) {
$elems[] = str_repeat($this->indent, $depth + 2) . JsonFile::encode($key). ': '.$this->format($val, $depth + 1);
}

return $out . implode(','.$this->newline, $elems) . $this->newline . str_repeat($this->indent, $depth + 1) . '}';
}

return JsonFile::encode($data);
}

protected function detectIndenting()
{
if ($this->pregMatch('{^([ \t]+)"}m', $this->contents, $match)) {
$this->indent = $match[1];
} else {
$this->indent = '    ';
}
}

protected function pregMatch($re, $str, &$matches = array())
{
$count = preg_match($re, $str, $matches);

if ($count === false) {
switch (preg_last_error()) {
case PREG_NO_ERROR:
throw new \RuntimeException('Failed to execute regex: PREG_NO_ERROR', PREG_NO_ERROR);
case PREG_INTERNAL_ERROR:
throw new \RuntimeException('Failed to execute regex: PREG_INTERNAL_ERROR', PREG_INTERNAL_ERROR);
case PREG_BACKTRACK_LIMIT_ERROR:
throw new \RuntimeException('Failed to execute regex: PREG_BACKTRACK_LIMIT_ERROR', PREG_BACKTRACK_LIMIT_ERROR);
case PREG_RECURSION_LIMIT_ERROR:
throw new \RuntimeException('Failed to execute regex: PREG_RECURSION_LIMIT_ERROR', PREG_RECURSION_LIMIT_ERROR);
case PREG_BAD_UTF8_ERROR:
throw new \RuntimeException('Failed to execute regex: PREG_BAD_UTF8_ERROR', PREG_BAD_UTF8_ERROR);
case PREG_BAD_UTF8_OFFSET_ERROR:
throw new \RuntimeException('Failed to execute regex: PREG_BAD_UTF8_OFFSET_ERROR', PREG_BAD_UTF8_OFFSET_ERROR);
default:
throw new \RuntimeException('Failed to execute regex: Unknown error');
}
}

return $count;
}
}
<?php











namespace Composer\Json;

use Exception;




class JsonValidationException extends Exception
{
protected $errors;

public function __construct($message, $errors = array(), Exception $previous = null)
{
$this->errors = $errors;
parent::__construct($message, 0, $previous);
}

public function getErrors()
{
return $this->errors;
}
}
<?php











namespace Composer\Package;

use Composer\Package\LinkConstraint\VersionConstraint;
use Composer\Package\Version\VersionParser;




class AliasPackage extends BasePackage implements CompletePackageInterface
{
protected $version;
protected $prettyVersion;
protected $dev;
protected $aliasOf;
protected $rootPackageAlias = false;
protected $stability;

protected $requires;
protected $devRequires;
protected $conflicts;
protected $provides;
protected $replaces;
protected $recommends;
protected $suggests;








public function __construct(PackageInterface $aliasOf, $version, $prettyVersion)
{
parent::__construct($aliasOf->getName());

$this->version = $version;
$this->prettyVersion = $prettyVersion;
$this->aliasOf = $aliasOf;
$this->stability = VersionParser::parseStability($version);
$this->dev = $this->stability === 'dev';

foreach (array('requires', 'devRequires', 'conflicts', 'provides', 'replaces') as $type) {
$links = $aliasOf->{'get' . ucfirst($type)}();
$this->$type = $this->replaceSelfVersionDependencies($links, $type);
}
}




public function getAliasOf()
{
return $this->aliasOf;
}




public function getVersion()
{
return $this->version;
}




public function getStability()
{
return $this->stability;
}




public function getPrettyVersion()
{
return $this->prettyVersion;
}




public function isDev()
{
return $this->dev;
}




public function getRequires()
{
return $this->requires;
}




public function getConflicts()
{
return $this->conflicts;
}




public function getProvides()
{
return $this->provides;
}




public function getReplaces()
{
return $this->replaces;
}




public function getDevRequires()
{
return $this->devRequires;
}










public function setRootPackageAlias($value)
{
return $this->rootPackageAlias = $value;
}





public function isRootPackageAlias()
{
return $this->rootPackageAlias;
}







protected function replaceSelfVersionDependencies(array $links, $linkType)
{
if (in_array($linkType, array('conflicts', 'provides', 'replaces'), true)) {
$newLinks = array();
foreach ($links as $link) {

 if ('self.version' === $link->getPrettyConstraint()) {
$newLinks[] = new Link($link->getSource(), $link->getTarget(), new VersionConstraint('=', $this->version), $linkType, $this->prettyVersion);
}
}
$links = array_merge($links, $newLinks);
} else {
foreach ($links as $index => $link) {
if ('self.version' === $link->getPrettyConstraint()) {
$links[$index] = new Link($link->getSource(), $link->getTarget(), new VersionConstraint('=', $this->version), $linkType, $this->prettyVersion);
}
}
}

return $links;
}





public function getType()
{
return $this->aliasOf->getType();
}
public function getTargetDir()
{
return $this->aliasOf->getTargetDir();
}
public function getExtra()
{
return $this->aliasOf->getExtra();
}
public function setInstallationSource($type)
{
$this->aliasOf->setInstallationSource($type);
}
public function getInstallationSource()
{
return $this->aliasOf->getInstallationSource();
}
public function getSourceType()
{
return $this->aliasOf->getSourceType();
}
public function getSourceUrl()
{
return $this->aliasOf->getSourceUrl();
}
public function getSourceUrls()
{
return $this->aliasOf->getSourceUrls();
}
public function getSourceReference()
{
return $this->aliasOf->getSourceReference();
}
public function setSourceReference($reference)
{
return $this->aliasOf->setSourceReference($reference);
}
public function setSourceMirrors($mirrors)
{
return $this->aliasOf->setSourceMirrors($mirrors);
}
public function getSourceMirrors()
{
return $this->aliasOf->getSourceMirrors();
}
public function getDistType()
{
return $this->aliasOf->getDistType();
}
public function getDistUrl()
{
return $this->aliasOf->getDistUrl();
}
public function getDistUrls()
{
return $this->aliasOf->getDistUrls();
}
public function getDistReference()
{
return $this->aliasOf->getDistReference();
}
public function setDistReference($reference)
{
return $this->aliasOf->setDistReference($reference);
}
public function getDistSha1Checksum()
{
return $this->aliasOf->getDistSha1Checksum();
}
public function setTransportOptions(array $options)
{
return $this->aliasOf->setTransportOptions($options);
}
public function getTransportOptions()
{
return $this->aliasOf->getTransportOptions();
}
public function setDistMirrors($mirrors)
{
return $this->aliasOf->setDistMirrors($mirrors);
}
public function getDistMirrors()
{
return $this->aliasOf->getDistMirrors();
}
public function getScripts()
{
return $this->aliasOf->getScripts();
}
public function getLicense()
{
return $this->aliasOf->getLicense();
}
public function getAutoload()
{
return $this->aliasOf->getAutoload();
}
public function getDevAutoload()
{
return $this->aliasOf->getDevAutoload();
}
public function getIncludePaths()
{
return $this->aliasOf->getIncludePaths();
}
public function getRepositories()
{
return $this->aliasOf->getRepositories();
}
public function getReleaseDate()
{
return $this->aliasOf->getReleaseDate();
}
public function getBinaries()
{
return $this->aliasOf->getBinaries();
}
public function getKeywords()
{
return $this->aliasOf->getKeywords();
}
public function getDescription()
{
return $this->aliasOf->getDescription();
}
public function getHomepage()
{
return $this->aliasOf->getHomepage();
}
public function getSuggests()
{
return $this->aliasOf->getSuggests();
}
public function getAuthors()
{
return $this->aliasOf->getAuthors();
}
public function getSupport()
{
return $this->aliasOf->getSupport();
}
public function getNotificationUrl()
{
return $this->aliasOf->getNotificationUrl();
}
public function getArchiveExcludes()
{
return $this->aliasOf->getArchiveExcludes();
}
public function isAbandoned()
{
return $this->aliasOf->isAbandoned();
}
public function getReplacementPackage()
{
return $this->aliasOf->getReplacementPackage();
}
public function __toString()
{
return parent::__toString().' (alias of '.$this->aliasOf->getVersion().')';
}
}
<?php











namespace Composer\Package\Archiver;

use Composer\Util\Filesystem;

use Symfony\Component\Finder;









class ArchivableFilesFinder extends \FilterIterator
{



protected $finder;







public function __construct($sources, array $excludes)
{
$fs = new Filesystem();

$sources = $fs->normalizePath($sources);

$filters = array(
new HgExcludeFilter($sources),
new GitExcludeFilter($sources),
new ComposerExcludeFilter($sources, $excludes),
);

$this->finder = new Finder\Finder();

$filter = function (\SplFileInfo $file) use ($sources, $filters, $fs) {
if ($file->isLink() && strpos($file->getLinkTarget(), $sources) !== 0) {
return false;
}

$relativePath = preg_replace(
'#^'.preg_quote($sources, '#').'#',
'',
$fs->normalizePath($file->getRealPath())
);

$exclude = false;
foreach ($filters as $filter) {
$exclude = $filter->filter($relativePath, $exclude);
}

return !$exclude;
};

if (method_exists($filter, 'bindTo')) {
$filter = $filter->bindTo(null);
}

$this->finder
->in($sources)
->filter($filter)
->ignoreVCS(true)
->ignoreDotFiles(false);

parent::__construct($this->finder->getIterator());
}

public function accept()
{
return !$this->getInnerIterator()->current()->isDir();
}
}
<?php











namespace Composer\Package\Archiver;

use Composer\Downloader\DownloadManager;
use Composer\Package\PackageInterface;
use Composer\Package\RootPackageInterface;
use Composer\Util\Filesystem;
use Composer\Json\JsonFile;





class ArchiveManager
{
protected $downloadManager;

protected $archivers = array();




protected $overwriteFiles = true;




public function __construct(DownloadManager $downloadManager)
{
$this->downloadManager = $downloadManager;
}




public function addArchiver(ArchiverInterface $archiver)
{
$this->archivers[] = $archiver;
}








public function setOverwriteFiles($overwriteFiles)
{
$this->overwriteFiles = $overwriteFiles;

return $this;
}








public function getPackageFilename(PackageInterface $package)
{
$nameParts = array(preg_replace('#[^a-z0-9-_]#i', '-', $package->getName()));

if (preg_match('{^[a-f0-9]{40}$}', $package->getDistReference())) {
$nameParts = array_merge($nameParts, array($package->getDistReference(), $package->getDistType()));
} else {
$nameParts = array_merge($nameParts, array($package->getPrettyVersion(), $package->getDistReference()));
}

if ($package->getSourceReference()) {
$nameParts[] = substr(sha1($package->getSourceReference()), 0, 6);
}

$name = implode('-', array_filter($nameParts, function ($p) {
return !empty($p);
}));

return str_replace('/', '-', $name);
}











public function archive(PackageInterface $package, $format, $targetDir)
{
if (empty($format)) {
throw new \InvalidArgumentException('Format must be specified');
}


 $usableArchiver = null;
foreach ($this->archivers as $archiver) {
if ($archiver->supports($format, $package->getSourceType())) {
$usableArchiver = $archiver;
break;
}
}


 if (null === $usableArchiver) {
throw new \RuntimeException(sprintf('No archiver found to support %s format', $format));
}

$filesystem = new Filesystem();
$packageName = $this->getPackageFilename($package);


 $filesystem->ensureDirectoryExists($targetDir);
$target = realpath($targetDir).'/'.$packageName.'.'.$format;
$filesystem->ensureDirectoryExists(dirname($target));

if (!$this->overwriteFiles && file_exists($target)) {
return $target;
}

if ($package instanceof RootPackageInterface) {
$sourcePath = realpath('.');
} else {

 $sourcePath = sys_get_temp_dir().'/composer_archive'.uniqid();
$filesystem->ensureDirectoryExists($sourcePath);


 $this->downloadManager->download($package, $sourcePath);


 if (file_exists($composerJsonPath = $sourcePath.'/composer.json')) {
$jsonFile = new JsonFile($composerJsonPath);
$jsonData = $jsonFile->read();
if (!empty($jsonData['archive']['exclude'])) {
$package->setArchiveExcludes($jsonData['archive']['exclude']);
}
}
}


 $tempTarget = sys_get_temp_dir().'/composer_archive'.uniqid().'.'.$format;
$filesystem->ensureDirectoryExists(dirname($tempTarget));

$archivePath = $usableArchiver->archive($sourcePath, $tempTarget, $format, $package->getArchiveExcludes());
rename($archivePath, $target);


 if (!$package instanceof RootPackageInterface) {
$filesystem->removeDirectory($sourcePath);
}
$filesystem->remove($tempTarget);

return $target;
}
}
<?php











namespace Composer\Package\Archiver;






interface ArchiverInterface
{










public function archive($sources, $target, $format, array $excludes = array());









public function supports($format, $sourceType);
}
<?php











namespace Composer\Package\Archiver;

use Symfony\Component\Finder;




abstract class BaseExcludeFilter
{



protected $sourcePath;




protected $excludePatterns;




public function __construct($sourcePath)
{
$this->sourcePath = $sourcePath;
$this->excludePatterns = array();
}











public function filter($relativePath, $exclude)
{
foreach ($this->excludePatterns as $patternData) {
list($pattern, $negate, $stripLeadingSlash) = $patternData;

if ($stripLeadingSlash) {
$path = substr($relativePath, 1);
} else {
$path = $relativePath;
}

if (preg_match($pattern, $path)) {
$exclude = !$negate;
}
}

return $exclude;
}









protected function parseLines(array $lines, $lineParser)
{
return array_filter(
array_map(
function ($line) use ($lineParser) {
$line = trim($line);

if (!$line || 0 === strpos($line, '#')) {
return;
}

return call_user_func($lineParser, $line);
},
$lines
),
function ($pattern) {
return $pattern !== null;
}
);
}








protected function generatePatterns($rules)
{
$patterns = array();
foreach ($rules as $rule) {
$patterns[] = $this->generatePattern($rule);
}

return $patterns;
}








protected function generatePattern($rule)
{
$negate = false;
$pattern = '#';

if (strlen($rule) && $rule[0] === '!') {
$negate = true;
$rule = substr($rule, 1);
}

if (strlen($rule) && $rule[0] === '/') {
$pattern .= '^/';
$rule = substr($rule, 1);
} elseif (strlen($rule) - 1 === strpos($rule, '/')) {
$pattern .= '/';
$rule = substr($rule, 0, -1);
} elseif (false === strpos($rule, '/')) {
$pattern .= '/';
}


 $pattern .= substr(Finder\Glob::toRegex($rule), 2, -2) . '(?=$|/)';

return array($pattern . '#', $negate, false);
}
}
<?php











namespace Composer\Package\Archiver;






class ComposerExcludeFilter extends BaseExcludeFilter
{




public function __construct($sourcePath, array $excludeRules)
{
parent::__construct($sourcePath);
$this->excludePatterns = $this->generatePatterns($excludeRules);
}
}
<?php











namespace Composer\Package\Archiver;








class GitExcludeFilter extends BaseExcludeFilter
{





public function __construct($sourcePath)
{
parent::__construct($sourcePath);

if (file_exists($sourcePath.'/.gitignore')) {
$this->excludePatterns = $this->parseLines(
file($sourcePath.'/.gitignore'),
array($this, 'parseGitIgnoreLine')
);
}
if (file_exists($sourcePath.'/.gitattributes')) {
$this->excludePatterns = array_merge(
$this->excludePatterns,
$this->parseLines(
file($sourcePath.'/.gitattributes'),
array($this, 'parseGitAttributesLine')
));
}
}








public function parseGitIgnoreLine($line)
{
return $this->generatePattern($line);
}








public function parseGitAttributesLine($line)
{
$parts = preg_split('#\s+#', $line);

if (count($parts) != 2) {
return null;
}

if ($parts[1] === 'export-ignore') {
return $this->generatePattern($parts[0]);
}
}
}
<?php











namespace Composer\Package\Archiver;

use Symfony\Component\Finder;






class HgExcludeFilter extends BaseExcludeFilter
{
const HG_IGNORE_REGEX = 1;
const HG_IGNORE_GLOB = 2;





protected $patternMode;






public function __construct($sourcePath)
{
parent::__construct($sourcePath);

$this->patternMode = self::HG_IGNORE_REGEX;

if (file_exists($sourcePath.'/.hgignore')) {
$this->excludePatterns = $this->parseLines(
file($sourcePath.'/.hgignore'),
array($this, 'parseHgIgnoreLine')
);
}
}








public function parseHgIgnoreLine($line)
{
if (preg_match('#^syntax\s*:\s*(glob|regexp)$#', $line, $matches)) {
if ($matches[1] === 'glob') {
$this->patternMode = self::HG_IGNORE_GLOB;
} else {
$this->patternMode = self::HG_IGNORE_REGEX;
}

return null;
}

if ($this->patternMode == self::HG_IGNORE_GLOB) {
return $this->patternFromGlob($line);
} else {
return $this->patternFromRegex($line);
}
}








protected function patternFromGlob($line)
{
$pattern = '#'.substr(Finder\Glob::toRegex($line), 2, -1).'#';
$pattern = str_replace('[^/]*', '.*', $pattern);

return array($pattern, false, true);
}








public function patternFromRegex($line)
{

 $pattern = '#'.preg_replace('/((?:\\\\\\\\)*)(\\\\?)#/', '\1\2\2\\#', $line).'#';

return array($pattern, false, true);
}
}
<?php











namespace Composer\Package\Archiver;






class PharArchiver implements ArchiverInterface
{
protected static $formats = array(
'zip' => \Phar::ZIP,
'tar' => \Phar::TAR,
);




public function archive($sources, $target, $format, array $excludes = array())
{
$sources = realpath($sources);


 if (file_exists($target)) {
unlink($target);
}

try {
$phar = new \PharData($target, null, null, static::$formats[$format]);
$files = new ArchivableFilesFinder($sources, $excludes);
$phar->buildFromIterator($files, $sources);

return $target;
} catch (\UnexpectedValueException $e) {
$message = sprintf("Could not create archive '%s' from '%s': %s",
$target,
$sources,
$e->getMessage()
);

throw new \RuntimeException($message, $e->getCode(), $e);
}
}




public function supports($format, $sourceType)
{
return isset(static::$formats[$format]);
}
}
<?php











namespace Composer\Package;

use Composer\Repository\RepositoryInterface;
use Composer\Repository\PlatformRepository;






abstract class BasePackage implements PackageInterface
{
public static $supportedLinkTypes = array(
'require' => array('description' => 'requires', 'method' => 'requires'),
'conflict' => array('description' => 'conflicts', 'method' => 'conflicts'),
'provide' => array('description' => 'provides', 'method' => 'provides'),
'replace' => array('description' => 'replaces', 'method' => 'replaces'),
'require-dev' => array('description' => 'requires (for development)', 'method' => 'devRequires'),
);

const STABILITY_STABLE = 0;
const STABILITY_RC = 5;
const STABILITY_BETA = 10;
const STABILITY_ALPHA = 15;
const STABILITY_DEV = 20;

public static $stabilities = array(
'stable' => self::STABILITY_STABLE,
'RC' => self::STABILITY_RC,
'beta' => self::STABILITY_BETA,
'alpha' => self::STABILITY_ALPHA,
'dev' => self::STABILITY_DEV,
);





public $id;

protected $name;
protected $prettyName;

protected $repository;
protected $transportOptions;






public function __construct($name)
{
$this->prettyName = $name;
$this->name = strtolower($name);
$this->id = -1;
$this->transportOptions = array();
}




public function getName()
{
return $this->name;
}




public function getPrettyName()
{
return $this->prettyName;
}




public function getNames()
{
$names = array(
$this->getName() => true,
);

foreach ($this->getProvides() as $link) {
$names[$link->getTarget()] = true;
}

foreach ($this->getReplaces() as $link) {
$names[$link->getTarget()] = true;
}

return array_keys($names);
}




public function setId($id)
{
$this->id = $id;
}




public function getId()
{
return $this->id;
}




public function setRepository(RepositoryInterface $repository)
{
if ($this->repository && $repository !== $this->repository) {
throw new \LogicException('A package can only be added to one repository');
}
$this->repository = $repository;
}




public function getRepository()
{
return $this->repository;
}




public function getTransportOptions()
{
return $this->transportOptions;
}






public function setTransportOptions(array $options)
{
$this->transportOptions = $options;
}






public function isPlatform()
{
return $this->getRepository() instanceof PlatformRepository;
}






public function getUniqueName()
{
return $this->getName().'-'.$this->getVersion();
}

public function equals(PackageInterface $package)
{
$self = $this;
if ($this instanceof AliasPackage) {
$self = $this->getAliasOf();
}
if ($package instanceof AliasPackage) {
$package = $package->getAliasOf();
}

return $package === $self;
}






public function __toString()
{
return $this->getUniqueName();
}

public function getPrettyString()
{
return $this->getPrettyName().' '.$this->getPrettyVersion();
}

public function __clone()
{
$this->repository = null;
$this->id = -1;
}
}
<?php











namespace Composer\Package;






class CompletePackage extends Package implements CompletePackageInterface
{
protected $repositories;
protected $license = array();
protected $keywords;
protected $authors;
protected $description;
protected $homepage;
protected $scripts = array();
protected $support = array();
protected $abandoned = false;




public function setScripts(array $scripts)
{
$this->scripts = $scripts;
}




public function getScripts()
{
return $this->scripts;
}






public function setRepositories($repositories)
{
$this->repositories = $repositories;
}




public function getRepositories()
{
return $this->repositories;
}






public function setLicense(array $license)
{
$this->license = $license;
}




public function getLicense()
{
return $this->license;
}






public function setKeywords(array $keywords)
{
$this->keywords = $keywords;
}




public function getKeywords()
{
return $this->keywords;
}






public function setAuthors(array $authors)
{
$this->authors = $authors;
}




public function getAuthors()
{
return $this->authors;
}






public function setDescription($description)
{
$this->description = $description;
}




public function getDescription()
{
return $this->description;
}






public function setHomepage($homepage)
{
$this->homepage = $homepage;
}




public function getHomepage()
{
return $this->homepage;
}






public function setSupport(array $support)
{
$this->support = $support;
}




public function getSupport()
{
return $this->support;
}




public function isAbandoned()
{
return (boolean) $this->abandoned;
}




public function setAbandoned($abandoned)
{
$this->abandoned = $abandoned;
}






public function getReplacementPackage()
{
return is_string($this->abandoned) ? $this->abandoned : null;
}
}
<?php











namespace Composer\Package;






interface CompletePackageInterface extends PackageInterface
{





public function getScripts();








public function getRepositories();






public function getLicense();






public function getKeywords();






public function getDescription();






public function getHomepage();








public function getAuthors();






public function getSupport();






public function isAbandoned();






public function getReplacementPackage();
}
<?php











namespace Composer\Package\Dumper;

use Composer\Package\BasePackage;
use Composer\Package\PackageInterface;
use Composer\Package\CompletePackageInterface;
use Composer\Package\RootPackageInterface;





class ArrayDumper
{
public function dump(PackageInterface $package)
{
$keys = array(
'binaries' => 'bin',
'type',
'extra',
'installationSource' => 'installation-source',
'autoload',
'devAutoload' => 'autoload-dev',
'notificationUrl' => 'notification-url',
'includePaths' => 'include-path',
);

$data = array();
$data['name'] = $package->getPrettyName();
$data['version'] = $package->getPrettyVersion();
$data['version_normalized'] = $package->getVersion();

if ($package->getTargetDir()) {
$data['target-dir'] = $package->getTargetDir();
}

if ($package->getSourceType()) {
$data['source']['type'] = $package->getSourceType();
$data['source']['url'] = $package->getSourceUrl();
$data['source']['reference'] = $package->getSourceReference();
if ($mirrors = $package->getSourceMirrors()) {
$data['source']['mirrors'] = $mirrors;
}
}

if ($package->getDistType()) {
$data['dist']['type'] = $package->getDistType();
$data['dist']['url'] = $package->getDistUrl();
$data['dist']['reference'] = $package->getDistReference();
$data['dist']['shasum'] = $package->getDistSha1Checksum();
if ($mirrors = $package->getDistMirrors()) {
$data['dist']['mirrors'] = $mirrors;
}
}

if ($package->getArchiveExcludes()) {
$data['archive']['exclude'] = $package->getArchiveExcludes();
}

foreach (BasePackage::$supportedLinkTypes as $type => $opts) {
if ($links = $package->{'get'.ucfirst($opts['method'])}()) {
foreach ($links as $link) {
$data[$type][$link->getTarget()] = $link->getPrettyConstraint();
}
ksort($data[$type]);
}
}

if ($packages = $package->getSuggests()) {
ksort($packages);
$data['suggest'] = $packages;
}

if ($package->getReleaseDate()) {
$data['time'] = $package->getReleaseDate()->format('Y-m-d H:i:s');
}

$data = $this->dumpValues($package, $keys, $data);

if ($package instanceof CompletePackageInterface) {
$keys = array(
'scripts',
'license',
'authors',
'description',
'homepage',
'keywords',
'repositories',
'support',
);

$data = $this->dumpValues($package, $keys, $data);

if (isset($data['keywords']) && is_array($data['keywords'])) {
sort($data['keywords']);
}

if ($package->isAbandoned()) {
$data['abandoned'] = $package->getReplacementPackage() ?: true;
}
}

if ($package instanceof RootPackageInterface) {
$minimumStability = $package->getMinimumStability();
if ($minimumStability) {
$data['minimum-stability'] = $minimumStability;
}
}

if (count($package->getTransportOptions()) > 0) {
$data['transport-options'] = $package->getTransportOptions();
}

return $data;
}

private function dumpValues(PackageInterface $package, array $keys, array $data)
{
foreach ($keys as $method => $key) {
if (is_numeric($method)) {
$method = $key;
}

$getter = 'get'.ucfirst($method);
$value = $package->$getter();

if (null !== $value && !(is_array($value) && 0 === count($value))) {
$data[$key] = $value;
}
}

return $data;
}
}
<?php











namespace Composer\Package;

use Composer\Package\LinkConstraint\LinkConstraintInterface;






class Link
{
protected $source;
protected $target;
protected $constraint;
protected $description;
protected $prettyConstraint;










public function __construct($source, $target, LinkConstraintInterface $constraint = null, $description = 'relates to', $prettyConstraint = null)
{
$this->source = strtolower($source);
$this->target = strtolower($target);
$this->constraint = $constraint;
$this->description = $description;
$this->prettyConstraint = $prettyConstraint;
}

public function getSource()
{
return $this->source;
}

public function getTarget()
{
return $this->target;
}

public function getConstraint()
{
return $this->constraint;
}

public function getPrettyConstraint()
{
if (null === $this->prettyConstraint) {
throw new \UnexpectedValueException(sprintf('Link %s has been misconfigured and had no prettyConstraint given.', $this));
}

return $this->prettyConstraint;
}

public function __toString()
{
return $this->source.' '.$this->description.' '.$this->target.' ('.$this->constraint.')';
}

public function getPrettyString(PackageInterface $sourcePackage)
{
return $sourcePackage->getPrettyString().' '.$this->description.' '.$this->target.' '.$this->constraint->getPrettyString().'';
}
}
<?php











namespace Composer\Package\LinkConstraint;






class EmptyConstraint implements LinkConstraintInterface
{
protected $prettyString;

public function matches(LinkConstraintInterface $provider)
{
return true;
}

public function setPrettyString($prettyString)
{
$this->prettyString = $prettyString;
}

public function getPrettyString()
{
if ($this->prettyString) {
return $this->prettyString;
}

return $this->__toString();
}

public function __toString()
{
return '[]';
}
}
<?php











namespace Composer\Package\LinkConstraint;






interface LinkConstraintInterface
{
public function matches(LinkConstraintInterface $provider);
public function setPrettyString($prettyString);
public function getPrettyString();
public function __toString();
}
<?php











namespace Composer\Package\LinkConstraint;







class MultiConstraint implements LinkConstraintInterface
{
protected $constraints;
protected $prettyString;
protected $conjunctive;







public function __construct(array $constraints, $conjunctive = true)
{
$this->constraints = $constraints;
$this->conjunctive = $conjunctive;
}

public function matches(LinkConstraintInterface $provider)
{
if (false === $this->conjunctive) {
foreach ($this->constraints as $constraint) {
if ($constraint->matches($provider)) {
return true;
}
}

return false;
}

foreach ($this->constraints as $constraint) {
if (!$constraint->matches($provider)) {
return false;
}
}

return true;
}

public function setPrettyString($prettyString)
{
$this->prettyString = $prettyString;
}

public function getPrettyString()
{
if ($this->prettyString) {
return $this->prettyString;
}

return $this->__toString();
}

public function __toString()
{
$constraints = array();
foreach ($this->constraints as $constraint) {
$constraints[] = $constraint->__toString();
}

return '['.implode($this->conjunctive ? ' ' : ' || ', $constraints).']';
}
}
<?php











namespace Composer\Package\LinkConstraint;






abstract class SpecificConstraint implements LinkConstraintInterface
{
protected $prettyString;

public function matches(LinkConstraintInterface $provider)
{
if ($provider instanceof MultiConstraint) {

 return $provider->matches($this);
} elseif ($provider instanceof $this) {
return $this->matchSpecific($provider);
}

return true;
}

public function setPrettyString($prettyString)
{
$this->prettyString = $prettyString;
}

public function getPrettyString()
{
if ($this->prettyString) {
return $this->prettyString;
}

return $this->__toString();
}


 
 
}
<?php











namespace Composer\Package\LinkConstraint;








class VersionConstraint extends SpecificConstraint
{
private $operator;
private $version;







public function __construct($operator, $version)
{
if ('=' === $operator) {
$operator = '==';
}

if ('<>' === $operator) {
$operator = '!=';
}

$this->operator = $operator;
$this->version = $version;
}

public function versionCompare($a, $b, $operator, $compareBranches = false)
{
$aIsBranch = 'dev-' === substr($a, 0, 4);
$bIsBranch = 'dev-' === substr($b, 0, 4);
if ($aIsBranch && $bIsBranch) {
return $operator == '==' && $a === $b;
}


 if (!$compareBranches && ($aIsBranch || $bIsBranch)) {
return false;
}

return version_compare($a, $b, $operator);
}






public function matchSpecific(VersionConstraint $provider, $compareBranches = false)
{
static $cache = array();
if (isset($cache[$this->operator][$this->version][$provider->operator][$provider->version][$compareBranches])) {
return $cache[$this->operator][$this->version][$provider->operator][$provider->version][$compareBranches];
}

return $cache[$this->operator][$this->version][$provider->operator][$provider->version][$compareBranches] =
$this->doMatchSpecific($provider, $compareBranches);
}






private function doMatchSpecific(VersionConstraint $provider, $compareBranches = false)
{
$noEqualOp = str_replace('=', '', $this->operator);
$providerNoEqualOp = str_replace('=', '', $provider->operator);

$isEqualOp = '==' === $this->operator;
$isNonEqualOp = '!=' === $this->operator;
$isProviderEqualOp = '==' === $provider->operator;
$isProviderNonEqualOp = '!=' === $provider->operator;


 
 if ($isNonEqualOp || $isProviderNonEqualOp) {
return !$isEqualOp && !$isProviderEqualOp
|| $this->versionCompare($provider->version, $this->version, '!=', $compareBranches);
}


 
 if ($this->operator != '==' && $noEqualOp == $providerNoEqualOp) {
return true;
}

if ($this->versionCompare($provider->version, $this->version, $this->operator, $compareBranches)) {

 
 if ($provider->version == $this->version && $provider->operator == $providerNoEqualOp && $this->operator != $noEqualOp) {
return false;
}

return true;
}

return false;
}

public function __toString()
{
return $this->operator.' '.$this->version;
}
}
<?php











namespace Composer\Package\Loader;

use Composer\Package;
use Composer\Package\AliasPackage;
use Composer\Package\RootAliasPackage;
use Composer\Package\RootPackageInterface;
use Composer\Package\Version\VersionParser;





class ArrayLoader implements LoaderInterface
{
protected $versionParser;
protected $loadOptions;

public function __construct(VersionParser $parser = null, $loadOptions = false)
{
if (!$parser) {
$parser = new VersionParser;
}
$this->versionParser = $parser;
$this->loadOptions = $loadOptions;
}

public function load(array $config, $class = 'Composer\Package\CompletePackage')
{
if (!isset($config['name'])) {
throw new \UnexpectedValueException('Unknown package has no name defined ('.json_encode($config).').');
}
if (!isset($config['version'])) {
throw new \UnexpectedValueException('Package '.$config['name'].' has no version defined.');
}


 if (isset($config['version_normalized'])) {
$version = $config['version_normalized'];
} else {
$version = $this->versionParser->normalize($config['version']);
}
$package = new $class($config['name'], $version, $config['version']);
$package->setType(isset($config['type']) ? strtolower($config['type']) : 'library');

if (isset($config['target-dir'])) {
$package->setTargetDir($config['target-dir']);
}

if (isset($config['extra']) && is_array($config['extra'])) {
$package->setExtra($config['extra']);
}

if (isset($config['bin'])) {
if (!is_array($config['bin'])) {
throw new \UnexpectedValueException('Package '.$config['name'].'\'s bin key should be an array, '.gettype($config['bin']).' given.');
}
foreach ($config['bin'] as $key => $bin) {
$config['bin'][$key] = ltrim($bin, '/');
}
$package->setBinaries($config['bin']);
}

if (isset($config['installation-source'])) {
$package->setInstallationSource($config['installation-source']);
}

if (isset($config['source'])) {
if (!isset($config['source']['type']) || !isset($config['source']['url']) || !isset($config['source']['reference'])) {
throw new \UnexpectedValueException(sprintf(
"Package %s's source key should be specified as {\"type\": ..., \"url\": ..., \"reference\": ...},\n%s given.",
$config['name'],
json_encode($config['source'])
));
}
$package->setSourceType($config['source']['type']);
$package->setSourceUrl($config['source']['url']);
$package->setSourceReference($config['source']['reference']);
if (isset($config['source']['mirrors'])) {
$package->setSourceMirrors($config['source']['mirrors']);
}
}

if (isset($config['dist'])) {
if (!isset($config['dist']['type'])
|| !isset($config['dist']['url'])) {
throw new \UnexpectedValueException(sprintf(
"Package %s's dist key should be specified as ".
"{\"type\": ..., \"url\": ..., \"reference\": ..., \"shasum\": ...},\n%s given.",
$config['name'],
json_encode($config['dist'])
));
}
$package->setDistType($config['dist']['type']);
$package->setDistUrl($config['dist']['url']);
$package->setDistReference(isset($config['dist']['reference']) ? $config['dist']['reference'] : null);
$package->setDistSha1Checksum(isset($config['dist']['shasum']) ? $config['dist']['shasum'] : null);
if (isset($config['dist']['mirrors'])) {
$package->setDistMirrors($config['dist']['mirrors']);
}
}

foreach (Package\BasePackage::$supportedLinkTypes as $type => $opts) {
if (isset($config[$type])) {
$method = 'set'.ucfirst($opts['method']);
$package->{$method}(
$this->versionParser->parseLinks(
$package->getName(),
$package->getPrettyVersion(),
$opts['description'],
$config[$type]
)
);
}
}

if (isset($config['suggest']) && is_array($config['suggest'])) {
foreach ($config['suggest'] as $target => $reason) {
if ('self.version' === trim($reason)) {
$config['suggest'][$target] = $package->getPrettyVersion();
}
}
$package->setSuggests($config['suggest']);
}

if (isset($config['autoload'])) {
$package->setAutoload($config['autoload']);
}

if (isset($config['autoload-dev'])) {
$package->setDevAutoload($config['autoload-dev']);
}

if (isset($config['include-path'])) {
$package->setIncludePaths($config['include-path']);
}

if (!empty($config['time'])) {
$time = preg_match('/^\d+$/D', $config['time']) ? '@'.$config['time'] : $config['time'];

try {
$date = new \DateTime($time, new \DateTimeZone('UTC'));
$package->setReleaseDate($date);
} catch (\Exception $e) {
}
}

if (!empty($config['notification-url'])) {
$package->setNotificationUrl($config['notification-url']);
}

if (!empty($config['archive']['exclude'])) {
$package->setArchiveExcludes($config['archive']['exclude']);
}

if ($package instanceof Package\CompletePackageInterface) {
if (isset($config['scripts']) && is_array($config['scripts'])) {
foreach ($config['scripts'] as $event => $listeners) {
$config['scripts'][$event] = (array) $listeners;
}
$package->setScripts($config['scripts']);
}

if (!empty($config['description']) && is_string($config['description'])) {
$package->setDescription($config['description']);
}

if (!empty($config['homepage']) && is_string($config['homepage'])) {
$package->setHomepage($config['homepage']);
}

if (!empty($config['keywords']) && is_array($config['keywords'])) {
$package->setKeywords($config['keywords']);
}

if (!empty($config['license'])) {
$package->setLicense(is_array($config['license']) ? $config['license'] : array($config['license']));
}

if (!empty($config['authors']) && is_array($config['authors'])) {
$package->setAuthors($config['authors']);
}

if (isset($config['support'])) {
$package->setSupport($config['support']);
}

if (isset($config['abandoned'])) {
$package->setAbandoned($config['abandoned']);
}
}

if ($aliasNormalized = $this->getBranchAlias($config)) {
if ($package instanceof RootPackageInterface) {
$package = new RootAliasPackage($package, $aliasNormalized, preg_replace('{(\.9{7})+}', '.x', $aliasNormalized));
} else {
$package = new AliasPackage($package, $aliasNormalized, preg_replace('{(\.9{7})+}', '.x', $aliasNormalized));
}
}

if ($this->loadOptions && isset($config['transport-options'])) {
$package->setTransportOptions($config['transport-options']);
}

return $package;
}







public function getBranchAlias(array $config)
{
if (('dev-' !== substr($config['version'], 0, 4) && '-dev' !== substr($config['version'], -4))
|| !isset($config['extra']['branch-alias'])
|| !is_array($config['extra']['branch-alias'])
) {
return;
}

foreach ($config['extra']['branch-alias'] as $sourceBranch => $targetBranch) {

 if ('-dev' !== substr($targetBranch, -4)) {
continue;
}


 $validatedTargetBranch = $this->versionParser->normalizeBranch(substr($targetBranch, 0, -4));
if ('-dev' !== substr($validatedTargetBranch, -4)) {
continue;
}


 if (strtolower($config['version']) !== strtolower($sourceBranch)) {
continue;
}


 if (($sourcePrefix = $this->versionParser->parseNumericAliasPrefix($sourceBranch))
&& ($targetPrefix = $this->versionParser->parseNumericAliasPrefix($targetBranch))
&& (stripos($targetPrefix, $sourcePrefix) !== 0)
) {
continue;
}

return $validatedTargetBranch;
}
}
}
<?php











namespace Composer\Package\Loader;




class InvalidPackageException extends \Exception
{
private $errors;
private $warnings;
private $data;

public function __construct(array $errors, array $warnings, array $data)
{
$this->errors = $errors;
$this->warnings = $warnings;
$this->data = $data;
parent::__construct("Invalid package information: \n".implode("\n", array_merge($errors, $warnings)));
}

public function getData()
{
return $this->data;
}

public function getErrors()
{
return $this->errors;
}

public function getWarnings()
{
return $this->warnings;
}
}
<?php











namespace Composer\Package\Loader;

use Composer\Json\JsonFile;




class JsonLoader
{
private $loader;

public function __construct(LoaderInterface $loader)
{
$this->loader = $loader;
}





public function load($json)
{
if ($json instanceof JsonFile) {
$config = $json->read();
} elseif (file_exists($json)) {
$config = JsonFile::parseJson(file_get_contents($json), $json);
} elseif (is_string($json)) {
$config = JsonFile::parseJson($json);
}

return $this->loader->load($config);
}
}
<?php











namespace Composer\Package\Loader;






interface LoaderInterface
{







public function load(array $package, $class = 'Composer\Package\CompletePackage');
}
<?php











namespace Composer\Package\Loader;

use Composer\Package\BasePackage;
use Composer\Package\AliasPackage;
use Composer\Config;
use Composer\Factory;
use Composer\Package\Version\VersionParser;
use Composer\Repository\RepositoryManager;
use Composer\Repository\Vcs\HgDriver;
use Composer\IO\NullIO;
use Composer\Util\ProcessExecutor;
use Composer\Util\Git as GitUtil;
use Composer\Util\Svn as SvnUtil;








class RootPackageLoader extends ArrayLoader
{
private $manager;
private $config;
private $process;

public function __construct(RepositoryManager $manager, Config $config, VersionParser $parser = null, ProcessExecutor $process = null)
{
$this->manager = $manager;
$this->config = $config;
$this->process = $process ?: new ProcessExecutor();
parent::__construct($parser);
}

public function load(array $config, $class = 'Composer\Package\RootPackage')
{
if (!isset($config['name'])) {
$config['name'] = '__root__';
}
if (!isset($config['version'])) {

 if (getenv('COMPOSER_ROOT_VERSION')) {
$version = getenv('COMPOSER_ROOT_VERSION');
} else {
$version = $this->guessVersion($config);
}

if (!$version) {
$version = '1.0.0';
}

$config['version'] = $version;
}

$realPackage = $package = parent::load($config, $class);

if ($realPackage instanceof AliasPackage) {
$realPackage = $package->getAliasOf();
}

if (isset($config['minimum-stability'])) {
$realPackage->setMinimumStability(VersionParser::normalizeStability($config['minimum-stability']));
}

$aliases = array();
$stabilityFlags = array();
$references = array();
foreach (array('require', 'require-dev') as $linkType) {
if (isset($config[$linkType])) {
$linkInfo = BasePackage::$supportedLinkTypes[$linkType];
$method = 'get'.ucfirst($linkInfo['method']);
$links = array();
foreach ($realPackage->$method() as $link) {
$links[$link->getTarget()] = $link->getConstraint()->getPrettyString();
}
$aliases = $this->extractAliases($links, $aliases);
$stabilityFlags = $this->extractStabilityFlags($links, $stabilityFlags, $realPackage->getMinimumStability());
$references = $this->extractReferences($links, $references);
}
}

$realPackage->setAliases($aliases);
$realPackage->setStabilityFlags($stabilityFlags);
$realPackage->setReferences($references);

if (isset($config['prefer-stable'])) {
$realPackage->setPreferStable((bool) $config['prefer-stable']);
}

$repos = Factory::createDefaultRepositories(null, $this->config, $this->manager);
foreach ($repos as $repo) {
$this->manager->addRepository($repo);
}
$realPackage->setRepositories($this->config->getRepositories());

return $package;
}

private function extractAliases(array $requires, array $aliases)
{
foreach ($requires as $reqName => $reqVersion) {
if (preg_match('{^([^,\s#]+)(?:#[^ ]+)? +as +([^,\s]+)$}', $reqVersion, $match)) {
$aliases[] = array(
'package' => strtolower($reqName),
'version' => $this->versionParser->normalize($match[1], $reqVersion),
'alias' => $match[2],
'alias_normalized' => $this->versionParser->normalize($match[2], $reqVersion),
);
}
}

return $aliases;
}

private function extractStabilityFlags(array $requires, array $stabilityFlags, $minimumStability)
{
$stabilities = BasePackage::$stabilities;
$minimumStability = $stabilities[$minimumStability];
foreach ($requires as $reqName => $reqVersion) {

 if (preg_match('{^[^@]*?@('.implode('|', array_keys($stabilities)).')$}i', $reqVersion, $match)) {
$name = strtolower($reqName);
$stability = $stabilities[VersionParser::normalizeStability($match[1])];

if (isset($stabilityFlags[$name]) && $stabilityFlags[$name] > $stability) {
continue;
}
$stabilityFlags[$name] = $stability;

continue;
}


 
 $reqVersion = preg_replace('{^([^,\s@]+) as .+$}', '$1', $reqVersion);
if (preg_match('{^[^,\s@]+$}', $reqVersion) && 'stable' !== ($stabilityName = VersionParser::parseStability($reqVersion))) {
$name = strtolower($reqName);
$stability = $stabilities[$stabilityName];
if ((isset($stabilityFlags[$name]) && $stabilityFlags[$name] > $stability) || ($minimumStability > $stability)) {
continue;
}
$stabilityFlags[$name] = $stability;
}
}

return $stabilityFlags;
}

private function extractReferences(array $requires, array $references)
{
foreach ($requires as $reqName => $reqVersion) {
$reqVersion = preg_replace('{^([^,\s@]+) as .+$}', '$1', $reqVersion);
if (preg_match('{^[^,\s@]+?#([a-f0-9]+)$}', $reqVersion, $match) && 'dev' === ($stabilityName = VersionParser::parseStability($reqVersion))) {
$name = strtolower($reqName);
$references[$name] = $match[1];
}
}

return $references;
}

private function guessVersion(array $config)
{
if (function_exists('proc_open')) {
$version = $this->guessGitVersion($config);
if (null !== $version) {
return $version;
}

$version = $this->guessHgVersion($config);
if (null !== $version) {
return $version;
}

return $this->guessSvnVersion($config);
}
}

private function guessGitVersion(array $config)
{
GitUtil::cleanEnv();


 if (0 === $this->process->execute('git describe --exact-match --tags', $output)) {
try {
return $this->versionParser->normalize(trim($output));
} catch (\Exception $e) {
}
}


 if (0 === $this->process->execute('git branch --no-color --no-abbrev -v', $output)) {
$branches = array();
$isFeatureBranch = false;
$version = null;


 foreach ($this->process->splitLines($output) as $branch) {
if ($branch && preg_match('{^(?:\* ) *(\(no branch\)|\(detached from \S+\)|\S+) *([a-f0-9]+) .*$}', $branch, $match)) {
if ($match[1] === '(no branch)' || substr($match[1], 0, 10) === '(detached ') {
$version = 'dev-'.$match[2];
$isFeatureBranch = true;
} else {
$version = $this->versionParser->normalizeBranch($match[1]);
$isFeatureBranch = 0 === strpos($version, 'dev-');
if ('9999999-dev' === $version) {
$version = 'dev-'.$match[1];
}
}
}

if ($branch && !preg_match('{^ *[^/]+/HEAD }', $branch)) {
if (preg_match('{^(?:\* )? *(\S+) *([a-f0-9]+) .*$}', $branch, $match)) {
$branches[] = $match[1];
}
}
}

if (!$isFeatureBranch) {
return $version;
}


 $version = $this->guessFeatureVersion($config, $version, $branches, 'git rev-list %candidate%..%branch%');

return $version;
}
}

private function guessHgVersion(array $config)
{

 if (0 === $this->process->execute('hg branch', $output)) {
$branch = trim($output);
$version = $this->versionParser->normalizeBranch($branch);
$isFeatureBranch = 0 === strpos($version, 'dev-');

if ('9999999-dev' === $version) {
$version = 'dev-'.$branch;
}

if (!$isFeatureBranch) {
return $version;
}


 $config = array('url' => getcwd());
$driver = new HgDriver($config, new NullIO(), $this->config, $this->process);
$branches = array_keys($driver->getBranches());


 $version = $this->guessFeatureVersion($config, $version, $branches, 'hg log -r "not ancestors(\'%candidate%\') and ancestors(\'%branch%\')" --template "{node}\\n"');

return $version;
}
}

private function guessFeatureVersion(array $config, $version, array $branches, $scmCmdline)
{

 
 if ((isset($config['extra']['branch-alias']) && !isset($config['extra']['branch-alias'][$version]))
|| strpos(json_encode($config), '"self.version"')
) {
$branch = preg_replace('{^dev-}', '', $version);
$length = PHP_INT_MAX;

$nonFeatureBranches = '';
if (!empty($config['non-feature-branches'])) {
$nonFeatureBranches = implode('|', $config['non-feature-branches']);
}

foreach ($branches as $candidate) {

 if ($candidate === $branch && preg_match('{^(' . $nonFeatureBranches . ')$}', $candidate)) {
return $version;
}


 if ($candidate === $branch || !preg_match('{^(master|trunk|default|develop|\d+\..+)$}', $candidate, $match)) {
continue;
}

$cmdLine = str_replace(array('%candidate%', '%branch%'), array($candidate, $branch), $scmCmdline);
if (0 !== $this->process->execute($cmdLine, $output)) {
continue;
}

if (strlen($output) < $length) {
$length = strlen($output);
$version = $this->versionParser->normalizeBranch($candidate);
if ('9999999-dev' === $version) {
$version = 'dev-'.$match[1];
}
}
}
}

return $version;
}

private function guessSvnVersion(array $config)
{
SvnUtil::cleanEnv();


 if (0 === $this->process->execute('svn info --xml', $output)) {
$trunkPath = isset($config['trunk-path']) ? preg_quote($config['trunk-path'], '#') : 'trunk';
$branchesPath = isset($config['branches-path']) ? preg_quote($config['branches-path'], '#') : 'branches';
$tagsPath = isset($config['tags-path']) ? preg_quote($config['tags-path'], '#') : 'tags';

$urlPattern = '#<url>.*/('.$trunkPath.'|('.$branchesPath.'|'. $tagsPath .')/(.*))</url>#';

if (preg_match($urlPattern, $output, $matches)) {
if (isset($matches[2]) && ($branchesPath === $matches[2] || $tagsPath === $matches[2])) {

 $version = $this->versionParser->normalizeBranch($matches[3]);
if ('9999999-dev' === $version) {
$version = 'dev-'.$matches[3];
}

return $version;
}

return $this->versionParser->normalize(trim($matches[1]));
}
}
}
}
<?php











namespace Composer\Package\Loader;

use Composer\Package;
use Composer\Package\BasePackage;
use Composer\Package\LinkConstraint\VersionConstraint;
use Composer\Package\Version\VersionParser;
use Composer\Repository\PlatformRepository;




class ValidatingArrayLoader implements LoaderInterface
{
const CHECK_ALL = 1;
const CHECK_UNBOUND_CONSTRAINTS = 1;

private $loader;
private $versionParser;
private $errors;
private $warnings;
private $config;
private $strictName;
private $flags;

public function __construct(LoaderInterface $loader, $strictName = true, VersionParser $parser = null, $flags = 0)
{
$this->loader = $loader;
$this->versionParser = $parser ?: new VersionParser();
$this->strictName = $strictName;
$this->flags = $flags;
}

public function load(array $config, $class = 'Composer\Package\CompletePackage')
{
$this->errors = array();
$this->warnings = array();
$this->config = $config;

if ($this->strictName) {
$this->validateRegex('name', '[A-Za-z0-9][A-Za-z0-9_.-]*/[A-Za-z0-9][A-Za-z0-9_.-]*', true);
} else {
$this->validateString('name', true);
}

if (!empty($this->config['version'])) {
try {
$this->versionParser->normalize($this->config['version']);
} catch (\Exception $e) {
$this->errors[] = 'version : invalid value ('.$this->config['version'].'): '.$e->getMessage();
unset($this->config['version']);
}
}

$this->validateRegex('type', '[A-Za-z0-9-]+');
$this->validateString('target-dir');
$this->validateArray('extra');
$this->validateFlatArray('bin');
$this->validateArray('scripts'); 
 $this->validateString('description');
$this->validateUrl('homepage');
$this->validateFlatArray('keywords', '[A-Za-z0-9 ._-]+');

if (isset($this->config['license'])) {
if (is_string($this->config['license'])) {
$this->validateRegex('license', '[A-Za-z0-9+. ()-]+');
} else {
$this->validateFlatArray('license', '[A-Za-z0-9+. ()-]+');
}
}

$this->validateString('time');
if (!empty($this->config['time'])) {
try {
$date = new \DateTime($this->config['time'], new \DateTimeZone('UTC'));
} catch (\Exception $e) {
$this->errors[] = 'time : invalid value ('.$this->config['time'].'): '.$e->getMessage();
unset($this->config['time']);
}
}

if ($this->validateArray('authors') && !empty($this->config['authors'])) {
foreach ($this->config['authors'] as $key => $author) {
if (!is_array($author)) {
$this->errors[] = 'authors.'.$key.' : should be an array, '.gettype($author).' given';
unset($this->config['authors'][$key]);
continue;
}
foreach (array('homepage', 'email', 'name', 'role') as $authorData) {
if (isset($author[$authorData]) && !is_string($author[$authorData])) {
$this->errors[] = 'authors.'.$key.'.'.$authorData.' : invalid value, must be a string';
unset($this->config['authors'][$key][$authorData]);
}
}
if (isset($author['homepage']) && !$this->filterUrl($author['homepage'])) {
$this->warnings[] = 'authors.'.$key.'.homepage : invalid value ('.$author['homepage'].'), must be an http/https URL';
unset($this->config['authors'][$key]['homepage']);
}
if (isset($author['email']) && !filter_var($author['email'], FILTER_VALIDATE_EMAIL)) {
$this->warnings[] = 'authors.'.$key.'.email : invalid value ('.$author['email'].'), must be a valid email address';
unset($this->config['authors'][$key]['email']);
}
if (empty($this->config['authors'][$key])) {
unset($this->config['authors'][$key]);
}
}
if (empty($this->config['authors'])) {
unset($this->config['authors']);
}
}

if ($this->validateArray('support') && !empty($this->config['support'])) {
foreach (array('issues', 'forum', 'wiki', 'source', 'email', 'irc', 'docs') as $key) {
if (isset($this->config['support'][$key]) && !is_string($this->config['support'][$key])) {
$this->errors[] = 'support.'.$key.' : invalid value, must be a string';
unset($this->config['support'][$key]);
}
}

if (isset($this->config['support']['email']) && !filter_var($this->config['support']['email'], FILTER_VALIDATE_EMAIL)) {
$this->warnings[] = 'support.email : invalid value ('.$this->config['support']['email'].'), must be a valid email address';
unset($this->config['support']['email']);
}

if (isset($this->config['support']['irc']) && !$this->filterUrl($this->config['support']['irc'], array('irc'))) {
$this->warnings[] = 'support.irc : invalid value ('.$this->config['support']['irc'].'), must be a irc://<server>/<channel> URL';
unset($this->config['support']['irc']);
}

foreach (array('issues', 'forum', 'wiki', 'source', 'docs') as $key) {
if (isset($this->config['support'][$key]) && !$this->filterUrl($this->config['support'][$key])) {
$this->warnings[] = 'support.'.$key.' : invalid value ('.$this->config['support'][$key].'), must be an http/https URL';
unset($this->config['support'][$key]);
}
}
if (empty($this->config['support'])) {
unset($this->config['support']);
}
}

$unboundConstraint = new VersionConstraint('=', $this->versionParser->normalize('dev-master'));

foreach (array_keys(BasePackage::$supportedLinkTypes) as $linkType) {
if ($this->validateArray($linkType) && isset($this->config[$linkType])) {
foreach ($this->config[$linkType] as $package => $constraint) {
if (!preg_match('{^[A-Za-z0-9_./-]+$}', $package)) {
$this->warnings[] = $linkType.'.'.$package.' : invalid key, package names must be strings containing only [A-Za-z0-9_./-]';
}
if (!is_string($constraint)) {
$this->errors[] = $linkType.'.'.$package.' : invalid value, must be a string containing a version constraint';
unset($this->config[$linkType][$package]);
} elseif ('self.version' !== $constraint) {
try {
$linkConstraint = $this->versionParser->parseConstraints($constraint);
} catch (\Exception $e) {
$this->errors[] = $linkType.'.'.$package.' : invalid version constraint ('.$e->getMessage().')';
unset($this->config[$linkType][$package]);
continue;
}


 if (
($this->flags & self::CHECK_UNBOUND_CONSTRAINTS)
&& 'require' === $linkType
&& $linkConstraint->matches($unboundConstraint)
&& !preg_match(PlatformRepository::PLATFORM_PACKAGE_REGEX, $package)
) {
$this->warnings[] = $linkType.'.'.$package.' : unbound version constraints ('.$constraint.') should be avoided';
}
}
}
}
}

if ($this->validateArray('suggest') && !empty($this->config['suggest'])) {
foreach ($this->config['suggest'] as $package => $description) {
if (!is_string($description)) {
$this->errors[] = 'suggest.'.$package.' : invalid value, must be a string describing why the package is suggested';
unset($this->config['suggest'][$package]);
}
}
}

if ($this->validateString('minimum-stability') && !empty($this->config['minimum-stability'])) {
if (!isset(BasePackage::$stabilities[$this->config['minimum-stability']])) {
$this->errors[] = 'minimum-stability : invalid value ('.$this->config['minimum-stability'].'), must be one of '.implode(', ', array_keys(BasePackage::$stabilities));
unset($this->config['minimum-stability']);
}
}

if ($this->validateArray('autoload') && !empty($this->config['autoload'])) {
$types = array('psr-0', 'psr-4', 'classmap', 'files');
foreach ($this->config['autoload'] as $type => $typeConfig) {
if (!in_array($type, $types)) {
$this->errors[] = 'autoload : invalid value ('.$type.'), must be one of '.implode(', ', $types);
unset($this->config['autoload'][$type]);
}
if ($type === 'psr-4') {
foreach ($typeConfig as $namespace => $dirs) {
if ($namespace !== '' && '\\' !== substr($namespace, -1)) {
$this->errors[] = 'autoload.psr-4 : invalid value ('.$namespace.'), namespaces must end with a namespace separator, should be '.$namespace.'\\';
}
}
}
}
}

if (!empty($this->config['autoload']['psr-4']) && !empty($this->config['target-dir'])) {
$this->errors[] = 'target-dir : this can not be used together with the autoload.psr-4 setting, remove target-dir to upgrade to psr-4';

 
 unset($this->config['autoload']['psr-4']);
}


 


 

$this->validateFlatArray('include-path');
$this->validateArray('transport-options');


 if (isset($this->config['extra']['branch-alias'])) {
if (!is_array($this->config['extra']['branch-alias'])) {
$this->errors[] = 'extra.branch-alias : must be an array of versions => aliases';
} else {
foreach ($this->config['extra']['branch-alias'] as $sourceBranch => $targetBranch) {

 if ('-dev' !== substr($targetBranch, -4)) {
$this->warnings[] = 'extra.branch-alias.'.$sourceBranch.' : the target branch ('.$targetBranch.') must end in -dev';
unset($this->config['extra']['branch-alias'][$sourceBranch]);

continue;
}


 $validatedTargetBranch = $this->versionParser->normalizeBranch(substr($targetBranch, 0, -4));
if ('-dev' !== substr($validatedTargetBranch, -4)) {
$this->warnings[] = 'extra.branch-alias.'.$sourceBranch.' : the target branch ('.$targetBranch.') must be a parseable number like 2.0-dev';
unset($this->config['extra']['branch-alias'][$sourceBranch]);

continue;
}


 if (($sourcePrefix = $this->versionParser->parseNumericAliasPrefix($sourceBranch))
&& ($targetPrefix = $this->versionParser->parseNumericAliasPrefix($targetBranch))
&& (stripos($targetPrefix, $sourcePrefix) !== 0)
) {
$this->warnings[] = 'extra.branch-alias.'.$sourceBranch.' : the target branch ('.$targetBranch.') is not a valid numeric alias for this version';
unset($this->config['extra']['branch-alias'][$sourceBranch]);
}
}
}
}

if ($this->errors) {
throw new InvalidPackageException($this->errors, $this->warnings, $config);
}

$package = $this->loader->load($this->config, $class);
$this->config = null;

return $package;
}

public function getWarnings()
{
return $this->warnings;
}

public function getErrors()
{
return $this->errors;
}

private function validateRegex($property, $regex, $mandatory = false)
{
if (!$this->validateString($property, $mandatory)) {
return false;
}

if (!preg_match('{^'.$regex.'$}u', $this->config[$property])) {
$message = $property.' : invalid value ('.$this->config[$property].'), must match '.$regex;
if ($mandatory) {
$this->errors[] = $message;
} else {
$this->warnings[] = $message;
}
unset($this->config[$property]);

return false;
}

return true;
}

private function validateString($property, $mandatory = false)
{
if (isset($this->config[$property]) && !is_string($this->config[$property])) {
$this->errors[] = $property.' : should be a string, '.gettype($this->config[$property]).' given';
unset($this->config[$property]);

return false;
}

if (!isset($this->config[$property]) || trim($this->config[$property]) === '') {
if ($mandatory) {
$this->errors[] = $property.' : must be present';
}
unset($this->config[$property]);

return false;
}

return true;
}

private function validateArray($property, $mandatory = false)
{
if (isset($this->config[$property]) && !is_array($this->config[$property])) {
$this->errors[] = $property.' : should be an array, '.gettype($this->config[$property]).' given';
unset($this->config[$property]);

return false;
}

if (!isset($this->config[$property]) || !count($this->config[$property])) {
if ($mandatory) {
$this->errors[] = $property.' : must be present and contain at least one element';
}
unset($this->config[$property]);

return false;
}

return true;
}

private function validateFlatArray($property, $regex = null, $mandatory = false)
{
if (!$this->validateArray($property, $mandatory)) {
return false;
}

$pass = true;
foreach ($this->config[$property] as $key => $value) {
if (!is_string($value) && !is_numeric($value)) {
$this->errors[] = $property.'.'.$key.' : must be a string or int, '.gettype($value).' given';
unset($this->config[$property][$key]);
$pass = false;

continue;
}

if ($regex && !preg_match('{^'.$regex.'$}u', $value)) {
$this->warnings[] = $property.'.'.$key.' : invalid value ('.$value.'), must match '.$regex;
unset($this->config[$property][$key]);
$pass = false;
}
}

return $pass;
}

private function validateUrl($property, $mandatory = false)
{
if (!$this->validateString($property, $mandatory)) {
return false;
}

if (!$this->filterUrl($this->config[$property])) {
$this->warnings[] = $property.' : invalid value ('.$this->config[$property].'), must be an http/https URL';
unset($this->config[$property]);

return false;
}

return true;
}

private function filterUrl($value, array $schemes = array('http', 'https'))
{
if ($value === '') {
return true;
}

$bits = parse_url($value);
if (empty($bits['scheme']) || empty($bits['host'])) {
return false;
}

if (!in_array($bits['scheme'], $schemes, true)) {
return false;
}

return true;
}
}
<?php











namespace Composer\Package;

use Composer\Json\JsonFile;
use Composer\Installer\InstallationManager;
use Composer\Repository\RepositoryManager;
use Composer\Util\ProcessExecutor;
use Composer\Repository\ArrayRepository;
use Composer\Package\Dumper\ArrayDumper;
use Composer\Package\Loader\ArrayLoader;
use Composer\Package\Version\VersionParser;
use Composer\Util\Git as GitUtil;
use Composer\IO\IOInterface;







class Locker
{
private $lockFile;
private $repositoryManager;
private $installationManager;
private $hash;
private $loader;
private $dumper;
private $process;
private $lockDataCache;










public function __construct(IOInterface $io, JsonFile $lockFile, RepositoryManager $repositoryManager, InstallationManager $installationManager, $hash)
{
$this->lockFile = $lockFile;
$this->repositoryManager = $repositoryManager;
$this->installationManager = $installationManager;
$this->hash = $hash;
$this->loader = new ArrayLoader(null, true);
$this->dumper = new ArrayDumper();
$this->process = new ProcessExecutor($io);
}






public function isLocked()
{
if (!$this->lockFile->exists()) {
return false;
}

$data = $this->getLockData();

return isset($data['packages']);
}






public function isFresh()
{
$lock = $this->lockFile->read();

return $this->hash === $lock['hash'];
}








public function getLockedRepository($withDevReqs = false)
{
$lockData = $this->getLockData();
$packages = new ArrayRepository();

$lockedPackages = $lockData['packages'];
if ($withDevReqs) {
if (isset($lockData['packages-dev'])) {
$lockedPackages = array_merge($lockedPackages, $lockData['packages-dev']);
} else {
throw new \RuntimeException('The lock file does not contain require-dev information, run install with the --no-dev option or run update to install those packages.');
}
}

if (empty($lockedPackages)) {
return $packages;
}

if (isset($lockedPackages[0]['name'])) {
foreach ($lockedPackages as $info) {
$packages->addPackage($this->loader->load($info));
}

return $packages;
}

throw new \RuntimeException('Your composer.lock was created before 2012-09-15, and is not supported anymore. Run "composer update" to generate a new one.');
}







public function getPlatformRequirements($withDevReqs = false)
{
$lockData = $this->getLockData();
$versionParser = new VersionParser();
$requirements = array();

if (!empty($lockData['platform'])) {
$requirements = $versionParser->parseLinks(
'__ROOT__',
'1.0.0',
'requires',
isset($lockData['platform']) ? $lockData['platform'] : array()
);
}

if ($withDevReqs && !empty($lockData['platform-dev'])) {
$devRequirements = $versionParser->parseLinks(
'__ROOT__',
'1.0.0',
'requires',
isset($lockData['platform-dev']) ? $lockData['platform-dev'] : array()
);

$requirements = array_merge($requirements, $devRequirements);
}

return $requirements;
}

public function getMinimumStability()
{
$lockData = $this->getLockData();

return isset($lockData['minimum-stability']) ? $lockData['minimum-stability'] : 'stable';
}

public function getStabilityFlags()
{
$lockData = $this->getLockData();

return isset($lockData['stability-flags']) ? $lockData['stability-flags'] : array();
}

public function getPreferStable()
{
$lockData = $this->getLockData();


 
 return isset($lockData['prefer-stable']) ? $lockData['prefer-stable'] : null;
}

public function getPreferLowest()
{
$lockData = $this->getLockData();


 
 return isset($lockData['prefer-lowest']) ? $lockData['prefer-lowest'] : null;
}

public function getPlatformOverrides()
{
$lockData = $this->getLockData();

return isset($lockData['platform-overrides']) ? $lockData['platform-overrides'] : array();
}

public function getAliases()
{
$lockData = $this->getLockData();

return isset($lockData['aliases']) ? $lockData['aliases'] : array();
}

public function getLockData()
{
if (null !== $this->lockDataCache) {
return $this->lockDataCache;
}

if (!$this->lockFile->exists()) {
throw new \LogicException('No lockfile found. Unable to read locked packages');
}

return $this->lockDataCache = $this->lockFile->read();
}

















public function setLockData(array $packages, $devPackages, array $platformReqs, $platformDevReqs, array $aliases, $minimumStability, array $stabilityFlags, $preferStable, $preferLowest, array $platformOverrides)
{
$lock = array(
'_readme' => array('This file locks the dependencies of your project to a known state',
'Read more about it at https://getcomposer.org/doc/01-basic-usage.md#composer-lock-the-lock-file',
'This file is @gener'.'ated automatically'),
'hash' => $this->hash,
'packages' => null,
'packages-dev' => null,
'aliases' => array(),
'minimum-stability' => $minimumStability,
'stability-flags' => $stabilityFlags,
'prefer-stable' => $preferStable,
'prefer-lowest' => $preferLowest,
);

foreach ($aliases as $package => $versions) {
foreach ($versions as $version => $alias) {
$lock['aliases'][] = array(
'alias' => $alias['alias'],
'alias_normalized' => $alias['alias_normalized'],
'version' => $version,
'package' => $package,
);
}
}

$lock['packages'] = $this->lockPackages($packages);
if (null !== $devPackages) {
$lock['packages-dev'] = $this->lockPackages($devPackages);
}

$lock['platform'] = $platformReqs;
$lock['platform-dev'] = $platformDevReqs;
if ($platformOverrides) {
$lock['platform-overrides'] = $platformOverrides;
}

if (empty($lock['packages']) && empty($lock['packages-dev']) && empty($lock['platform']) && empty($lock['platform-dev'])) {
if ($this->lockFile->exists()) {
unlink($this->lockFile->getPath());
}

return false;
}

if (!$this->isLocked() || $lock !== $this->getLockData()) {
$this->lockFile->write($lock);
$this->lockDataCache = null;

return true;
}

return false;
}

private function lockPackages(array $packages)
{
$locked = array();

foreach ($packages as $package) {
if ($package instanceof AliasPackage) {
continue;
}

$name = $package->getPrettyName();
$version = $package->getPrettyVersion();

if (!$name || !$version) {
throw new \LogicException(sprintf(
'Package "%s" has no version or name and can not be locked', $package
));
}

$spec = $this->dumper->dump($package);
unset($spec['version_normalized']);


 $time = isset($spec['time']) ? $spec['time'] : null;
unset($spec['time']);
if ($package->isDev() && $package->getInstallationSource() === 'source') {

 $time = $this->getPackageTime($package) ?: $time;
}
if (null !== $time) {
$spec['time'] = $time;
}

unset($spec['installation-source']);

$locked[] = $spec;
}

usort($locked, function ($a, $b) {
$comparison = strcmp($a['name'], $b['name']);

if (0 !== $comparison) {
return $comparison;
}


 return strcmp($a['version'], $b['version']);
});

return $locked;
}







private function getPackageTime(PackageInterface $package)
{
if (!function_exists('proc_open')) {
return null;
}

$path = realpath($this->installationManager->getInstallPath($package));
$sourceType = $package->getSourceType();
$datetime = null;

if ($path && in_array($sourceType, array('git', 'hg'))) {
$sourceRef = $package->getSourceReference() ?: $package->getDistReference();
switch ($sourceType) {
case 'git':
GitUtil::cleanEnv();

if (0 === $this->process->execute('git log -n1 --pretty=%ct '.ProcessExecutor::escape($sourceRef), $output, $path) && preg_match('{^\s*\d+\s*$}', $output)) {
$datetime = new \DateTime('@'.trim($output), new \DateTimeZone('UTC'));
}
break;

case 'hg':
if (0 === $this->process->execute('hg log --template "{date|hgdate}" -r '.ProcessExecutor::escape($sourceRef), $output, $path) && preg_match('{^\s*(\d+)\s*}', $output, $match)) {
$datetime = new \DateTime('@'.$match[1], new \DateTimeZone('UTC'));
}
break;
}
}

return $datetime ? $datetime->format('Y-m-d H:i:s') : null;
}
}
<?php











namespace Composer\Package;

use Composer\Package\Version\VersionParser;
use Composer\Util\ComposerMirror;






class Package extends BasePackage
{
protected $type;
protected $targetDir;
protected $installationSource;
protected $sourceType;
protected $sourceUrl;
protected $sourceReference;
protected $sourceMirrors;
protected $distType;
protected $distUrl;
protected $distReference;
protected $distSha1Checksum;
protected $distMirrors;
protected $version;
protected $prettyVersion;
protected $releaseDate;
protected $extra = array();
protected $binaries = array();
protected $dev;
protected $stability;
protected $notificationUrl;

protected $requires = array();
protected $conflicts = array();
protected $provides = array();
protected $replaces = array();
protected $devRequires = array();
protected $suggests = array();
protected $autoload = array();
protected $devAutoload = array();
protected $includePaths = array();
protected $archiveExcludes = array();








public function __construct($name, $version, $prettyVersion)
{
parent::__construct($name);

$this->version = $version;
$this->prettyVersion = $prettyVersion;

$this->stability = VersionParser::parseStability($version);
$this->dev = $this->stability === 'dev';
}




public function isDev()
{
return $this->dev;
}




public function setType($type)
{
$this->type = $type;
}




public function getType()
{
return $this->type ?: 'library';
}




public function getStability()
{
return $this->stability;
}




public function setTargetDir($targetDir)
{
$this->targetDir = $targetDir;
}




public function getTargetDir()
{
if (null === $this->targetDir) {
return;
}

return ltrim(preg_replace('{ (?:^|[\\\\/]+) \.\.? (?:[\\\\/]+|$) (?:\.\.? (?:[\\\\/]+|$) )*}x', '/', $this->targetDir), '/');
}




public function setExtra(array $extra)
{
$this->extra = $extra;
}




public function getExtra()
{
return $this->extra;
}




public function setBinaries(array $binaries)
{
$this->binaries = $binaries;
}




public function getBinaries()
{
return $this->binaries;
}




public function setInstallationSource($type)
{
$this->installationSource = $type;
}




public function getInstallationSource()
{
return $this->installationSource;
}




public function setSourceType($type)
{
$this->sourceType = $type;
}




public function getSourceType()
{
return $this->sourceType;
}




public function setSourceUrl($url)
{
$this->sourceUrl = $url;
}




public function getSourceUrl()
{
return $this->sourceUrl;
}




public function setSourceReference($reference)
{
$this->sourceReference = $reference;
}




public function getSourceReference()
{
return $this->sourceReference;
}




public function setSourceMirrors($mirrors)
{
$this->sourceMirrors = $mirrors;
}




public function getSourceMirrors()
{
return $this->sourceMirrors;
}




public function getSourceUrls()
{
return $this->getUrls($this->sourceUrl, $this->sourceMirrors, $this->sourceReference, $this->sourceType, 'source');
}




public function setDistType($type)
{
$this->distType = $type;
}




public function getDistType()
{
return $this->distType;
}




public function setDistUrl($url)
{
$this->distUrl = $url;
}




public function getDistUrl()
{
return $this->distUrl;
}




public function setDistReference($reference)
{
$this->distReference = $reference;
}




public function getDistReference()
{
return $this->distReference;
}




public function setDistSha1Checksum($sha1checksum)
{
$this->distSha1Checksum = $sha1checksum;
}




public function getDistSha1Checksum()
{
return $this->distSha1Checksum;
}




public function setDistMirrors($mirrors)
{
$this->distMirrors = $mirrors;
}




public function getDistMirrors()
{
return $this->distMirrors;
}




public function getDistUrls()
{
return $this->getUrls($this->distUrl, $this->distMirrors, $this->distReference, $this->distType, 'dist');
}




public function getVersion()
{
return $this->version;
}




public function getPrettyVersion()
{
return $this->prettyVersion;
}






public function setReleaseDate(\DateTime $releaseDate)
{
$this->releaseDate = $releaseDate;
}




public function getReleaseDate()
{
return $this->releaseDate;
}






public function setRequires(array $requires)
{
$this->requires = $requires;
}




public function getRequires()
{
return $this->requires;
}






public function setConflicts(array $conflicts)
{
$this->conflicts = $conflicts;
}




public function getConflicts()
{
return $this->conflicts;
}






public function setProvides(array $provides)
{
$this->provides = $provides;
}




public function getProvides()
{
return $this->provides;
}






public function setReplaces(array $replaces)
{
$this->replaces = $replaces;
}




public function getReplaces()
{
return $this->replaces;
}






public function setDevRequires(array $devRequires)
{
$this->devRequires = $devRequires;
}




public function getDevRequires()
{
return $this->devRequires;
}






public function setSuggests(array $suggests)
{
$this->suggests = $suggests;
}




public function getSuggests()
{
return $this->suggests;
}






public function setAutoload(array $autoload)
{
$this->autoload = $autoload;
}




public function getAutoload()
{
return $this->autoload;
}






public function setDevAutoload(array $devAutoload)
{
$this->devAutoload = $devAutoload;
}




public function getDevAutoload()
{
return $this->devAutoload;
}






public function setIncludePaths(array $includePaths)
{
$this->includePaths = $includePaths;
}




public function getIncludePaths()
{
return $this->includePaths;
}






public function setNotificationUrl($notificationUrl)
{
$this->notificationUrl = $notificationUrl;
}




public function getNotificationUrl()
{
return $this->notificationUrl;
}






public function setArchiveExcludes(array $excludes)
{
$this->archiveExcludes = $excludes;
}




public function getArchiveExcludes()
{
return $this->archiveExcludes;
}








public function replaceVersion($version, $prettyVersion)
{
$this->version = $version;
$this->prettyVersion = $prettyVersion;

$this->stability = VersionParser::parseStability($version);
$this->dev = $this->stability === 'dev';
}

protected function getUrls($url, $mirrors, $ref, $type, $urlType)
{
if (!$url) {
return array();
}
$urls = array($url);
if ($mirrors) {
foreach ($mirrors as $mirror) {
if ($urlType === 'dist') {
$mirrorUrl = ComposerMirror::processUrl($mirror['url'], $this->name, $this->version, $ref, $type);
} elseif ($urlType === 'source' && $type === 'git') {
$mirrorUrl = ComposerMirror::processGitUrl($mirror['url'], $this->name, $url, $type);
} elseif ($urlType === 'source' && $type === 'hg') {
$mirrorUrl = ComposerMirror::processHgUrl($mirror['url'], $this->name, $url, $type);
}
if (!in_array($mirrorUrl, $urls)) {
$func = $mirror['preferred'] ? 'array_unshift' : 'array_push';
$func($urls, $mirrorUrl);
}
}
}

return $urls;
}
}
<?php











namespace Composer\Package;

use Composer\Repository\RepositoryInterface;






interface PackageInterface
{





public function getName();






public function getPrettyName();









public function getNames();






public function setId($id);






public function getId();






public function isDev();






public function getType();






public function getTargetDir();






public function getExtra();






public function setInstallationSource($type);






public function getInstallationSource();






public function getSourceType();






public function getSourceUrl();






public function getSourceUrls();






public function getSourceReference();






public function getSourceMirrors();






public function getDistType();






public function getDistUrl();






public function getDistUrls();






public function getDistReference();






public function getDistSha1Checksum();






public function getDistMirrors();






public function getVersion();






public function getPrettyVersion();






public function getReleaseDate();






public function getStability();







public function getRequires();







public function getConflicts();







public function getProvides();







public function getReplaces();







public function getDevRequires();







public function getSuggests();











public function getAutoload();











public function getDevAutoload();







public function getIncludePaths();






public function setRepository(RepositoryInterface $repository);






public function getRepository();






public function getBinaries();






public function getUniqueName();






public function getNotificationUrl();






public function __toString();






public function getPrettyString();






public function getArchiveExcludes();






public function getTransportOptions();
}
<?php











namespace Composer\Package;




class RootAliasPackage extends AliasPackage implements RootPackageInterface
{
public function __construct(RootPackageInterface $aliasOf, $version, $prettyVersion)
{
parent::__construct($aliasOf, $version, $prettyVersion);
}




public function getAliases()
{
return $this->aliasOf->getAliases();
}




public function getMinimumStability()
{
return $this->aliasOf->getMinimumStability();
}




public function getStabilityFlags()
{
return $this->aliasOf->getStabilityFlags();
}




public function getReferences()
{
return $this->aliasOf->getReferences();
}




public function getPreferStable()
{
return $this->aliasOf->getPreferStable();
}




public function setRequires(array $require)
{
$this->requires = $this->replaceSelfVersionDependencies($require, 'requires');

$this->aliasOf->setRequires($require);
}




public function setDevRequires(array $devRequire)
{
$this->devRequires = $this->replaceSelfVersionDependencies($devRequire, 'devRequires');

$this->aliasOf->setDevRequires($devRequire);
}

public function __clone()
{
parent::__clone();
$this->aliasOf = clone $this->aliasOf;
}
}
<?php











namespace Composer\Package;






class RootPackage extends CompletePackage implements RootPackageInterface
{
protected $minimumStability = 'stable';
protected $preferStable = false;
protected $stabilityFlags = array();
protected $references = array();
protected $aliases = array();






public function setMinimumStability($minimumStability)
{
$this->minimumStability = $minimumStability;
}




public function getMinimumStability()
{
return $this->minimumStability;
}






public function setStabilityFlags(array $stabilityFlags)
{
$this->stabilityFlags = $stabilityFlags;
}




public function getStabilityFlags()
{
return $this->stabilityFlags;
}






public function setPreferStable($preferStable)
{
$this->preferStable = $preferStable;
}




public function getPreferStable()
{
return $this->preferStable;
}






public function setReferences(array $references)
{
$this->references = $references;
}




public function getReferences()
{
return $this->references;
}






public function setAliases(array $aliases)
{
$this->aliases = $aliases;
}




public function getAliases()
{
return $this->aliases;
}
}
<?php











namespace Composer\Package;






interface RootPackageInterface extends CompletePackageInterface
{





public function getAliases();






public function getMinimumStability();








public function getStabilityFlags();








public function getReferences();






public function getPreferStable();






public function setRequires(array $requires);






public function setDevRequires(array $devRequires);
}
<?php











namespace Composer\Package\Version;

use Composer\Package\BasePackage;
use Composer\Package\PackageInterface;
use Composer\Package\Link;
use Composer\Package\LinkConstraint\EmptyConstraint;
use Composer\Package\LinkConstraint\MultiConstraint;
use Composer\Package\LinkConstraint\VersionConstraint;






class VersionParser
{
private static $modifierRegex = '[._-]?(?:(stable|beta|b|RC|alpha|a|patch|pl|p)(?:[.-]?(\d+))?)?([.-]?dev)?';







public static function parseStability($version)
{
$version = preg_replace('{#.+$}i', '', $version);

if ('dev-' === substr($version, 0, 4) || '-dev' === substr($version, -4)) {
return 'dev';
}

preg_match('{'.self::$modifierRegex.'$}i', strtolower($version), $match);
if (!empty($match[3])) {
return 'dev';
}

if (!empty($match[1])) {
if ('beta' === $match[1] || 'b' === $match[1]) {
return 'beta';
}
if ('alpha' === $match[1] || 'a' === $match[1]) {
return 'alpha';
}
if ('rc' === $match[1]) {
return 'RC';
}
}

return 'stable';
}

public static function normalizeStability($stability)
{
$stability = strtolower($stability);

return $stability === 'rc' ? 'RC' : $stability;
}

public static function formatVersion(PackageInterface $package, $truncate = true)
{
if (!$package->isDev() || !in_array($package->getSourceType(), array('hg', 'git'))) {
return $package->getPrettyVersion();
}


 if ($truncate && strlen($package->getSourceReference()) === 40) {
return $package->getPrettyVersion() . ' ' . substr($package->getSourceReference(), 0, 7);
}

return $package->getPrettyVersion() . ' ' . $package->getSourceReference();
}









public function normalize($version, $fullVersion = null)
{
$version = trim($version);
if (null === $fullVersion) {
$fullVersion = $version;
}


 if (preg_match('{^([^,\s]+) +as +([^,\s]+)$}', $version, $match)) {
$version = $match[1];
}


 if (preg_match('{^([^,\s+]+)\+[^\s]+$}', $version, $match)) {
$version = $match[1];
}


 if (preg_match('{^(?:dev-)?(?:master|trunk|default)$}i', $version)) {
return '9999999-dev';
}

if ('dev-' === strtolower(substr($version, 0, 4))) {
return 'dev-'.substr($version, 4);
}


 if (preg_match('{^v?(\d{1,3})(\.\d+)?(\.\d+)?(\.\d+)?'.self::$modifierRegex.'$}i', $version, $matches)) {
$version = $matches[1]
.(!empty($matches[2]) ? $matches[2] : '.0')
.(!empty($matches[3]) ? $matches[3] : '.0')
.(!empty($matches[4]) ? $matches[4] : '.0');
$index = 5;
} elseif (preg_match('{^v?(\d{4}(?:[.:-]?\d{2}){1,6}(?:[.:-]?\d{1,3})?)'.self::$modifierRegex.'$}i', $version, $matches)) { 
 $version = preg_replace('{\D}', '-', $matches[1]);
$index = 2;
} elseif (preg_match('{^v?(\d{4,})(\.\d+)?(\.\d+)?(\.\d+)?'.self::$modifierRegex.'$}i', $version, $matches)) {
$version = $matches[1]
.(!empty($matches[2]) ? $matches[2] : '.0')
.(!empty($matches[3]) ? $matches[3] : '.0')
.(!empty($matches[4]) ? $matches[4] : '.0');
$index = 5;
}


 if (isset($index)) {
if (!empty($matches[$index])) {
if ('stable' === $matches[$index]) {
return $version;
}
$version .= '-' . $this->expandStability($matches[$index]) . (!empty($matches[$index+1]) ? $matches[$index+1] : '');
}

if (!empty($matches[$index+2])) {
$version .= '-dev';
}

return $version;
}


 if (preg_match('{(.*?)[.-]?dev$}i', $version, $match)) {
try {
return $this->normalizeBranch($match[1]);
} catch (\Exception $e) {
}
}

$extraMessage = '';
if (preg_match('{ +as +'.preg_quote($version).'$}', $fullVersion)) {
$extraMessage = ' in "'.$fullVersion.'", the alias must be an exact version';
} elseif (preg_match('{^'.preg_quote($version).' +as +}', $fullVersion)) {
$extraMessage = ' in "'.$fullVersion.'", the alias source must be an exact version, if it is a branch name you should prefix it with dev-';
}

throw new \UnexpectedValueException('Invalid version string "'.$version.'"'.$extraMessage);
}








public function parseNumericAliasPrefix($branch)
{
if (preg_match('/^(?P<version>(\d+\\.)*\d+)(?:\.x)?-dev$/i', $branch, $matches)) {
return $matches['version'].".";
}

return false;
}







public function normalizeBranch($name)
{
$name = trim($name);

if (in_array($name, array('master', 'trunk', 'default'))) {
return $this->normalize($name);
}

if (preg_match('#^v?(\d+)(\.(?:\d+|[xX*]))?(\.(?:\d+|[xX*]))?(\.(?:\d+|[xX*]))?$#i', $name, $matches)) {
$version = '';
for ($i = 1; $i < 5; $i++) {
$version .= isset($matches[$i]) ? str_replace(array('*', 'X'), 'x', $matches[$i]) : '.x';
}

return str_replace('x', '9999999', $version).'-dev';
}

return 'dev-'.$name;
}








public function parseLinks($source, $sourceVersion, $description, $links)
{
$res = array();
foreach ($links as $target => $constraint) {
if ('self.version' === $constraint) {
$parsedConstraint = $this->parseConstraints($sourceVersion);
} else {
$parsedConstraint = $this->parseConstraints($constraint);
}
$res[strtolower($target)] = new Link($source, $target, $parsedConstraint, $description, $constraint);
}

return $res;
}







public function parseConstraints($constraints)
{
$prettyConstraint = $constraints;

if (preg_match('{^([^,\s]*?)@('.implode('|', array_keys(BasePackage::$stabilities)).')$}i', $constraints, $match)) {
$constraints = empty($match[1]) ? '*' : $match[1];
}

if (preg_match('{^(dev-[^,\s@]+?|[^,\s@]+?\.x-dev)#.+$}i', $constraints, $match)) {
$constraints = $match[1];
}

$orConstraints = preg_split('{\s*\|\|?\s*}', trim($constraints));
$orGroups = array();
foreach ($orConstraints as $constraints) {
$andConstraints = preg_split('{(?<!^|as|[=>< ,]) *(?<!-)[, ](?!-) *(?!,|as|$)}', $constraints);
if (count($andConstraints) > 1) {
$constraintObjects = array();
foreach ($andConstraints as $constraint) {
$constraintObjects = array_merge($constraintObjects, $this->parseConstraint($constraint));
}
} else {
$constraintObjects = $this->parseConstraint($andConstraints[0]);
}

if (1 === count($constraintObjects)) {
$constraint = $constraintObjects[0];
} else {
$constraint = new MultiConstraint($constraintObjects);
}

$orGroups[] = $constraint;
}

if (1 === count($orGroups)) {
$constraint = $orGroups[0];
} else {
$constraint = new MultiConstraint($orGroups, false);
}

$constraint->setPrettyString($prettyConstraint);

return $constraint;
}

private function parseConstraint($constraint)
{
if (preg_match('{^([^,\s]+?)@('.implode('|', array_keys(BasePackage::$stabilities)).')$}i', $constraint, $match)) {
$constraint = $match[1];
if ($match[2] !== 'stable') {
$stabilityModifier = $match[2];
}
}

if (preg_match('{^[xX*](\.[xX*])*$}i', $constraint)) {
return array(new EmptyConstraint);
}

$versionRegex = '(\d+)(?:\.(\d+))?(?:\.(\d+))?(?:\.(\d+))?'.self::$modifierRegex;


 
 
 
 
 if (preg_match('{^~>?'.$versionRegex.'$}i', $constraint, $matches)) {
if (substr($constraint, 0, 2) === '~>') {
throw new \UnexpectedValueException(
'Could not parse version constraint '.$constraint.': '.
'Invalid operator "~>", you probably meant to use the "~" operator'
);
}


 if (isset($matches[4]) && '' !== $matches[4]) {
$position = 4;
} elseif (isset($matches[3]) && '' !== $matches[3]) {
$position = 3;
} elseif (isset($matches[2]) && '' !== $matches[2]) {
$position = 2;
} else {
$position = 1;
}


 $stabilitySuffix = '';
if (!empty($matches[5])) {
$stabilitySuffix .= '-' . $this->expandStability($matches[5]) . (!empty($matches[6]) ? $matches[6] : '');
}

if (!empty($matches[7])) {
$stabilitySuffix .= '-dev';
}

if (!$stabilitySuffix) {
$stabilitySuffix = "-dev";
}
$lowVersion = $this->manipulateVersionString($matches, $position, 0) . $stabilitySuffix;
$lowerBound = new VersionConstraint('>=', $lowVersion);


 
 $highPosition = max(1, $position - 1);
$highVersion = $this->manipulateVersionString($matches, $highPosition, 1) . '-dev';
$upperBound = new VersionConstraint('<', $highVersion);

return array(
$lowerBound,
$upperBound
);
}


 if (preg_match('{^\^'.$versionRegex.'($)}i', $constraint, $matches)) {

 if ('0' !== $matches[1] || '' === $matches[2]) {
$position = 1;
} elseif ('0' !== $matches[2] || '' === $matches[3]) {
$position = 2;
} else {
$position = 3;
}


 $stabilitySuffix = '';
if (empty($matches[5]) && empty($matches[7])) {
$stabilitySuffix .= '-dev';
}

$lowVersion = $this->normalize(substr($constraint . $stabilitySuffix, 1));
$lowerBound = new VersionConstraint('>=', $lowVersion);


 
 $highVersion = $this->manipulateVersionString($matches, $position, 1) . '-dev';
$upperBound = new VersionConstraint('<', $highVersion);

return array(
$lowerBound,
$upperBound
);
}


 if (preg_match('{^(\d+)(?:\.(\d+))?(?:\.(\d+))?\.[xX*]$}', $constraint, $matches)) {
if (isset($matches[3]) && '' !== $matches[3]) {
$position = 3;
} elseif (isset($matches[2]) && '' !== $matches[2]) {
$position = 2;
} else {
$position = 1;
}

$lowVersion = $this->manipulateVersionString($matches, $position) . "-dev";
$highVersion = $this->manipulateVersionString($matches, $position, 1) . "-dev";

if ($lowVersion === "0.0.0.0-dev") {
return array(new VersionConstraint('<', $highVersion));
}

return array(
new VersionConstraint('>=', $lowVersion),
new VersionConstraint('<', $highVersion),
);
}


 if (preg_match('{^(?P<from>'.$versionRegex.') +- +(?P<to>'.$versionRegex.')($)}i', $constraint, $matches)) {

 $lowStabilitySuffix = '';
if (empty($matches[6]) && empty($matches[8])) {
$lowStabilitySuffix = '-dev';
}

$lowVersion = $this->normalize($matches['from']);
$lowerBound = new VersionConstraint('>=', $lowVersion . $lowStabilitySuffix);

if ((!empty($matches[11]) && !empty($matches[12])) || !empty($matches[14]) || !empty($matches[16])) {
$highVersion = $this->normalize($matches['to']);
$upperBound = new VersionConstraint('<=', $highVersion);
} else {
$highMatch = array('', $matches[10], $matches[11], $matches[12], $matches[13]);
$highVersion = $this->manipulateVersionString($highMatch, empty($matches[11]) ? 1 : 2, 1) . '-dev';
$upperBound = new VersionConstraint('<', $highVersion);
}

return array(
$lowerBound,
$upperBound
);
}


 if (preg_match('{^(<>|!=|>=?|<=?|==?)?\s*(.*)}', $constraint, $matches)) {
try {
$version = $this->normalize($matches[2]);

if (!empty($stabilityModifier) && $this->parseStability($version) === 'stable') {
$version .= '-' . $stabilityModifier;
} elseif ('<' === $matches[1]) {
if (!preg_match('/-' . self::$modifierRegex . '$/', strtolower($matches[2]))) {
$version .= '-dev';
}
}

return array(new VersionConstraint($matches[1] ?: '=', $version));
} catch (\Exception $e) {
}
}

$message = 'Could not parse version constraint '.$constraint;
if (isset($e)) {
$message .= ': '. $e->getMessage();
}

throw new \UnexpectedValueException($message);
}












private function manipulateVersionString($matches, $position, $increment = 0, $pad = '0')
{
for ($i = 4; $i > 0; $i--) {
if ($i > $position) {
$matches[$i] = $pad;
} elseif ($i == $position && $increment) {
$matches[$i] += $increment;

 if ($matches[$i] < 0) {
$matches[$i] = $pad;
$position--;


 if ($i == 1) {
return;
}
}
}
}

return $matches[1] . '.' . $matches[2] . '.' . $matches[3] . '.' . $matches[4];
}

private function expandStability($stability)
{
$stability = strtolower($stability);

switch ($stability) {
case 'a':
return 'alpha';
case 'b':
return 'beta';
case 'p':
case 'pl':
return 'patch';
case 'rc':
return 'RC';
default:
return $stability;
}
}







public function parseNameVersionPairs(array $pairs)
{
$pairs = array_values($pairs);
$result = array();

for ($i = 0, $count = count($pairs); $i < $count; $i++) {
$pair = preg_replace('{^([^=: ]+)[=: ](.*)$}', '$1 $2', trim($pairs[$i]));
if (false === strpos($pair, ' ') && isset($pairs[$i+1]) && false === strpos($pairs[$i+1], '/')) {
$pair .= ' '.$pairs[$i+1];
$i++;
}

if (strpos($pair, ' ')) {
list($name, $version) = explode(" ", $pair, 2);
$result[] = array('name' => $name, 'version' => $version);
} else {
$result[] = array('name' => $pair);
}
}

return $result;
}
}
<?php











namespace Composer\Package\Version;

use Composer\DependencyResolver\Pool;
use Composer\Package\PackageInterface;
use Composer\Package\Loader\ArrayLoader;
use Composer\Package\Dumper\ArrayDumper;







class VersionSelector
{
private $pool;

private $parser;

public function __construct(Pool $pool)
{
$this->pool = $pool;
}









public function findBestCandidate($packageName, $targetPackageVersion = null)
{
$constraint = $targetPackageVersion ? $this->getParser()->parseConstraints($targetPackageVersion) : null;
$candidates = $this->pool->whatProvides(strtolower($packageName), $constraint, true);

if (!$candidates) {
return false;
}


 $package = reset($candidates);
foreach ($candidates as $candidate) {
if (version_compare($package->getVersion(), $candidate->getVersion(), '<')) {
$package = $candidate;
}
}

return $package;
}
















public function findRecommendedRequireVersion(PackageInterface $package)
{
$version = $package->getVersion();
if (!$package->isDev()) {
return $this->transformVersion($version, $package->getPrettyVersion(), $package->getStability());
}

$loader = new ArrayLoader($this->getParser());
$dumper = new ArrayDumper();
$extra = $loader->getBranchAlias($dumper->dump($package));
if ($extra) {
$extra = preg_replace('{^(\d+\.\d+\.\d+)(\.9999999)-dev$}', '$1.0', $extra, -1, $count);
if ($count) {
$extra = str_replace('.9999999', '.0', $extra);

return $this->transformVersion($extra, $extra, 'dev');
}
}

return $package->getPrettyVersion();
}

private function transformVersion($version, $prettyVersion, $stability)
{

 
 $semanticVersionParts = explode('.', $version);


 if (count($semanticVersionParts) == 4 && preg_match('{^0\D?}', $semanticVersionParts[3])) {

 if ($semanticVersionParts[0] === '0') {
unset($semanticVersionParts[3]);
} else {
unset($semanticVersionParts[2], $semanticVersionParts[3]);
}
$version = implode('.', $semanticVersionParts);
} else {
return $prettyVersion;
}


 if ($stability != 'stable') {
$version .= '@'.$stability;
}


 return '^' . $version;
}

private function getParser()
{
if ($this->parser === null) {
$this->parser = new VersionParser();
}

return $this->parser;
}
}
<?php











namespace Composer\Plugin;

use Composer\EventDispatcher\Event;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;






class CommandEvent extends Event
{



private $commandName;




private $input;




private $output;











public function __construct($name, $commandName, $input, $output, array $args = array(), array $flags = array())
{
parent::__construct($name, $args, $flags);
$this->commandName = $commandName;
$this->input = $input;
$this->output = $output;
}






public function getInput()
{
return $this->input;
}






public function getOutput()
{
return $this->output;
}






public function getCommandName()
{
return $this->commandName;
}
}
<?php











namespace Composer\Plugin;






class PluginEvents
{








const COMMAND = 'command';









const PRE_FILE_DOWNLOAD = 'pre-file-download';
}
<?php











namespace Composer\Plugin;

use Composer\Composer;
use Composer\IO\IOInterface;






interface PluginInterface
{





const PLUGIN_API_VERSION = '1.0.0';







public function activate(Composer $composer, IOInterface $io);
}
<?php











namespace Composer\Plugin;

use Composer\Composer;
use Composer\EventDispatcher\EventSubscriberInterface;
use Composer\IO\IOInterface;
use Composer\Package\Package;
use Composer\Package\Version\VersionParser;
use Composer\Repository\RepositoryInterface;
use Composer\Package\AliasPackage;
use Composer\Package\PackageInterface;
use Composer\Package\Link;
use Composer\Package\LinkConstraint\VersionConstraint;
use Composer\DependencyResolver\Pool;







class PluginManager
{
protected $composer;
protected $io;
protected $globalComposer;
protected $versionParser;

protected $plugins = array();
protected $registeredPlugins = array();

private static $classCounter = 0;








public function __construct(IOInterface $io, Composer $composer, Composer $globalComposer = null)
{
$this->io = $io;
$this->composer = $composer;
$this->globalComposer = $globalComposer;
$this->versionParser = new VersionParser();
}




public function loadInstalledPlugins()
{
$repo = $this->composer->getRepositoryManager()->getLocalRepository();
$globalRepo = $this->globalComposer ? $this->globalComposer->getRepositoryManager()->getLocalRepository() : null;
if ($repo) {
$this->loadRepository($repo);
}
if ($globalRepo) {
$this->loadRepository($globalRepo);
}
}






public function addPlugin(PluginInterface $plugin)
{
if ($this->io->isDebug()) {
$this->io->writeError('Loading plugin '.get_class($plugin));
}
$this->plugins[] = $plugin;
$plugin->activate($this->composer, $this->io);

if ($plugin instanceof EventSubscriberInterface) {
$this->composer->getEventDispatcher()->addSubscriber($plugin);
}
}






public function getPlugins()
{
return $this->plugins;
}












public function loadRepository(RepositoryInterface $repo)
{
foreach ($repo->getPackages() as $package) {
if ($package instanceof AliasPackage) {
continue;
}
if ('composer-plugin' === $package->getType()) {
$requiresComposer = null;
foreach ($package->getRequires() as $link) {
if ($link->getTarget() == 'composer-plugin-api') {
$requiresComposer = $link->getConstraint();
}
}

if (!$requiresComposer) {
throw new \RuntimeException("Plugin ".$package->getName()." is missing a require statement for a version of the composer-plugin-api package.");
}

if (!$requiresComposer->matches(new VersionConstraint('==', $this->versionParser->normalize(PluginInterface::PLUGIN_API_VERSION)))) {
$this->io->writeError("<warning>The plugin ".$package->getName()." requires a version of composer-plugin-api that does not match your composer installation. You may need to run composer update with the '--no-plugins' option.</warning>");
}

$this->registerPackage($package);
}

 if ('composer-installer' === $package->getType()) {
$this->registerPackage($package);
}
}
}










protected function collectDependencies(Pool $pool, array $collected, PackageInterface $package)
{
$requires = array_merge(
$package->getRequires(),
$package->getDevRequires()
);

foreach ($requires as $requireLink) {
$requiredPackage = $this->lookupInstalledPackage($pool, $requireLink);
if ($requiredPackage && !isset($collected[$requiredPackage->getName()])) {
$collected[$requiredPackage->getName()] = $requiredPackage;
$collected = $this->collectDependencies($pool, $collected, $requiredPackage);
}
}

return $collected;
}











protected function lookupInstalledPackage(Pool $pool, Link $link)
{
$packages = $pool->whatProvides($link->getTarget(), $link->getConstraint());

return (!empty($packages)) ? $packages[0] : null;
}












public function registerPackage(PackageInterface $package, $failOnMissingClasses = false)
{
$oldInstallerPlugin = ($package->getType() === 'composer-installer');

if (in_array($package->getName(), $this->registeredPlugins)) {
return;
}

$extra = $package->getExtra();
if (empty($extra['class'])) {
throw new \UnexpectedValueException('Error while installing '.$package->getPrettyName().', composer-plugin packages should have a class defined in their extra key to be usable.');
}
$classes = is_array($extra['class']) ? $extra['class'] : array($extra['class']);

$localRepo = $this->composer->getRepositoryManager()->getLocalRepository();
$globalRepo = $this->globalComposer ? $this->globalComposer->getRepositoryManager()->getLocalRepository() : null;

$pool = new Pool('dev');
$pool->addRepository($localRepo);
if ($globalRepo) {
$pool->addRepository($globalRepo);
}

$autoloadPackages = array($package->getName() => $package);
$autoloadPackages = $this->collectDependencies($pool, $autoloadPackages, $package);

$generator = $this->composer->getAutoloadGenerator();
$autoloads = array();
foreach ($autoloadPackages as $autoloadPackage) {
$downloadPath = $this->getInstallPath($autoloadPackage, ($globalRepo && $globalRepo->hasPackage($autoloadPackage)));
$autoloads[] = array($autoloadPackage, $downloadPath);
}

$map = $generator->parseAutoloads($autoloads, new Package('dummy', '1.0.0.0', '1.0.0'));
$classLoader = $generator->createLoader($map);
$classLoader->register();

foreach ($classes as $class) {
if (class_exists($class, false)) {
$code = file_get_contents($classLoader->findFile($class));
$code = preg_replace('{^(\s*)class\s+(\S+)}mi', '$1class $2_composer_tmp'.self::$classCounter, $code);
eval('?>'.$code);
$class .= '_composer_tmp'.self::$classCounter;
self::$classCounter++;
}

if ($oldInstallerPlugin) {
$installer = new $class($this->io, $this->composer);
$this->composer->getInstallationManager()->addInstaller($installer);
} elseif (class_exists($class)) {
$plugin = new $class();
$this->addPlugin($plugin);
$this->registeredPlugins[] = $package->getName();
} elseif ($failOnMissingClasses) {
throw new \UnexpectedValueException('Plugin '.$package->getName().' could not be initialized, class not found: '.$class);
}
}
}









public function getInstallPath(PackageInterface $package, $global = false)
{
if (!$global) {
return $this->composer->getInstallationManager()->getInstallPath($package);
}

return $this->globalComposer->getInstallationManager()->getInstallPath($package);
}
}
<?php











namespace Composer\Plugin;

use Composer\EventDispatcher\Event;
use Composer\Util\RemoteFilesystem;






class PreFileDownloadEvent extends Event
{



private $rfs;




private $processedUrl;








public function __construct($name, RemoteFilesystem $rfs, $processedUrl)
{
parent::__construct($name);
$this->rfs = $rfs;
$this->processedUrl = $processedUrl;
}






public function getRemoteFilesystem()
{
return $this->rfs;
}






public function setRemoteFilesystem(RemoteFilesystem $rfs)
{
$this->rfs = $rfs;
}






public function getProcessedUrl()
{
return $this->processedUrl;
}
}
<?php











namespace Composer\Repository;

use Composer\Package\AliasPackage;
use Composer\Package\PackageInterface;
use Composer\Package\CompletePackageInterface;
use Composer\Package\Version\VersionParser;






class ArrayRepository implements RepositoryInterface
{
protected $packages;

public function __construct(array $packages = array())
{
foreach ($packages as $package) {
$this->addPackage($package);
}
}




public function findPackage($name, $version)
{

 $versionParser = new VersionParser();
$version = $versionParser->normalize($version);
$name = strtolower($name);

foreach ($this->getPackages() as $package) {
if ($name === $package->getName() && $version === $package->getVersion()) {
return $package;
}
}
}




public function findPackages($name, $version = null)
{

 $name = strtolower($name);


 if (null !== $version) {
$versionParser = new VersionParser();
$version = $versionParser->normalize($version);
}

$packages = array();

foreach ($this->getPackages() as $package) {
if ($package->getName() === $name && (null === $version || $version === $package->getVersion())) {
$packages[] = $package;
}
}

return $packages;
}




public function search($query, $mode = 0)
{
$regex = '{(?:'.implode('|', preg_split('{\s+}', $query)).')}i';

$matches = array();
foreach ($this->getPackages() as $package) {
$name = $package->getName();
if (isset($matches[$name])) {
continue;
}
if (preg_match($regex, $name)
|| ($mode === self::SEARCH_FULLTEXT && $package instanceof CompletePackageInterface && preg_match($regex, implode(' ', (array) $package->getKeywords()) . ' ' . $package->getDescription()))
) {
$matches[$name] = array(
'name' => $package->getPrettyName(),
'description' => $package->getDescription(),
);
}
}

return array_values($matches);
}




public function hasPackage(PackageInterface $package)
{
$packageId = $package->getUniqueName();

foreach ($this->getPackages() as $repoPackage) {
if ($packageId === $repoPackage->getUniqueName()) {
return true;
}
}

return false;
}






public function addPackage(PackageInterface $package)
{
if (null === $this->packages) {
$this->initialize();
}
$package->setRepository($this);
$this->packages[] = $package;

if ($package instanceof AliasPackage) {
$aliasedPackage = $package->getAliasOf();
if (null === $aliasedPackage->getRepository()) {
$this->addPackage($aliasedPackage);
}
}
}

protected function createAliasPackage(PackageInterface $package, $alias, $prettyAlias)
{
return new AliasPackage($package instanceof AliasPackage ? $package->getAliasOf() : $package, $alias, $prettyAlias);
}






public function removePackage(PackageInterface $package)
{
$packageId = $package->getUniqueName();

foreach ($this->getPackages() as $key => $repoPackage) {
if ($packageId === $repoPackage->getUniqueName()) {
array_splice($this->packages, $key, 1);

return;
}
}
}




public function getPackages()
{
if (null === $this->packages) {
$this->initialize();
}

return $this->packages;
}






public function count()
{
return count($this->packages);
}




protected function initialize()
{
$this->packages = array();
}
}
<?php











namespace Composer\Repository;

use Composer\IO\IOInterface;
use Composer\Json\JsonFile;
use Composer\Package\Loader\ArrayLoader;




class ArtifactRepository extends ArrayRepository
{

protected $loader;

protected $lookup;

public function __construct(array $repoConfig, IOInterface $io)
{
if (!extension_loaded('zip')) {
throw new \RuntimeException('The artifact repository requires PHP\'s zip extension');
}

$this->loader = new ArrayLoader();
$this->lookup = $repoConfig['url'];
$this->io = $io;
}

protected function initialize()
{
parent::initialize();

$this->scanDirectory($this->lookup);
}

private function scanDirectory($path)
{
$io = $this->io;

$directory = new \RecursiveDirectoryIterator($path);
$iterator = new \RecursiveIteratorIterator($directory);
$regex = new \RegexIterator($iterator, '/^.+\.(zip|phar)$/i');
foreach ($regex as $file) {

if (!$file->isFile()) {
continue;
}

$package = $this->getComposerInformation($file);
if (!$package) {
if ($io->isVerbose()) {
$io->writeError("File <comment>{$file->getBasename()}</comment> doesn't seem to hold a package");
}
continue;
}

if ($io->isVerbose()) {
$template = 'Found package <info>%s</info> (<comment>%s</comment>) in file <info>%s</info>';
$io->writeError(sprintf($template, $package->getName(), $package->getPrettyVersion(), $file->getBasename()));
}

$this->addPackage($package);
}
}








private function locateFile(\ZipArchive $zip, $filename)
{
$indexOfShortestMatch = false;
$lengthOfShortestMatch = -1;

for ($i = 0; $i < $zip->numFiles; $i++) {
$stat = $zip->statIndex($i);
if (strcmp(basename($stat['name']), $filename) === 0) {
$directoryName = dirname($stat['name']);
if ($directoryName == '.') {

 
 return $i;
}

if (strpos($directoryName, '\\') !== false ||
strpos($directoryName, '/') !== false) {

 continue;
}

$length = strlen($stat['name']);
if ($indexOfShortestMatch == false || $length < $lengthOfShortestMatch) {

 $contents = $zip->getFromIndex($i);
if ($contents !== false) {
$indexOfShortestMatch = $i;
$lengthOfShortestMatch = $length;
}
}
}
}

return $indexOfShortestMatch;
}

private function getComposerInformation(\SplFileInfo $file)
{
$zip = new \ZipArchive();
$zip->open($file->getPathname());

if (0 == $zip->numFiles) {
return false;
}

$foundFileIndex = $this->locateFile($zip, 'composer.json');
if (false === $foundFileIndex) {
return false;
}

$configurationFileName = $zip->getNameIndex($foundFileIndex);

$composerFile = "zip://{$file->getPathname()}#$configurationFileName";
$json = file_get_contents($composerFile);

$package = JsonFile::parseJson($json, $composerFile);
$package['dist'] = array(
'type' => 'zip',
'url' => $file->getPathname(),
'shasum' => sha1_file($file->getRealPath())
);

$package = $this->loader->load($package);

return $package;
}
}
<?php











namespace Composer\Repository;

use Composer\Package\Loader\ArrayLoader;
use Composer\Package\Package;
use Composer\Package\PackageInterface;
use Composer\Package\AliasPackage;
use Composer\Package\Version\VersionParser;
use Composer\DependencyResolver\Pool;
use Composer\Json\JsonFile;
use Composer\Cache;
use Composer\Config;
use Composer\IO\IOInterface;
use Composer\Util\RemoteFilesystem;
use Composer\Plugin\PluginEvents;
use Composer\Plugin\PreFileDownloadEvent;
use Composer\EventDispatcher\EventDispatcher;




class ComposerRepository extends ArrayRepository
{
protected $config;
protected $options;
protected $url;
protected $baseUrl;
protected $io;
protected $rfs;
protected $cache;
protected $notifyUrl;
protected $searchUrl;
protected $hasProviders = false;
protected $providersUrl;
protected $lazyProvidersUrl;
protected $providerListing;
protected $providers = array();
protected $providersByUid = array();
protected $loader;
protected $rootAliases;
protected $allowSslDowngrade = false;
protected $eventDispatcher;
protected $sourceMirrors;
protected $distMirrors;
private $degradedMode = false;
private $rootData;

public function __construct(array $repoConfig, IOInterface $io, Config $config, EventDispatcher $eventDispatcher = null)
{
if (!preg_match('{^[\w.]+\??://}', $repoConfig['url'])) {

 $repoConfig['url'] = 'http://'.$repoConfig['url'];
}
$repoConfig['url'] = rtrim($repoConfig['url'], '/');

if ('https?' === substr($repoConfig['url'], 0, 6)) {
$repoConfig['url'] = (extension_loaded('openssl') ? 'https' : 'http') . substr($repoConfig['url'], 6);
}

$urlBits = parse_url($repoConfig['url']);
if ($urlBits === false || empty($urlBits['scheme'])) {
throw new \UnexpectedValueException('Invalid url given for Composer repository: '.$repoConfig['url']);
}

if (!isset($repoConfig['options'])) {
$repoConfig['options'] = array();
}
if (isset($repoConfig['allow_ssl_downgrade']) && true === $repoConfig['allow_ssl_downgrade']) {
$this->allowSslDowngrade = true;
}

$this->config = $config;
$this->options = $repoConfig['options'];
$this->url = $repoConfig['url'];
$this->baseUrl = rtrim(preg_replace('{^(.*)(?:/[^/\\]+.json)?(?:[?#].*)?$}', '$1', $this->url), '/');
$this->io = $io;
$this->cache = new Cache($io, $config->get('cache-repo-dir').'/'.preg_replace('{[^a-z0-9.]}i', '-', $this->url), 'a-z0-9.$');
$this->loader = new ArrayLoader();
$this->rfs = new RemoteFilesystem($this->io, $this->config, $this->options);
$this->eventDispatcher = $eventDispatcher;
}

public function setRootAliases(array $rootAliases)
{
$this->rootAliases = $rootAliases;
}




public function findPackage($name, $version)
{
if (!$this->hasProviders()) {
return parent::findPackage($name, $version);
}

 $versionParser = new VersionParser();
$version = $versionParser->normalize($version);
$name = strtolower($name);

foreach ($this->getProviderNames() as $providerName) {
if ($name === $providerName) {
$packages = $this->whatProvides(new Pool('dev'), $providerName);
foreach ($packages as $package) {
if ($name == $package->getName() && $version === $package->getVersion()) {
return $package;
}
}
}
}
}




public function findPackages($name, $version = null)
{
if (!$this->hasProviders()) {
return parent::findPackages($name, $version);
}

 $name = strtolower($name);


 if (null !== $version) {
$versionParser = new VersionParser();
$version = $versionParser->normalize($version);
}

$packages = array();

foreach ($this->getProviderNames() as $providerName) {
if ($name === $providerName) {
$packages = $this->whatProvides(new Pool('dev'), $providerName);
foreach ($packages as $package) {
if ($name == $package->getName() && (null === $version || $version === $package->getVersion())) {
$packages[] = $package;
}
}
}
}

return $packages;
}

public function getPackages()
{
if ($this->hasProviders()) {
throw new \LogicException('Composer repositories that have providers can not load the complete list of packages, use getProviderNames instead.');
}

return parent::getPackages();
}




public function search($query, $mode = 0)
{
$this->loadRootServerFile();

if ($this->searchUrl && $mode === self::SEARCH_FULLTEXT) {
$url = str_replace('%query%', $query, $this->searchUrl);

$hostname = parse_url($url, PHP_URL_HOST) ?: $url;
$json = $this->rfs->getContents($hostname, $url, false);
$results = JsonFile::parseJson($json, $url);

return $results['results'];
}

if ($this->hasProviders()) {
$results = array();
$regex = '{(?:'.implode('|', preg_split('{\s+}', $query)).')}i';

foreach ($this->getProviderNames() as $name) {
if (preg_match($regex, $name)) {
$results[] = array('name' => $name);
}
}

return $results;
}

return parent::search($query, $mode);
}

public function getProviderNames()
{
$this->loadRootServerFile();

if (null === $this->providerListing) {
$this->loadProviderListings($this->loadRootServerFile());
}

if ($this->lazyProvidersUrl) {

 return array();
}

if ($this->providersUrl) {
return array_keys($this->providerListing);
}


 $providers = array();
foreach (array_keys($this->providerListing) as $provider) {
$providers[] = substr($provider, 2, -5);
}

return $providers;
}

protected function configurePackageTransportOptions(PackageInterface $package)
{
foreach ($package->getDistUrls() as $url) {
if (strpos($url, $this->baseUrl) === 0) {
$package->setTransportOptions($this->options);

return;
}
}
}

public function hasProviders()
{
$this->loadRootServerFile();

return $this->hasProviders;
}

public function resetPackageIds()
{
foreach ($this->providersByUid as $package) {
if ($package instanceof AliasPackage) {
$package->getAliasOf()->setId(-1);
}
$package->setId(-1);
}
}

public function whatProvides(Pool $pool, $name)
{
if (isset($this->providers[$name])) {
return $this->providers[$name];
}


 if (preg_match(PlatformRepository::PLATFORM_PACKAGE_REGEX, $name) || '__root__' === $name) {
return array();
}

if (null === $this->providerListing) {
$this->loadProviderListings($this->loadRootServerFile());
}

if ($this->lazyProvidersUrl && !isset($this->providerListing[$name])) {
$hash = null;
$url = str_replace('%package%', $name, $this->lazyProvidersUrl);
$cacheKey = false;
} elseif ($this->providersUrl) {

 if (!isset($this->providerListing[$name])) {
return array();
}

$hash = $this->providerListing[$name]['sha256'];
$url = str_replace(array('%package%', '%hash%'), array($name, $hash), $this->providersUrl);
$cacheKey = 'provider-'.strtr($name, '/', '$').'.json';
} else {

 $url = 'p/'.$name.'.json';


 if (!isset($this->providerListing[$url])) {
return array();
}
$hash = $this->providerListing[$url]['sha256'];
$cacheKey = null;
}

if ($cacheKey && $this->cache->sha256($cacheKey) === $hash) {
$packages = json_decode($this->cache->read($cacheKey), true);
} else {
$packages = $this->fetchFile($url, $cacheKey, $hash);
}

$this->providers[$name] = array();
foreach ($packages['packages'] as $versions) {
foreach ($versions as $version) {

 if (isset($this->providersByUid[$version['uid']])) {

 if (!isset($this->providers[$name][$version['uid']])) {

 if ($this->providersByUid[$version['uid']] instanceof AliasPackage) {
$this->providers[$name][$version['uid']] = $this->providersByUid[$version['uid']]->getAliasOf();
$this->providers[$name][$version['uid'].'-alias'] = $this->providersByUid[$version['uid']];
} else {
$this->providers[$name][$version['uid']] = $this->providersByUid[$version['uid']];
}

 if (isset($this->providersByUid[$version['uid'].'-root'])) {
$this->providers[$name][$version['uid'].'-root'] = $this->providersByUid[$version['uid'].'-root'];
}
}
} else {
if (!$pool->isPackageAcceptable(strtolower($version['name']), VersionParser::parseStability($version['version']))) {
continue;
}


 $package = $this->createPackage($version, 'Composer\Package\Package');
$package->setRepository($this);

if ($package instanceof AliasPackage) {
$aliased = $package->getAliasOf();
$aliased->setRepository($this);

$this->providers[$name][$version['uid']] = $aliased;
$this->providers[$name][$version['uid'].'-alias'] = $package;


 $this->providersByUid[$version['uid']] = $package;
} else {
$this->providers[$name][$version['uid']] = $package;
$this->providersByUid[$version['uid']] = $package;
}


 unset($rootAliasData);

if (isset($this->rootAliases[$package->getName()][$package->getVersion()])) {
$rootAliasData = $this->rootAliases[$package->getName()][$package->getVersion()];
} elseif ($package instanceof AliasPackage && isset($this->rootAliases[$package->getName()][$package->getAliasOf()->getVersion()])) {
$rootAliasData = $this->rootAliases[$package->getName()][$package->getAliasOf()->getVersion()];
}

if (isset($rootAliasData)) {
$alias = $this->createAliasPackage($package, $rootAliasData['alias_normalized'], $rootAliasData['alias']);
$alias->setRepository($this);

$this->providers[$name][$version['uid'].'-root'] = $alias;
$this->providersByUid[$version['uid'].'-root'] = $alias;
}
}
}
}

return $this->providers[$name];
}




protected function initialize()
{
parent::initialize();

$repoData = $this->loadDataFromServer();

foreach ($repoData as $package) {
$this->addPackage($this->createPackage($package, 'Composer\Package\CompletePackage'));
}
}






public function addPackage(PackageInterface $package)
{
parent::addPackage($package);
$this->configurePackageTransportOptions($package);
}

protected function loadRootServerFile()
{
if (null !== $this->rootData) {
return $this->rootData;
}

if (!extension_loaded('openssl') && 'https' === substr($this->url, 0, 5)) {
throw new \RuntimeException('You must enable the openssl extension in your php.ini to load information from '.$this->url);
}

$jsonUrlParts = parse_url($this->url);

if (isset($jsonUrlParts['path']) && false !== strpos($jsonUrlParts['path'], '.json')) {
$jsonUrl = $this->url;
} else {
$jsonUrl = $this->url . '/packages.json';
}

$data = $this->fetchFile($jsonUrl, 'packages.json');

if (!empty($data['notify-batch'])) {
$this->notifyUrl = $this->canonicalizeUrl($data['notify-batch']);
} elseif (!empty($data['notify_batch'])) {

 $this->notifyUrl = $this->canonicalizeUrl($data['notify_batch']);
} elseif (!empty($data['notify'])) {
$this->notifyUrl = $this->canonicalizeUrl($data['notify']);
}

if (!empty($data['search'])) {
$this->searchUrl = $this->canonicalizeUrl($data['search']);
}

if (!empty($data['mirrors'])) {
foreach ($data['mirrors'] as $mirror) {
if (!empty($mirror['git-url'])) {
$this->sourceMirrors['git'][] = array('url' => $mirror['git-url'], 'preferred' => !empty($mirror['preferred']));
}
if (!empty($mirror['hg-url'])) {
$this->sourceMirrors['hg'][] = array('url' => $mirror['hg-url'], 'preferred' => !empty($mirror['preferred']));
}
if (!empty($mirror['dist-url'])) {
$this->distMirrors[] = array('url' => $mirror['dist-url'], 'preferred' => !empty($mirror['preferred']));
}
}
}

if (!empty($data['warning'])) {
$this->io->writeError('<warning>Warning from '.$this->url.': '.$data['warning'].'</warning>');
}

if (!empty($data['providers-lazy-url'])) {
$this->lazyProvidersUrl = $this->canonicalizeUrl($data['providers-lazy-url']);
$this->hasProviders = true;
}

if ($this->allowSslDowngrade) {
$this->url = str_replace('https://', 'http://', $this->url);
}

if (!empty($data['providers-url'])) {
$this->providersUrl = $this->canonicalizeUrl($data['providers-url']);
$this->hasProviders = true;
}

if (!empty($data['providers']) || !empty($data['providers-includes'])) {
$this->hasProviders = true;
}

return $this->rootData = $data;
}

protected function canonicalizeUrl($url)
{
if ('/' === $url[0]) {
return preg_replace('{(https?://[^/]+).*}i', '$1' . $url, $this->url);
}

return $url;
}

protected function loadDataFromServer()
{
$data = $this->loadRootServerFile();

return $this->loadIncludes($data);
}

protected function loadProviderListings($data)
{
if (isset($data['providers'])) {
if (!is_array($this->providerListing)) {
$this->providerListing = array();
}
$this->providerListing = array_merge($this->providerListing, $data['providers']);
}

if ($this->providersUrl && isset($data['provider-includes'])) {
$includes = $data['provider-includes'];
foreach ($includes as $include => $metadata) {
$url = $this->baseUrl . '/' . str_replace('%hash%', $metadata['sha256'], $include);
$cacheKey = str_replace(array('%hash%','$'), '', $include);
if ($this->cache->sha256($cacheKey) === $metadata['sha256']) {
$includedData = json_decode($this->cache->read($cacheKey), true);
} else {
$includedData = $this->fetchFile($url, $cacheKey, $metadata['sha256']);
}

$this->loadProviderListings($includedData);
}
} elseif (isset($data['providers-includes'])) {

 $includes = $data['providers-includes'];
foreach ($includes as $include => $metadata) {
if ($this->cache->sha256($include) === $metadata['sha256']) {
$includedData = json_decode($this->cache->read($include), true);
} else {
$includedData = $this->fetchFile($include, null, $metadata['sha256']);
}

$this->loadProviderListings($includedData);
}
}
}

protected function loadIncludes($data)
{
$packages = array();


 if (!isset($data['packages']) && !isset($data['includes'])) {
foreach ($data as $pkg) {
foreach ($pkg['versions'] as $metadata) {
$packages[] = $metadata;
}
}

return $packages;
}

if (isset($data['packages'])) {
foreach ($data['packages'] as $package => $versions) {
foreach ($versions as $version => $metadata) {
$packages[] = $metadata;
}
}
}

if (isset($data['includes'])) {
foreach ($data['includes'] as $include => $metadata) {
if ($this->cache->sha1($include) === $metadata['sha1']) {
$includedData = json_decode($this->cache->read($include), true);
} else {
$includedData = $this->fetchFile($include);
}
$packages = array_merge($packages, $this->loadIncludes($includedData));
}
}

return $packages;
}

protected function createPackage(array $data, $class)
{
try {
if (!isset($data['notification-url'])) {
$data['notification-url'] = $this->notifyUrl;
}

$package = $this->loader->load($data, 'Composer\Package\CompletePackage');
if (isset($this->sourceMirrors[$package->getSourceType()])) {
$package->setSourceMirrors($this->sourceMirrors[$package->getSourceType()]);
}
$package->setDistMirrors($this->distMirrors);
$this->configurePackageTransportOptions($package);

return $package;
} catch (\Exception $e) {
throw new \RuntimeException('Could not load package '.(isset($data['name']) ? $data['name'] : json_encode($data)).' in '.$this->url.': ['.get_class($e).'] '.$e->getMessage(), 0, $e);
}
}

protected function fetchFile($filename, $cacheKey = null, $sha256 = null)
{
if (null === $cacheKey) {
$cacheKey = $filename;
$filename = $this->baseUrl.'/'.$filename;
}

$retries = 3;
while ($retries--) {
try {
$preFileDownloadEvent = new PreFileDownloadEvent(PluginEvents::PRE_FILE_DOWNLOAD, $this->rfs, $filename);
if ($this->eventDispatcher) {
$this->eventDispatcher->dispatch($preFileDownloadEvent->getName(), $preFileDownloadEvent);
}

$hostname = parse_url($filename, PHP_URL_HOST) ?: $filename;
$json = $preFileDownloadEvent->getRemoteFilesystem()->getContents($hostname, $filename, false);
if ($sha256 && $sha256 !== hash('sha256', $json)) {
if ($retries) {
usleep(100000);

continue;
}


 throw new RepositorySecurityException('The contents of '.$filename.' do not match its signature. This should indicate a man-in-the-middle attack. Try running composer again and report this if you think it is a mistake.');
}
$data = JsonFile::parseJson($json, $filename);
if ($cacheKey) {
$this->cache->write($cacheKey, $json);
}

break;
} catch (\Exception $e) {
if ($retries) {
usleep(100000);
continue;
}

if ($e instanceof RepositorySecurityException) {
throw $e;
}

if ($cacheKey && ($contents = $this->cache->read($cacheKey))) {
if (!$this->degradedMode) {
$this->io->writeError('<warning>'.$e->getMessage().'</warning>');
$this->io->writeError('<warning>'.$this->url.' could not be fully loaded, package information was loaded from the local cache and may be out of date</warning>');
}
$this->degradedMode = true;
$data = JsonFile::parseJson($contents, $this->cache->getRoot().$cacheKey);

break;
}

throw $e;
}
}

return $data;
}
}
<?php











namespace Composer\Repository;

use Composer\Package\PackageInterface;






class CompositeRepository implements RepositoryInterface
{




private $repositories;





public function __construct(array $repositories)
{
$this->repositories = array();
foreach ($repositories as $repo) {
$this->addRepository($repo);
}
}






public function getRepositories()
{
return $this->repositories;
}




public function hasPackage(PackageInterface $package)
{
foreach ($this->repositories as $repository) {

if ($repository->hasPackage($package)) {
return true;
}
}

return false;
}




public function findPackage($name, $version)
{
foreach ($this->repositories as $repository) {

$package = $repository->findPackage($name, $version);
if (null !== $package) {
return $package;
}
}

return null;
}




public function findPackages($name, $version = null)
{
$packages = array();
foreach ($this->repositories as $repository) {

$packages[] = $repository->findPackages($name, $version);
}

return $packages ? call_user_func_array('array_merge', $packages) : array();
}




public function search($query, $mode = 0)
{
$matches = array();
foreach ($this->repositories as $repository) {

$matches[] = $repository->search($query, $mode);
}

return $matches ? call_user_func_array('array_merge', $matches) : array();
}




public function filterPackages($callback, $class = 'Composer\Package\Package')
{
foreach ($this->repositories as $repository) {
if (false === $repository->filterPackages($callback, $class)) {
return false;
}
}

return true;
}




public function getPackages()
{
$packages = array();
foreach ($this->repositories as $repository) {

$packages[] = $repository->getPackages();
}

return $packages ? call_user_func_array('array_merge', $packages) : array();
}




public function removePackage(PackageInterface $package)
{
foreach ($this->repositories as $repository) {

$repository->removePackage($package);
}
}




public function count()
{
$total = 0;
foreach ($this->repositories as $repository) {

$total += $repository->count();
}

return $total;
}





public function addRepository(RepositoryInterface $repository)
{
if ($repository instanceof self) {
foreach ($repository->getRepositories() as $repo) {
$this->addRepository($repo);
}
} else {
$this->repositories[] = $repository;
}
}
}
<?php











namespace Composer\Repository;

use Composer\Json\JsonFile;
use Composer\Package\Loader\ArrayLoader;
use Composer\Package\Dumper\ArrayDumper;







class FilesystemRepository extends WritableArrayRepository
{
private $file;






public function __construct(JsonFile $repositoryFile)
{
$this->file = $repositoryFile;
}




protected function initialize()
{
parent::initialize();

if (!$this->file->exists()) {
return;
}

try {
$packages = $this->file->read();

if (!is_array($packages)) {
throw new \UnexpectedValueException('Could not parse package list from the repository');
}
} catch (\Exception $e) {
throw new InvalidRepositoryException('Invalid repository data in '.$this->file->getPath().', packages could not be loaded: ['.get_class($e).'] '.$e->getMessage());
}

$loader = new ArrayLoader(null, true);
foreach ($packages as $packageData) {
$package = $loader->load($packageData);
$this->addPackage($package);
}
}

public function reload()
{
$this->packages = null;
$this->initialize();
}




public function write()
{
$data = array();
$dumper = new ArrayDumper();

foreach ($this->getCanonicalPackages() as $package) {
$data[] = $dumper->dump($package);
}

$this->file->write($data);
}
}
<?php











namespace Composer\Repository;








class InstalledArrayRepository extends WritableArrayRepository implements InstalledRepositoryInterface
{
}
<?php











namespace Composer\Repository;






class InstalledFilesystemRepository extends FilesystemRepository implements InstalledRepositoryInterface
{
}
<?php











namespace Composer\Repository;








interface InstalledRepositoryInterface extends WritableRepositoryInterface
{
}
<?php











namespace Composer\Repository;






class InvalidRepositoryException extends \Exception
{
}
<?php











namespace Composer\Repository;

use Composer\Package\Loader\ArrayLoader;
use Composer\Package\Loader\ValidatingArrayLoader;






class PackageRepository extends ArrayRepository
{
private $config;






public function __construct(array $config)
{
$this->config = $config['package'];


 if (!is_numeric(key($this->config))) {
$this->config = array($this->config);
}
}




protected function initialize()
{
parent::initialize();

$loader = new ValidatingArrayLoader(new ArrayLoader, false);
foreach ($this->config as $package) {
try {
$package = $loader->load($package);
} catch (\Exception $e) {
throw new InvalidRepositoryException('A repository of type "package" contains an invalid package definition: '.$e->getMessage()."\n\nInvalid package definition:\n".json_encode($package));
}

$this->addPackage($package);
}
}
}
<?php











namespace Composer\Repository\Pear;

use Composer\Util\RemoteFilesystem;








abstract class BaseChannelReader
{



const CHANNEL_NS = 'http://pear.php.net/channel-1.0';
const ALL_CATEGORIES_NS = 'http://pear.php.net/dtd/rest.allcategories';
const CATEGORY_PACKAGES_INFO_NS = 'http://pear.php.net/dtd/rest.categorypackageinfo';
const ALL_PACKAGES_NS = 'http://pear.php.net/dtd/rest.allpackages';
const ALL_RELEASES_NS = 'http://pear.php.net/dtd/rest.allreleases';
const PACKAGE_INFO_NS = 'http://pear.php.net/dtd/rest.package';


private $rfs;

protected function __construct(RemoteFilesystem $rfs)
{
$this->rfs = $rfs;
}









protected function requestContent($origin, $path)
{
$url = rtrim($origin, '/') . '/' . ltrim($path, '/');
$content = $this->rfs->getContents($origin, $url, false);
if (!$content) {
throw new \UnexpectedValueException('The PEAR channel at ' . $url . ' did not respond.');
}

return $content;
}









protected function requestXml($origin, $path)
{

 $xml = simplexml_load_string($this->requestContent($origin, $path), "SimpleXMLElement", LIBXML_NOERROR);

if (false == $xml) {
$url = rtrim($origin, '/') . '/' . ltrim($path, '/');
throw new \UnexpectedValueException(sprintf('The PEAR channel at ' . $origin . ' is broken. (Invalid XML at file `%s`)', $path));
}

return $xml;
}
}
<?php











namespace Composer\Repository\Pear;






class ChannelInfo
{
private $name;
private $alias;
private $packages;






public function __construct($name, $alias, array $packages)
{
$this->name = $name;
$this->alias = $alias;
$this->packages = $packages;
}






public function getName()
{
return $this->name;
}






public function getAlias()
{
return $this->alias;
}






public function getPackages()
{
return $this->packages;
}
}
<?php











namespace Composer\Repository\Pear;

use Composer\Util\RemoteFilesystem;








class ChannelReader extends BaseChannelReader
{

private $readerMap;

public function __construct(RemoteFilesystem $rfs)
{
parent::__construct($rfs);

$rest10reader = new ChannelRest10Reader($rfs);
$rest11reader = new ChannelRest11Reader($rfs);

$this->readerMap = array(
'REST1.3' => $rest11reader,
'REST1.2' => $rest11reader,
'REST1.1' => $rest11reader,
'REST1.0' => $rest10reader,
);
}








public function read($url)
{
$xml = $this->requestXml($url, "/channel.xml");

$channelName = (string) $xml->name;
$channelSummary = (string) $xml->summary;
$channelAlias = (string) $xml->suggestedalias;

$supportedVersions = array_keys($this->readerMap);
$selectedRestVersion = $this->selectRestVersion($xml, $supportedVersions);
if (!$selectedRestVersion) {
throw new \UnexpectedValueException(sprintf('PEAR repository %s does not supports any of %s protocols.', $url, implode(', ', $supportedVersions)));
}

$reader = $this->readerMap[$selectedRestVersion['version']];
$packageDefinitions = $reader->read($selectedRestVersion['baseUrl']);

return new ChannelInfo($channelName, $channelAlias, $packageDefinitions);
}








private function selectRestVersion($channelXml, $supportedVersions)
{
$channelXml->registerXPathNamespace('ns', self::CHANNEL_NS);

foreach ($supportedVersions as $version) {
$xpathTest = "ns:servers/ns:primary/ns:rest/ns:baseurl[@type='{$version}']";
$testResult = $channelXml->xpath($xpathTest);
if (count($testResult) > 0) {
return array('version' => $version, 'baseUrl' => (string) $testResult[0]);
}
}

return null;
}
}
<?php











namespace Composer\Repository\Pear;

use Composer\Downloader\TransportException;












class ChannelRest10Reader extends BaseChannelReader
{
private $dependencyReader;

public function __construct($rfs)
{
parent::__construct($rfs);

$this->dependencyReader = new PackageDependencyParser();
}








public function read($baseUrl)
{
return $this->readPackages($baseUrl);
}








private function readPackages($baseUrl)
{
$result = array();

$xmlPath = '/p/packages.xml';
$xml = $this->requestXml($baseUrl, $xmlPath);
$xml->registerXPathNamespace('ns', self::ALL_PACKAGES_NS);
foreach ($xml->xpath('ns:p') as $node) {
$packageName = (string) $node;
$packageInfo = $this->readPackage($baseUrl, $packageName);
$result[] = $packageInfo;
}

return $result;
}









private function readPackage($baseUrl, $packageName)
{
$xmlPath = '/p/' . strtolower($packageName) . '/info.xml';
$xml = $this->requestXml($baseUrl, $xmlPath);
$xml->registerXPathNamespace('ns', self::PACKAGE_INFO_NS);

$channelName = (string) $xml->c;
$packageName = (string) $xml->n;
$license = (string) $xml->l;
$shortDescription = (string) $xml->s;
$description = (string) $xml->d;

return new PackageInfo(
$channelName,
$packageName,
$license,
$shortDescription,
$description,
$this->readPackageReleases($baseUrl, $packageName)
);
}










private function readPackageReleases($baseUrl, $packageName)
{
$result = array();

try {
$xmlPath = '/r/' . strtolower($packageName) . '/allreleases.xml';
$xml = $this->requestXml($baseUrl, $xmlPath);
$xml->registerXPathNamespace('ns', self::ALL_RELEASES_NS);
foreach ($xml->xpath('ns:r') as $node) {
$releaseVersion = (string) $node->v;
$releaseStability = (string) $node->s;

try {
$result[$releaseVersion] = new ReleaseInfo(
$releaseStability,
$this->readPackageReleaseDependencies($baseUrl, $packageName, $releaseVersion)
);
} catch (TransportException $exception) {
if ($exception->getCode() != 404) {
throw $exception;
}
}
}
} catch (TransportException $exception) {
if ($exception->getCode() != 404) {
throw $exception;
}
}

return $result;
}










private function readPackageReleaseDependencies($baseUrl, $packageName, $version)
{
$dependencyReader = new PackageDependencyParser();

$depthPath = '/r/' . strtolower($packageName) . '/deps.' . $version . '.txt';
$content = $this->requestContent($baseUrl, $depthPath);
$dependencyArray = unserialize($content);
$result = $dependencyReader->buildDependencyInfo($dependencyArray);

return $result;
}
}
<?php











namespace Composer\Repository\Pear;










class ChannelRest11Reader extends BaseChannelReader
{
private $dependencyReader;

public function __construct($rfs)
{
parent::__construct($rfs);

$this->dependencyReader = new PackageDependencyParser();
}








public function read($baseUrl)
{
return $this->readChannelPackages($baseUrl);
}








private function readChannelPackages($baseUrl)
{
$result = array();

$xml = $this->requestXml($baseUrl, "/c/categories.xml");
$xml->registerXPathNamespace('ns', self::ALL_CATEGORIES_NS);
foreach ($xml->xpath('ns:c') as $node) {
$categoryName = (string) $node;
$categoryPackages = $this->readCategoryPackages($baseUrl, $categoryName);
$result = array_merge($result, $categoryPackages);
}

return $result;
}









private function readCategoryPackages($baseUrl, $categoryName)
{
$result = array();

$categoryPath = '/c/'.urlencode($categoryName).'/packagesinfo.xml';
$xml = $this->requestXml($baseUrl, $categoryPath);
$xml->registerXPathNamespace('ns', self::CATEGORY_PACKAGES_INFO_NS);
foreach ($xml->xpath('ns:pi') as $node) {
$packageInfo = $this->parsePackage($node);
$result[] = $packageInfo;
}

return $result;
}







private function parsePackage($packageInfo)
{
$packageInfo->registerXPathNamespace('ns', self::CATEGORY_PACKAGES_INFO_NS);
$channelName = (string) $packageInfo->p->c;
$packageName = (string) $packageInfo->p->n;
$license = (string) $packageInfo->p->l;
$shortDescription = (string) $packageInfo->p->s;
$description = (string) $packageInfo->p->d;

$dependencies = array();
foreach ($packageInfo->xpath('ns:deps') as $node) {
$dependencyVersion = (string) $node->v;
$dependencyArray = unserialize((string) $node->d);

$dependencyInfo = $this->dependencyReader->buildDependencyInfo($dependencyArray);

$dependencies[$dependencyVersion] = $dependencyInfo;
}

$releases = array();
$releasesInfo = $packageInfo->xpath('ns:a/ns:r');
if ($releasesInfo) {
foreach ($releasesInfo as $node) {
$releaseVersion = (string) $node->v;
$releaseStability = (string) $node->s;
$releases[$releaseVersion] = new ReleaseInfo(
$releaseStability,
isset($dependencies[$releaseVersion]) ? $dependencies[$releaseVersion] : new DependencyInfo(array(), array())
);
}
}

return new PackageInfo(
$channelName,
$packageName,
$license,
$shortDescription,
$description,
$releases
);
}
}
<?php











namespace Composer\Repository\Pear;






class DependencyConstraint
{
private $type;
private $constraint;
private $channelName;
private $packageName;







public function __construct($type, $constraint, $channelName, $packageName)
{
$this->type = $type;
$this->constraint = $constraint;
$this->channelName = $channelName;
$this->packageName = $packageName;
}

public function getChannelName()
{
return $this->channelName;
}

public function getConstraint()
{
return $this->constraint;
}

public function getPackageName()
{
return $this->packageName;
}

public function getType()
{
return $this->type;
}
}
<?php











namespace Composer\Repository\Pear;






class DependencyInfo
{
private $requires;
private $optionals;





public function __construct($requires, $optionals)
{
$this->requires = $requires;
$this->optionals = $optionals;
}




public function getRequires()
{
return $this->requires;
}




public function getOptionals()
{
return $this->optionals;
}
}
<?php











namespace Composer\Repository\Pear;






class PackageDependencyParser
{






public function buildDependencyInfo($depArray)
{
if (!is_array($depArray)) {
return new DependencyInfo(array(), array());
}
if (!$this->isHash($depArray)) {
return new DependencyInfo($this->buildDependency10Info($depArray), array());
}

return $this->buildDependency20Info($depArray);
}













private function buildDependency10Info($depArray)
{
static $dep10toOperatorMap = array('has' => '==', 'eq' => '==', 'ge' => '>=', 'gt' => '>', 'le' => '<=', 'lt' => '<', 'not' => '!=');

$result = array();

foreach ($depArray as $depItem) {
if (empty($depItem['rel']) || !array_key_exists($depItem['rel'], $dep10toOperatorMap)) {

 continue;
}

$depType = !empty($depItem['optional']) && 'yes' == $depItem['optional']
? 'optional'
: 'required';
$depType = 'not' == $depItem['rel']
? 'conflicts'
: $depType;

$depVersion = !empty($depItem['version']) ? $this->parseVersion($depItem['version']) : '*';


 $depVersionConstraint = ('has' == $depItem['rel'] || 'not' == $depItem['rel']) && '*' == $depVersion
? '*'
: $dep10toOperatorMap[$depItem['rel']] . $depVersion;

switch ($depItem['type']) {
case 'php':
$depChannelName = 'php';
$depPackageName = '';
break;
case 'pkg':
$depChannelName = !empty($depItem['channel']) ? $depItem['channel'] : 'pear.php.net';
$depPackageName = $depItem['name'];
break;
case 'ext':
$depChannelName = 'ext';
$depPackageName = $depItem['name'];
break;
case 'os':
case 'sapi':
$depChannelName = '';
$depPackageName = '';
break;
default:
$depChannelName = '';
$depPackageName = '';
break;
}

if ('' != $depChannelName) {
$result[] = new DependencyConstraint(
$depType,
$depVersionConstraint,
$depChannelName,
$depPackageName
);
}
}

return $result;
}







private function buildDependency20Info($depArray)
{
$result = array();
$optionals = array();
$defaultOptionals = array();
foreach ($depArray as $depType => $depTypeGroup) {
if (!is_array($depTypeGroup)) {
continue;
}
if ('required' == $depType || 'optional' == $depType) {
foreach ($depTypeGroup as $depItemType => $depItem) {
switch ($depItemType) {
case 'php':
$result[] = new DependencyConstraint(
$depType,
$this->parse20VersionConstraint($depItem),
'php',
''
);
break;
case 'package':
$deps = $this->buildDepPackageConstraints($depItem, $depType);
$result = array_merge($result, $deps);
break;
case 'extension':
$deps = $this->buildDepExtensionConstraints($depItem, $depType);
$result = array_merge($result, $deps);
break;
case 'subpackage':
$deps = $this->buildDepPackageConstraints($depItem, 'replaces');
$defaultOptionals += $deps;
break;
case 'os':
case 'pearinstaller':
break;
default:
break;
}
}
} elseif ('group' == $depType) {
if ($this->isHash($depTypeGroup)) {
$depTypeGroup = array($depTypeGroup);
}

foreach ($depTypeGroup as $depItem) {
$groupName = $depItem['attribs']['name'];
if (!isset($optionals[$groupName])) {
$optionals[$groupName] = array();
}

if (isset($depItem['subpackage'])) {
$optionals[$groupName] += $this->buildDepPackageConstraints($depItem['subpackage'], 'replaces');
} else {
$result += $this->buildDepPackageConstraints($depItem['package'], 'optional');
}
}
}
}

if (count($defaultOptionals) > 0) {
$optionals['*'] = $defaultOptionals;
}

return new DependencyInfo($result, $optionals);
}








private function buildDepExtensionConstraints($depItem, $depType)
{
if ($this->isHash($depItem)) {
$depItem = array($depItem);
}

$result = array();
foreach ($depItem as $subDepItem) {
$depChannelName = 'ext';
$depPackageName = $subDepItem['name'];
$depVersionConstraint = $this->parse20VersionConstraint($subDepItem);

$result[] = new DependencyConstraint(
$depType,
$depVersionConstraint,
$depChannelName,
$depPackageName
);
}

return $result;
}








private function buildDepPackageConstraints($depItem, $depType)
{
if ($this->isHash($depItem)) {
$depItem = array($depItem);
}

$result = array();
foreach ($depItem as $subDepItem) {
$depChannelName = $subDepItem['channel'];
$depPackageName = $subDepItem['name'];
$depVersionConstraint = $this->parse20VersionConstraint($subDepItem);
if (isset($subDepItem['conflicts'])) {
$depType = 'conflicts';
}

$result[] = new DependencyConstraint(
$depType,
$depVersionConstraint,
$depChannelName,
$depPackageName
);
}

return $result;
}







private function parse20VersionConstraint(array $data)
{
static $dep20toOperatorMap = array('has' => '==', 'min' => '>=', 'max' => '<=', 'exclude' => '!=');

$versions = array();
$values = array_intersect_key($data, $dep20toOperatorMap);
if (0 == count($values)) {
return '*';
}
if (isset($values['min']) && isset($values['exclude']) && $data['min'] == $data['exclude']) {
$versions[] = '>' . $this->parseVersion($values['min']);
} elseif (isset($values['max']) && isset($values['exclude']) && $data['max'] == $data['exclude']) {
$versions[] = '<' . $this->parseVersion($values['max']);
} else {
foreach ($values as $op => $version) {
if ('exclude' == $op && is_array($version)) {
foreach ($version as $versionPart) {
$versions[] = $dep20toOperatorMap[$op] . $this->parseVersion($versionPart);
}
} else {
$versions[] = $dep20toOperatorMap[$op] . $this->parseVersion($version);
}
}
}

return implode(',', $versions);
}







private function parseVersion($version)
{
if (preg_match('{^v?(\d{1,3})(\.\d+)?(\.\d+)?(\.\d+)?}i', $version, $matches)) {
$version = $matches[1]
.(!empty($matches[2]) ? $matches[2] : '.0')
.(!empty($matches[3]) ? $matches[3] : '.0')
.(!empty($matches[4]) ? $matches[4] : '.0');

return $version;
}

return null;
}







private function isHash(array $array)
{
return !array_key_exists(1, $array) && !array_key_exists(0, $array);
}
}
<?php











namespace Composer\Repository\Pear;






class PackageInfo
{
private $channelName;
private $packageName;
private $license;
private $shortDescription;
private $description;
private $releases;









public function __construct($channelName, $packageName, $license, $shortDescription, $description, $releases)
{
$this->channelName = $channelName;
$this->packageName = $packageName;
$this->license = $license;
$this->shortDescription = $shortDescription;
$this->description = $description;
$this->releases = $releases;
}




public function getChannelName()
{
return $this->channelName;
}




public function getPackageName()
{
return $this->packageName;
}




public function getDescription()
{
return $this->description;
}




public function getShortDescription()
{
return $this->shortDescription;
}




public function getLicense()
{
return $this->license;
}




public function getReleases()
{
return $this->releases;
}
}
<?php











namespace Composer\Repository\Pear;






class ReleaseInfo
{
private $stability;
private $dependencyInfo;





public function __construct($stability, $dependencyInfo)
{
$this->stability = $stability;
$this->dependencyInfo = $dependencyInfo;
}




public function getDependencyInfo()
{
return $this->dependencyInfo;
}




public function getStability()
{
return $this->stability;
}
}
<?php











namespace Composer\Repository;

use Composer\IO\IOInterface;
use Composer\Package\Version\VersionParser;
use Composer\Repository\Pear\ChannelReader;
use Composer\Package\CompletePackage;
use Composer\Repository\Pear\ChannelInfo;
use Composer\EventDispatcher\EventDispatcher;
use Composer\Package\Link;
use Composer\Package\LinkConstraint\VersionConstraint;
use Composer\Util\RemoteFilesystem;
use Composer\Config;










class PearRepository extends ArrayRepository
{
private $url;
private $io;
private $rfs;
private $versionParser;




private $vendorAlias;

public function __construct(array $repoConfig, IOInterface $io, Config $config, EventDispatcher $dispatcher = null, RemoteFilesystem $rfs = null)
{
if (!preg_match('{^https?://}', $repoConfig['url'])) {
$repoConfig['url'] = 'http://'.$repoConfig['url'];
}

$urlBits = parse_url($repoConfig['url']);
if (empty($urlBits['scheme']) || empty($urlBits['host'])) {
throw new \UnexpectedValueException('Invalid url given for PEAR repository: '.$repoConfig['url']);
}

$this->url = rtrim($repoConfig['url'], '/');
$this->io = $io;
$this->rfs = $rfs ?: new RemoteFilesystem($this->io, $config);
$this->vendorAlias = isset($repoConfig['vendor-alias']) ? $repoConfig['vendor-alias'] : null;
$this->versionParser = new VersionParser();
}

protected function initialize()
{
parent::initialize();

$this->io->writeError('Initializing PEAR repository '.$this->url);

$reader = new ChannelReader($this->rfs);
try {
$channelInfo = $reader->read($this->url);
} catch (\Exception $e) {
$this->io->writeError('<warning>PEAR repository from '.$this->url.' could not be loaded. '.$e->getMessage().'</warning>');

return;
}
$packages = $this->buildComposerPackages($channelInfo, $this->versionParser);
foreach ($packages as $package) {
$this->addPackage($package);
}
}








private function buildComposerPackages(ChannelInfo $channelInfo, VersionParser $versionParser)
{
$result = array();
foreach ($channelInfo->getPackages() as $packageDefinition) {
foreach ($packageDefinition->getReleases() as $version => $releaseInfo) {
try {
$normalizedVersion = $versionParser->normalize($version);
} catch (\UnexpectedValueException $e) {
if ($this->io->isVerbose()) {
$this->io->writeError('Could not load '.$packageDefinition->getPackageName().' '.$version.': '.$e->getMessage());
}
continue;
}

$composerPackageName = $this->buildComposerPackageName($packageDefinition->getChannelName(), $packageDefinition->getPackageName());


 
 $urlBits = parse_url($this->url);
$scheme = (isset($urlBits['scheme']) && 'https' === $urlBits['scheme'] && extension_loaded('openssl')) ? 'https' : 'http';
$distUrl = "{$scheme}://{$packageDefinition->getChannelName()}/get/{$packageDefinition->getPackageName()}-{$version}.tgz";

$requires = array();
$suggests = array();
$conflicts = array();
$replaces = array();


 
 if ($channelInfo->getName() == $packageDefinition->getChannelName()) {
$composerPackageAlias = $this->buildComposerPackageName($channelInfo->getAlias(), $packageDefinition->getPackageName());
$aliasConstraint = new VersionConstraint('==', $normalizedVersion);
$replaces[] = new Link($composerPackageName, $composerPackageAlias, $aliasConstraint, 'replaces', (string) $aliasConstraint);
}


 if (!empty($this->vendorAlias)
&& ($this->vendorAlias != 'pear-'.$channelInfo->getAlias() || $channelInfo->getName() != $packageDefinition->getChannelName())
) {
$composerPackageAlias = "{$this->vendorAlias}/{$packageDefinition->getPackageName()}";
$aliasConstraint = new VersionConstraint('==', $normalizedVersion);
$replaces[] = new Link($composerPackageName, $composerPackageAlias, $aliasConstraint, 'replaces', (string) $aliasConstraint);
}

foreach ($releaseInfo->getDependencyInfo()->getRequires() as $dependencyConstraint) {
$dependencyPackageName = $this->buildComposerPackageName($dependencyConstraint->getChannelName(), $dependencyConstraint->getPackageName());
$constraint = $versionParser->parseConstraints($dependencyConstraint->getConstraint());
$link = new Link($composerPackageName, $dependencyPackageName, $constraint, $dependencyConstraint->getType(), $dependencyConstraint->getConstraint());
switch ($dependencyConstraint->getType()) {
case 'required':
$requires[] = $link;
break;
case 'conflicts':
$conflicts[] = $link;
break;
case 'replaces':
$replaces[] = $link;
break;
}
}

foreach ($releaseInfo->getDependencyInfo()->getOptionals() as $group => $dependencyConstraints) {
foreach ($dependencyConstraints as $dependencyConstraint) {
$dependencyPackageName = $this->buildComposerPackageName($dependencyConstraint->getChannelName(), $dependencyConstraint->getPackageName());
$suggests[$group.'-'.$dependencyPackageName] = $dependencyConstraint->getConstraint();
}
}

$package = new CompletePackage($composerPackageName, $normalizedVersion, $version);
$package->setType('pear-library');
$package->setDescription($packageDefinition->getDescription());
$package->setLicense(array($packageDefinition->getLicense()));
$package->setDistType('file');
$package->setDistUrl($distUrl);
$package->setAutoload(array('classmap' => array('')));
$package->setIncludePaths(array('/'));
$package->setRequires($requires);
$package->setConflicts($conflicts);
$package->setSuggests($suggests);
$package->setReplaces($replaces);
$result[] = $package;
}
}

return $result;
}

private function buildComposerPackageName($channelName, $packageName)
{
if ('php' === $channelName) {
return "php";
}
if ('ext' === $channelName) {
return "ext-{$packageName}";
}

return "pear-{$channelName}/{$packageName}";
}
}
<?php











namespace Composer\Repository;

use Composer\Package\PackageInterface;
use Composer\Package\CompletePackage;
use Composer\Package\Version\VersionParser;
use Composer\Plugin\PluginInterface;




class PlatformRepository extends ArrayRepository
{
const PLATFORM_PACKAGE_REGEX = '{^(?:php(?:-64bit)?|hhvm|(?:ext|lib)-[^/]+)$}i';








private $overrides;

public function __construct(array $packages = array(), array $overrides = array())
{
parent::__construct($packages);
$this->overrides = array();
foreach ($overrides as $name => $version) {
$this->overrides[strtolower($name)] = array('name' => $name, 'version' => $version);
}
}

protected function initialize()
{
parent::initialize();

$versionParser = new VersionParser();


 
 foreach ($this->overrides as $override) {

 if (!preg_match(self::PLATFORM_PACKAGE_REGEX, $override['name'])) {
throw new \InvalidArgumentException('Invalid platform package name in config.platform: '.$override['name']);
}

$version = $versionParser->normalize($override['version']);
$package = new CompletePackage($override['name'], $version, $override['version']);
$package->setDescription('Overridden virtual platform package '.$override['name']);
parent::addPackage($package);
}

$prettyVersion = PluginInterface::PLUGIN_API_VERSION;
$version = $versionParser->normalize($prettyVersion);
$composerPluginApi = new CompletePackage('composer-plugin-api', $version, $prettyVersion);
$composerPluginApi->setDescription('The Composer Plugin API');
$this->addPackage($composerPluginApi);

try {
$prettyVersion = PHP_VERSION;
$version = $versionParser->normalize($prettyVersion);
} catch (\UnexpectedValueException $e) {
$prettyVersion = preg_replace('#^([^~+-]+).*$#', '$1', PHP_VERSION);
$version = $versionParser->normalize($prettyVersion);
}

$php = new CompletePackage('php', $version, $prettyVersion);
$php->setDescription('The PHP interpreter');
$this->addPackage($php);

if (PHP_INT_SIZE === 8) {
$php64 = new CompletePackage('php-64bit', $version, $prettyVersion);
$php64->setDescription('The PHP interpreter (64bit)');
$this->addPackage($php64);
}

$loadedExtensions = get_loaded_extensions();


 foreach ($loadedExtensions as $name) {
if (in_array($name, array('standard', 'Core'))) {
continue;
}

$reflExt = new \ReflectionExtension($name);
try {
$prettyVersion = $reflExt->getVersion();
$version = $versionParser->normalize($prettyVersion);
} catch (\UnexpectedValueException $e) {
$prettyVersion = '0';
$version = $versionParser->normalize($prettyVersion);
}

$packageName = $this->buildPackageName($name);
$ext = new CompletePackage($packageName, $version, $prettyVersion);
$ext->setDescription('The '.$name.' PHP extension');
$this->addPackage($ext);
}


 
 
 foreach ($loadedExtensions as $name) {
$prettyVersion = null;
switch ($name) {
case 'curl':
$curlVersion = curl_version();
$prettyVersion = $curlVersion['version'];
break;

case 'iconv':
$prettyVersion = ICONV_VERSION;
break;

case 'intl':
$name = 'ICU';
if (defined('INTL_ICU_VERSION')) {
$prettyVersion = INTL_ICU_VERSION;
} else {
$reflector = new \ReflectionExtension('intl');

ob_start();
$reflector->info();
$output = ob_get_clean();

preg_match('/^ICU version => (.*)$/m', $output, $matches);
$prettyVersion = $matches[1];
}

break;

case 'libxml':
$prettyVersion = LIBXML_DOTTED_VERSION;
break;

case 'openssl':
$prettyVersion = preg_replace_callback('{^(?:OpenSSL\s*)?([0-9.]+)([a-z]?).*}', function ($match) {
return $match[1] . (empty($match[2]) ? '' : '.'.(ord($match[2]) - 96));
}, OPENSSL_VERSION_TEXT);
break;

case 'pcre':
$prettyVersion = preg_replace('{^(\S+).*}', '$1', PCRE_VERSION);
break;

case 'uuid':
$prettyVersion = phpversion('uuid');
break;

case 'xsl':
$prettyVersion = LIBXSLT_DOTTED_VERSION;
break;

default:

 continue 2;
}

try {
$version = $versionParser->normalize($prettyVersion);
} catch (\UnexpectedValueException $e) {
continue;
}

$lib = new CompletePackage('lib-'.$name, $version, $prettyVersion);
$lib->setDescription('The '.$name.' PHP library');
$this->addPackage($lib);
}

if (defined('HHVM_VERSION')) {
try {
$prettyVersion = HHVM_VERSION;
$version = $versionParser->normalize($prettyVersion);
} catch (\UnexpectedValueException $e) {
$prettyVersion = preg_replace('#^([^~+-]+).*$#', '$1', HHVM_VERSION);
$version = $versionParser->normalize($prettyVersion);
}

$hhvm = new CompletePackage('hhvm', $version, $prettyVersion);
$hhvm->setDescription('The HHVM Runtime (64bit)');
$this->addPackage($hhvm);
}
}




public function addPackage(PackageInterface $package)
{

 if (isset($this->overrides[strtolower($package->getName())])) {
return;
}
parent::addPackage($package);
}

private function buildPackageName($name)
{
return 'ext-' . str_replace(' ', '-', $name);
}
}
<?php











namespace Composer\Repository;

use Composer\Package\PackageInterface;








interface RepositoryInterface extends \Countable
{
const SEARCH_FULLTEXT = 0;
const SEARCH_NAME = 1;








public function hasPackage(PackageInterface $package);









public function findPackage($name, $version);









public function findPackages($name, $version = null);






public function getPackages();








public function search($query, $mode = 0);
}
<?php











namespace Composer\Repository;

use Composer\IO\IOInterface;
use Composer\Config;
use Composer\EventDispatcher\EventDispatcher;








class RepositoryManager
{
private $localRepository;
private $repositories = array();
private $repositoryClasses = array();
private $io;
private $config;
private $eventDispatcher;

public function __construct(IOInterface $io, Config $config, EventDispatcher $eventDispatcher = null)
{
$this->io = $io;
$this->config = $config;
$this->eventDispatcher = $eventDispatcher;
}









public function findPackage($name, $version)
{
foreach ($this->repositories as $repository) {
if ($package = $repository->findPackage($name, $version)) {
return $package;
}
}
}









public function findPackages($name, $version)
{
$packages = array();

foreach ($this->repositories as $repository) {
$packages = array_merge($packages, $repository->findPackages($name, $version));
}

return $packages;
}






public function addRepository(RepositoryInterface $repository)
{
$this->repositories[] = $repository;
}









public function createRepository($type, $config)
{
if (!isset($this->repositoryClasses[$type])) {
throw new \InvalidArgumentException('Repository type is not registered: '.$type);
}

$class = $this->repositoryClasses[$type];

return new $class($config, $this->io, $this->config, $this->eventDispatcher);
}







public function setRepositoryClass($type, $class)
{
$this->repositoryClasses[$type] = $class;
}






public function getRepositories()
{
return $this->repositories;
}






public function setLocalRepository(WritableRepositoryInterface $repository)
{
$this->localRepository = $repository;
}






public function getLocalRepository()
{
return $this->localRepository;
}







public function getLocalRepositories()
{
trigger_error('This method is deprecated, use getLocalRepository instead since the getLocalDevRepository is now gone', E_USER_DEPRECATED);

return array($this->localRepository);
}
}
<?php











namespace Composer\Repository;






class RepositorySecurityException extends \Exception
{
}
<?php











namespace Composer\Repository\Vcs;

use Composer\Config;
use Composer\Json\JsonFile;
use Composer\IO\IOInterface;




class GitBitbucketDriver extends VcsDriver implements VcsDriverInterface
{
protected $owner;
protected $repository;
protected $tags;
protected $branches;
protected $rootIdentifier;
protected $infoCache = array();




public function initialize()
{
preg_match('#^https?://bitbucket\.org/([^/]+)/(.+?)\.git$#', $this->url, $match);
$this->owner = $match[1];
$this->repository = $match[2];
$this->originUrl = 'bitbucket.org';
}




public function getRootIdentifier()
{
if (null === $this->rootIdentifier) {
$resource = $this->getScheme() . '://api.bitbucket.org/1.0/repositories/'.$this->owner.'/'.$this->repository;
$repoData = JsonFile::parseJson($this->getContents($resource), $resource);
$this->rootIdentifier = !empty($repoData['main_branch']) ? $repoData['main_branch'] : 'master';
}

return $this->rootIdentifier;
}




public function getUrl()
{
return $this->url;
}




public function getSource($identifier)
{
return array('type' => 'git', 'url' => $this->getUrl(), 'reference' => $identifier);
}




public function getDist($identifier)
{
$url = $this->getScheme() . '://bitbucket.org/'.$this->owner.'/'.$this->repository.'/get/'.$identifier.'.zip';

return array('type' => 'zip', 'url' => $url, 'reference' => $identifier, 'shasum' => '');
}




public function getComposerInformation($identifier)
{
if (!isset($this->infoCache[$identifier])) {
$resource = $this->getScheme() . '://bitbucket.org/'.$this->owner.'/'.$this->repository.'/raw/'.$identifier.'/composer.json';
$composer = $this->getContents($resource);
if (!$composer) {
return;
}

$composer = JsonFile::parseJson($composer, $resource);

if (empty($composer['time'])) {
$resource = $this->getScheme() . '://api.bitbucket.org/1.0/repositories/'.$this->owner.'/'.$this->repository.'/changesets/'.$identifier;
$changeset = JsonFile::parseJson($this->getContents($resource), $resource);
$composer['time'] = $changeset['timestamp'];
}
$this->infoCache[$identifier] = $composer;
}

return $this->infoCache[$identifier];
}




public function getTags()
{
if (null === $this->tags) {
$resource = $this->getScheme() . '://api.bitbucket.org/1.0/repositories/'.$this->owner.'/'.$this->repository.'/tags';
$tagsData = JsonFile::parseJson($this->getContents($resource), $resource);
$this->tags = array();
foreach ($tagsData as $tag => $data) {
$this->tags[$tag] = $data['raw_node'];
}
}

return $this->tags;
}




public function getBranches()
{
if (null === $this->branches) {
$resource = $this->getScheme() . '://api.bitbucket.org/1.0/repositories/'.$this->owner.'/'.$this->repository.'/branches';
$branchData = JsonFile::parseJson($this->getContents($resource), $resource);
$this->branches = array();
foreach ($branchData as $branch => $data) {
$this->branches[$branch] = $data['raw_node'];
}
}

return $this->branches;
}




public static function supports(IOInterface $io, Config $config, $url, $deep = false)
{
if (!preg_match('#^https?://bitbucket\.org/([^/]+)/(.+?)\.git$#', $url)) {
return false;
}

if (!extension_loaded('openssl')) {
if ($io->isVerbose()) {
$io->writeError('Skipping Bitbucket git driver for '.$url.' because the OpenSSL PHP extension is missing.');
}

return false;
}

return true;
}
}
<?php











namespace Composer\Repository\Vcs;

use Composer\Json\JsonFile;
use Composer\Util\ProcessExecutor;
use Composer\Util\Filesystem;
use Composer\Util\Git as GitUtil;
use Composer\IO\IOInterface;
use Composer\Cache;
use Composer\Config;




class GitDriver extends VcsDriver
{
protected $cache;
protected $tags;
protected $branches;
protected $rootIdentifier;
protected $repoDir;
protected $infoCache = array();




public function initialize()
{
if (Filesystem::isLocalPath($this->url)) {
$this->repoDir = $this->url;
$cacheUrl = realpath($this->url);
} else {
$this->repoDir = $this->config->get('cache-vcs-dir') . '/' . preg_replace('{[^a-z0-9.]}i', '-', $this->url) . '/';

GitUtil::cleanEnv();

$fs = new Filesystem();
$fs->ensureDirectoryExists(dirname($this->repoDir));

if (!is_writable(dirname($this->repoDir))) {
throw new \RuntimeException('Can not clone '.$this->url.' to access package information. The "'.dirname($this->repoDir).'" directory is not writable by the current user.');
}

if (preg_match('{^ssh://[^@]+@[^:]+:[^0-9]+}', $this->url)) {
throw new \InvalidArgumentException('The source URL '.$this->url.' is invalid, ssh URLs should have a port number after ":".'."\n".'Use ssh://git@example.com:22/path or just git@example.com:path if you do not want to provide a password or custom port.');
}

$gitUtil = new GitUtil($this->io, $this->config, $this->process, $fs);


 if (is_dir($this->repoDir) && 0 === $this->process->execute('git rev-parse --git-dir', $output, $this->repoDir) && trim($output) === '.') {
try {
$commandCallable = function ($url) {
return sprintf('git remote set-url origin %s && git remote update --prune origin', ProcessExecutor::escape($url));
};
$gitUtil->runCommand($commandCallable, $this->url, $this->repoDir);
} catch (\Exception $e) {
$this->io->writeError('<error>Failed to update '.$this->url.', package information from this repository may be outdated ('.$e->getMessage().')</error>');
}
} else {

 $fs->removeDirectory($this->repoDir);

$repoDir = $this->repoDir;
$commandCallable = function ($url) use ($repoDir) {
return sprintf('git clone --mirror %s %s', ProcessExecutor::escape($url), ProcessExecutor::escape($repoDir));
};

$gitUtil->runCommand($commandCallable, $this->url, $this->repoDir, true);
}

$cacheUrl = $this->url;
}

$this->getTags();
$this->getBranches();

$this->cache = new Cache($this->io, $this->config->get('cache-repo-dir').'/'.preg_replace('{[^a-z0-9.]}i', '-', $cacheUrl));
}




public function getRootIdentifier()
{
if (null === $this->rootIdentifier) {
$this->rootIdentifier = 'master';


 $this->process->execute('git branch --no-color', $output, $this->repoDir);
$branches = $this->process->splitLines($output);
if (!in_array('* master', $branches)) {
foreach ($branches as $branch) {
if ($branch && preg_match('{^\* +(\S+)}', $branch, $match)) {
$this->rootIdentifier = $match[1];
break;
}
}
}
}

return $this->rootIdentifier;
}




public function getUrl()
{
return $this->url;
}




public function getSource($identifier)
{
return array('type' => 'git', 'url' => $this->getUrl(), 'reference' => $identifier);
}




public function getDist($identifier)
{
return null;
}




public function getComposerInformation($identifier)
{
if (preg_match('{[a-f0-9]{40}}i', $identifier) && $res = $this->cache->read($identifier)) {
$this->infoCache[$identifier] = JsonFile::parseJson($res);
}

if (!isset($this->infoCache[$identifier])) {
$resource = sprintf('%s:composer.json', ProcessExecutor::escape($identifier));
$this->process->execute(sprintf('git show %s', $resource), $composer, $this->repoDir);

if (!trim($composer)) {
return;
}

$composer = JsonFile::parseJson($composer, $resource);

if (empty($composer['time'])) {
$this->process->execute(sprintf('git log -1 --format=%%at %s', ProcessExecutor::escape($identifier)), $output, $this->repoDir);
$date = new \DateTime('@'.trim($output), new \DateTimeZone('UTC'));
$composer['time'] = $date->format('Y-m-d H:i:s');
}

if (preg_match('{[a-f0-9]{40}}i', $identifier)) {
$this->cache->write($identifier, json_encode($composer));
}

$this->infoCache[$identifier] = $composer;
}

return $this->infoCache[$identifier];
}




public function getTags()
{
if (null === $this->tags) {
$this->tags = array();

$this->process->execute('git show-ref --tags', $output, $this->repoDir);
foreach ($output = $this->process->splitLines($output) as $tag) {
if ($tag && preg_match('{^([a-f0-9]{40}) refs/tags/(\S+)$}', $tag, $match)) {
$this->tags[$match[2]] = $match[1];
}
}
}

return $this->tags;
}




public function getBranches()
{
if (null === $this->branches) {
$branches = array();

$this->process->execute('git branch --no-color --no-abbrev -v', $output, $this->repoDir);
foreach ($this->process->splitLines($output) as $branch) {
if ($branch && !preg_match('{^ *[^/]+/HEAD }', $branch)) {
if (preg_match('{^(?:\* )? *(\S+) *([a-f0-9]+)(?: .*)?$}', $branch, $match)) {
$branches[$match[1]] = $match[2];
}
}
}

$this->branches = $branches;
}

return $this->branches;
}




public static function supports(IOInterface $io, Config $config, $url, $deep = false)
{
if (preg_match('#(^git://|\.git$|git(?:olite)?@|//git\.|//github.com/)#i', $url)) {
return true;
}


 if (Filesystem::isLocalPath($url)) {
$url = Filesystem::getPlatformPath($url);
if (!is_dir($url)) {
return false;
}

$process = new ProcessExecutor($io);

 if ($process->execute('git tag', $output, $url) === 0) {
return true;
}
}

if (!$deep) {
return false;
}

$process = new ProcessExecutor($io);
if ($process->execute('git ls-remote --heads ' . ProcessExecutor::escape($url), $output) === 0) {
return true;
}

return false;
}
}
<?php











namespace Composer\Repository\Vcs;

use Composer\Config;
use Composer\Downloader\TransportException;
use Composer\Json\JsonFile;
use Composer\Cache;
use Composer\IO\IOInterface;
use Composer\Util\GitHub;




class GitHubDriver extends VcsDriver
{
protected $cache;
protected $owner;
protected $repository;
protected $tags;
protected $branches;
protected $rootIdentifier;
protected $hasIssues;
protected $infoCache = array();
protected $isPrivate = false;






protected $gitDriver;




public function initialize()
{
preg_match('#^(?:(?:https?|git)://([^/]+)/|git@([^:]+):)([^/]+)/(.+?)(?:\.git|/)?$#', $this->url, $match);
$this->owner = $match[3];
$this->repository = $match[4];
$this->originUrl = !empty($match[1]) ? $match[1] : $match[2];
$this->cache = new Cache($this->io, $this->config->get('cache-repo-dir').'/'.$this->originUrl.'/'.$this->owner.'/'.$this->repository);

if (isset($this->repoConfig['no-api']) && $this->repoConfig['no-api']) {
$this->setupGitDriver($this->url);

return;
}

$this->fetchRootIdentifier();
}

public function getRepositoryUrl()
{
return 'https://'.$this->originUrl.'/'.$this->owner.'/'.$this->repository;
}




public function getRootIdentifier()
{
if ($this->gitDriver) {
return $this->gitDriver->getRootIdentifier();
}

return $this->rootIdentifier;
}




public function getUrl()
{
if ($this->gitDriver) {
return $this->gitDriver->getUrl();
}

return 'https://' . $this->originUrl . '/'.$this->owner.'/'.$this->repository.'.git';
}




protected function getApiUrl()
{
if ('github.com' === $this->originUrl) {
$apiUrl = 'api.github.com';
} else {
$apiUrl = $this->originUrl . '/api/v3';
}

return 'https://' . $apiUrl;
}




public function getSource($identifier)
{
if ($this->gitDriver) {
return $this->gitDriver->getSource($identifier);
}
if ($this->isPrivate) {

 
 $url = $this->generateSshUrl();
} else {
$url = $this->getUrl();
}

return array('type' => 'git', 'url' => $url, 'reference' => $identifier);
}




public function getDist($identifier)
{
$url = $this->getApiUrl() . '/repos/'.$this->owner.'/'.$this->repository.'/zipball/'.$identifier;

return array('type' => 'zip', 'url' => $url, 'reference' => $identifier, 'shasum' => '');
}




public function getComposerInformation($identifier)
{
if ($this->gitDriver) {
return $this->gitDriver->getComposerInformation($identifier);
}

if (preg_match('{[a-f0-9]{40}}i', $identifier) && $res = $this->cache->read($identifier)) {
$this->infoCache[$identifier] = JsonFile::parseJson($res);
}

if (!isset($this->infoCache[$identifier])) {
$notFoundRetries = 2;
while ($notFoundRetries) {
try {
$resource = $this->getApiUrl() . '/repos/'.$this->owner.'/'.$this->repository.'/contents/composer.json?ref='.urlencode($identifier);
$composer = JsonFile::parseJson($this->getContents($resource));
if (empty($composer['content']) || $composer['encoding'] !== 'base64' || !($composer = base64_decode($composer['content']))) {
throw new \RuntimeException('Could not retrieve composer.json from '.$resource);
}
break;
} catch (TransportException $e) {
if (404 !== $e->getCode()) {
throw $e;
}


 
 $notFoundRetries--;
$composer = false;
}
}

if ($composer) {
$composer = JsonFile::parseJson($composer, $resource);

if (empty($composer['time'])) {
$resource = $this->getApiUrl() . '/repos/'.$this->owner.'/'.$this->repository.'/commits/'.urlencode($identifier);
$commit = JsonFile::parseJson($this->getContents($resource), $resource);
$composer['time'] = $commit['commit']['committer']['date'];
}
if (!isset($composer['support']['source'])) {
$label = array_search($identifier, $this->getTags()) ?: array_search($identifier, $this->getBranches()) ?: $identifier;
$composer['support']['source'] = sprintf('https://%s/%s/%s/tree/%s', $this->originUrl, $this->owner, $this->repository, $label);
}
if (!isset($composer['support']['issues']) && $this->hasIssues) {
$composer['support']['issues'] = sprintf('https://%s/%s/%s/issues', $this->originUrl, $this->owner, $this->repository);
}
}

if (preg_match('{[a-f0-9]{40}}i', $identifier)) {
$this->cache->write($identifier, json_encode($composer));
}

$this->infoCache[$identifier] = $composer;
}

return $this->infoCache[$identifier];
}




public function getTags()
{
if ($this->gitDriver) {
return $this->gitDriver->getTags();
}
if (null === $this->tags) {
$this->tags = array();
$resource = $this->getApiUrl() . '/repos/'.$this->owner.'/'.$this->repository.'/tags?per_page=100';

do {
$tagsData = JsonFile::parseJson($this->getContents($resource), $resource);
foreach ($tagsData as $tag) {
$this->tags[$tag['name']] = $tag['commit']['sha'];
}

$resource = $this->getNextPage();
} while ($resource);
}

return $this->tags;
}




public function getBranches()
{
if ($this->gitDriver) {
return $this->gitDriver->getBranches();
}
if (null === $this->branches) {
$this->branches = array();
$resource = $this->getApiUrl() . '/repos/'.$this->owner.'/'.$this->repository.'/git/refs/heads?per_page=100';

$branchBlacklist = array('gh-pages');

do {
$branchData = JsonFile::parseJson($this->getContents($resource), $resource);
foreach ($branchData as $branch) {
$name = substr($branch['ref'], 11);
if (!in_array($name, $branchBlacklist)) {
$this->branches[$name] = $branch['object']['sha'];
}
}

$resource = $this->getNextPage();
} while ($resource);
}

return $this->branches;
}




public static function supports(IOInterface $io, Config $config, $url, $deep = false)
{
if (!preg_match('#^((?:https?|git)://([^/]+)/|git@([^:]+):)([^/]+)/(.+?)(?:\.git|/)?$#', $url, $matches)) {
return false;
}

$originUrl = !empty($matches[2]) ? $matches[2] : $matches[3];
if (!in_array($originUrl, $config->get('github-domains'))) {
return false;
}

if (!extension_loaded('openssl')) {
if ($io->isVerbose()) {
$io->writeError('Skipping GitHub driver for '.$url.' because the OpenSSL PHP extension is missing.');
}

return false;
}

return true;
}






protected function generateSshUrl()
{
return 'git@' . $this->originUrl . ':'.$this->owner.'/'.$this->repository.'.git';
}




protected function getContents($url, $fetchingRepoData = false)
{
try {
return parent::getContents($url);
} catch (TransportException $e) {
$gitHubUtil = new GitHub($this->io, $this->config, $this->process, $this->remoteFilesystem);

switch ($e->getCode()) {
case 401:
case 404:

 if (!$fetchingRepoData) {
throw $e;
}

if ($gitHubUtil->authorizeOAuth($this->originUrl)) {
return parent::getContents($url);
}

if (!$this->io->isInteractive()) {
return $this->attemptCloneFallback();
}

$gitHubUtil->authorizeOAuthInteractively($this->originUrl, 'Your GitHub credentials are required to fetch private repository metadata (<info>'.$this->url.'</info>)');

return parent::getContents($url);

case 403:
if (!$this->io->hasAuthentication($this->originUrl) && $gitHubUtil->authorizeOAuth($this->originUrl)) {
return parent::getContents($url);
}

if (!$this->io->isInteractive() && $fetchingRepoData) {
return $this->attemptCloneFallback();
}

$rateLimited = false;
foreach ($e->getHeaders() as $header) {
if (preg_match('{^X-RateLimit-Remaining: *0$}i', trim($header))) {
$rateLimited = true;
}
}

if (!$this->io->hasAuthentication($this->originUrl)) {
if (!$this->io->isInteractive()) {
$this->io->writeError('<error>GitHub API limit exhausted. Failed to get metadata for the '.$this->url.' repository, try running in interactive mode so that you can enter your GitHub credentials to increase the API limit</error>');
throw $e;
}

$gitHubUtil->authorizeOAuthInteractively($this->originUrl, 'API limit exhausted. Enter your GitHub credentials to get a larger API limit (<info>'.$this->url.'</info>)');

return parent::getContents($url);
}

if ($rateLimited) {
$rateLimit = $this->getRateLimit($e->getHeaders());
$this->io->writeError(sprintf(
'<error>GitHub API limit (%d calls/hr) is exhausted. You are already authorized so you have to wait until %s before doing more requests</error>',
$rateLimit['limit'],
$rateLimit['reset']
));
}

throw $e;

default:
throw $e;
}
}
}








protected function getRateLimit(array $headers)
{
$rateLimit = array(
'limit' => '?',
'reset' => '?',
);

foreach ($headers as $header) {
$header = trim($header);
if (false === strpos($header, 'X-RateLimit-')) {
continue;
}
list($type, $value) = explode(':', $header, 2);
switch ($type) {
case 'X-RateLimit-Limit':
$rateLimit['limit'] = (int) trim($value);
break;
case 'X-RateLimit-Reset':
$rateLimit['reset'] = date('Y-m-d H:i:s', (int) trim($value));
break;
}
}

return $rateLimit;
}






protected function fetchRootIdentifier()
{
$repoDataUrl = $this->getApiUrl() . '/repos/'.$this->owner.'/'.$this->repository;

$repoData = JsonFile::parseJson($this->getContents($repoDataUrl, true), $repoDataUrl);
if (null === $repoData && null !== $this->gitDriver) {
return;
}

$this->owner = $repoData['owner']['login'];
$this->repository = $repoData['name'];

$this->isPrivate = !empty($repoData['private']);
if (isset($repoData['default_branch'])) {
$this->rootIdentifier = $repoData['default_branch'];
} elseif (isset($repoData['master_branch'])) {
$this->rootIdentifier = $repoData['master_branch'];
} else {
$this->rootIdentifier = 'master';
}
$this->hasIssues = !empty($repoData['has_issues']);
}

protected function attemptCloneFallback()
{
$this->isPrivate = true;

try {

 
 
 
 $this->setupGitDriver($this->generateSshUrl());

return;
} catch (\RuntimeException $e) {
$this->gitDriver = null;

$this->io->writeError('<error>Failed to clone the '.$this->generateSshUrl().' repository, try running in interactive mode so that you can enter your GitHub credentials</error>');
throw $e;
}
}

protected function setupGitDriver($url)
{
$this->gitDriver = new GitDriver(
array('url' => $url),
$this->io,
$this->config,
$this->process,
$this->remoteFilesystem
);
$this->gitDriver->initialize();
}

protected function getNextPage()
{
$headers = $this->remoteFilesystem->getLastHeaders();
foreach ($headers as $header) {
if (substr($header, 0, 5) === 'Link:') {
$links = explode(',', substr($header, 5));
foreach ($links as $link) {
if (preg_match('{<(.+?)>; *rel="next"}', $link, $match)) {
return $match[1];
}
}
}
}
}
}
<?php











namespace Composer\Repository\Vcs;

use Composer\Config;
use Composer\Json\JsonFile;
use Composer\IO\IOInterface;




class HgBitbucketDriver extends VcsDriver
{
protected $owner;
protected $repository;
protected $tags;
protected $branches;
protected $rootIdentifier;
protected $infoCache = array();




public function initialize()
{
preg_match('#^https?://bitbucket\.org/([^/]+)/([^/]+)/?$#', $this->url, $match);
$this->owner = $match[1];
$this->repository = $match[2];
$this->originUrl = 'bitbucket.org';
}




public function getRootIdentifier()
{
if (null === $this->rootIdentifier) {
$resource = $this->getScheme() . '://bitbucket.org/api/1.0/repositories/'.$this->owner.'/'.$this->repository.'/tags';
$repoData = JsonFile::parseJson($this->getContents($resource), $resource);
if (array() === $repoData || !isset($repoData['tip'])) {
throw new \RuntimeException($this->url.' does not appear to be a mercurial repository, use '.$this->url.'.git if this is a git bitbucket repository');
}
$this->rootIdentifier = $repoData['tip']['raw_node'];
}

return $this->rootIdentifier;
}




public function getUrl()
{
return $this->url;
}




public function getSource($identifier)
{
return array('type' => 'hg', 'url' => $this->getUrl(), 'reference' => $identifier);
}




public function getDist($identifier)
{
$url = $this->getScheme() . '://bitbucket.org/'.$this->owner.'/'.$this->repository.'/get/'.$identifier.'.zip';

return array('type' => 'zip', 'url' => $url, 'reference' => $identifier, 'shasum' => '');
}




public function getComposerInformation($identifier)
{
if (!isset($this->infoCache[$identifier])) {
$resource = $this->getScheme() . '://bitbucket.org/api/1.0/repositories/'.$this->owner.'/'.$this->repository.'/src/'.$identifier.'/composer.json';
$repoData = JsonFile::parseJson($this->getContents($resource), $resource);


 
 
 

if (!array_key_exists('data', $repoData)) {
return;
}

$composer = JsonFile::parseJson($repoData['data'], $resource);

if (empty($composer['time'])) {
$resource = $this->getScheme() . '://bitbucket.org/api/1.0/repositories/'.$this->owner.'/'.$this->repository.'/changesets/'.$identifier;
$changeset = JsonFile::parseJson($this->getContents($resource), $resource);
$composer['time'] = $changeset['timestamp'];
}
$this->infoCache[$identifier] = $composer;
}

return $this->infoCache[$identifier];
}




public function getTags()
{
if (null === $this->tags) {
$resource = $this->getScheme() . '://bitbucket.org/api/1.0/repositories/'.$this->owner.'/'.$this->repository.'/tags';
$tagsData = JsonFile::parseJson($this->getContents($resource), $resource);
$this->tags = array();
foreach ($tagsData as $tag => $data) {
$this->tags[$tag] = $data['raw_node'];
}
unset($this->tags['tip']);
}

return $this->tags;
}




public function getBranches()
{
if (null === $this->branches) {
$resource = $this->getScheme() . '://bitbucket.org/api/1.0/repositories/'.$this->owner.'/'.$this->repository.'/branches';
$branchData = JsonFile::parseJson($this->getContents($resource), $resource);
$this->branches = array();
foreach ($branchData as $branch => $data) {
$this->branches[$branch] = $data['raw_node'];
}
}

return $this->branches;
}




public static function supports(IOInterface $io, Config $config, $url, $deep = false)
{
if (!preg_match('#^https?://bitbucket\.org/([^/]+)/([^/]+)/?$#', $url)) {
return false;
}

if (!extension_loaded('openssl')) {
if ($io->isVerbose()) {
$io->writeError('Skipping Bitbucket hg driver for '.$url.' because the OpenSSL PHP extension is missing.');
}

return false;
}

return true;
}
}
<?php











namespace Composer\Repository\Vcs;

use Composer\Config;
use Composer\Json\JsonFile;
use Composer\Util\ProcessExecutor;
use Composer\Util\Filesystem;
use Composer\IO\IOInterface;




class HgDriver extends VcsDriver
{
protected $tags;
protected $branches;
protected $rootIdentifier;
protected $repoDir;
protected $infoCache = array();




public function initialize()
{
if (Filesystem::isLocalPath($this->url)) {
$this->repoDir = $this->url;
} else {
$cacheDir = $this->config->get('cache-vcs-dir');
$this->repoDir = $cacheDir . '/' . preg_replace('{[^a-z0-9]}i', '-', $this->url) . '/';

$fs = new Filesystem();
$fs->ensureDirectoryExists($cacheDir);

if (!is_writable(dirname($this->repoDir))) {
throw new \RuntimeException('Can not clone '.$this->url.' to access package information. The "'.$cacheDir.'" directory is not writable by the current user.');
}


 if (is_dir($this->repoDir) && 0 === $this->process->execute('hg summary', $output, $this->repoDir)) {
if (0 !== $this->process->execute('hg pull', $output, $this->repoDir)) {
$this->io->writeError('<error>Failed to update '.$this->url.', package information from this repository may be outdated ('.$this->process->getErrorOutput().')</error>');
}
} else {

 $fs->removeDirectory($this->repoDir);

if (0 !== $this->process->execute(sprintf('hg clone --noupdate %s %s', ProcessExecutor::escape($this->url), ProcessExecutor::escape($this->repoDir)), $output, $cacheDir)) {
$output = $this->process->getErrorOutput();

if (0 !== $this->process->execute('hg --version', $ignoredOutput)) {
throw new \RuntimeException('Failed to clone '.$this->url.', hg was not found, check that it is installed and in your PATH env.' . "\n\n" . $this->process->getErrorOutput());
}

throw new \RuntimeException('Failed to clone '.$this->url.', could not read packages from it' . "\n\n" .$output);
}
}
}

$this->getTags();
$this->getBranches();
}




public function getRootIdentifier()
{
if (null === $this->rootIdentifier) {
$this->process->execute(sprintf('hg tip --template "{node}"'), $output, $this->repoDir);
$output = $this->process->splitLines($output);
$this->rootIdentifier = $output[0];
}

return $this->rootIdentifier;
}




public function getUrl()
{
return $this->url;
}




public function getSource($identifier)
{
return array('type' => 'hg', 'url' => $this->getUrl(), 'reference' => $identifier);
}




public function getDist($identifier)
{
return null;
}




public function getComposerInformation($identifier)
{
if (!isset($this->infoCache[$identifier])) {
$this->process->execute(sprintf('hg cat -r %s composer.json', ProcessExecutor::escape($identifier)), $composer, $this->repoDir);

if (!trim($composer)) {
return;
}

$composer = JsonFile::parseJson($composer, $identifier);

if (empty($composer['time'])) {
$this->process->execute(sprintf('hg log --template "{date|rfc3339date}" -r %s', ProcessExecutor::escape($identifier)), $output, $this->repoDir);
$date = new \DateTime(trim($output), new \DateTimeZone('UTC'));
$composer['time'] = $date->format('Y-m-d H:i:s');
}
$this->infoCache[$identifier] = $composer;
}

return $this->infoCache[$identifier];
}




public function getTags()
{
if (null === $this->tags) {
$tags = array();

$this->process->execute('hg tags', $output, $this->repoDir);
foreach ($this->process->splitLines($output) as $tag) {
if ($tag && preg_match('(^([^\s]+)\s+\d+:(.*)$)', $tag, $match)) {
$tags[$match[1]] = $match[2];
}
}
unset($tags['tip']);

$this->tags = $tags;
}

return $this->tags;
}




public function getBranches()
{
if (null === $this->branches) {
$branches = array();
$bookmarks = array();

$this->process->execute('hg branches', $output, $this->repoDir);
foreach ($this->process->splitLines($output) as $branch) {
if ($branch && preg_match('(^([^\s]+)\s+\d+:([a-f0-9]+))', $branch, $match)) {
$branches[$match[1]] = $match[2];
}
}

$this->process->execute('hg bookmarks', $output, $this->repoDir);
foreach ($this->process->splitLines($output) as $branch) {
if ($branch && preg_match('(^(?:[\s*]*)([^\s]+)\s+\d+:(.*)$)', $branch, $match)) {
$bookmarks[$match[1]] = $match[2];
}
}


 $this->branches = array_merge($bookmarks, $branches);
}

return $this->branches;
}




public static function supports(IOInterface $io, Config $config, $url, $deep = false)
{
if (preg_match('#(^(?:https?|ssh)://(?:[^@]@)?bitbucket.org|https://(?:.*?)\.kilnhg.com)#i', $url)) {
return true;
}


 if (Filesystem::isLocalPath($url)) {
$url = Filesystem::getPlatformPath($url);
if (!is_dir($url)) {
return false;
}

$process = new ProcessExecutor();

 if ($process->execute('hg summary', $output, $url) === 0) {
return true;
}
}

if (!$deep) {
return false;
}

$processExecutor = new ProcessExecutor();
$exit = $processExecutor->execute(sprintf('hg identify %s', ProcessExecutor::escape($url)), $ignored);

return $exit === 0;
}
}
<?php











namespace Composer\Repository\Vcs;

use Composer\Config;
use Composer\IO\IOInterface;
use Composer\Util\ProcessExecutor;
use Composer\Util\Perforce;




class PerforceDriver extends VcsDriver
{
protected $depot;
protected $branch;
protected $perforce;
protected $composerInfo;
protected $composerInfoIdentifier;




public function initialize()
{
$this->depot = $this->repoConfig['depot'];
$this->branch = '';
if (!empty($this->repoConfig['branch'])) {
$this->branch = $this->repoConfig['branch'];
}

$this->initPerforce($this->repoConfig);
$this->perforce->p4Login($this->io);
$this->perforce->checkStream($this->depot);

$this->perforce->writeP4ClientSpec();
$this->perforce->connectClient();

return true;
}

private function initPerforce($repoConfig)
{
if (!empty($this->perforce)) {
return;
}

$repoDir = $this->config->get('cache-vcs-dir') . '/' . $this->depot;
$this->perforce = Perforce::create($repoConfig, $this->getUrl(), $repoDir, $this->process, $this->io);
}




public function getComposerInformation($identifier)
{
if (!empty($this->composerInfoIdentifier)) {
if (strcmp($identifier, $this->composerInfoIdentifier) === 0) {
return $this->composerInfo;
}
}
$composer_info = $this->perforce->getComposerInformation($identifier);

return $composer_info;
}




public function getRootIdentifier()
{
return $this->branch;
}




public function getBranches()
{
$branches = $this->perforce->getBranches();

return $branches;
}




public function getTags()
{
$tags = $this->perforce->getTags();

return $tags;
}




public function getDist($identifier)
{
return null;
}




public function getSource($identifier)
{
$source = array(
'type' => 'perforce',
'url' => $this->repoConfig['url'],
'reference' => $identifier,
'p4user' => $this->perforce->getUser()
);

return $source;
}




public function getUrl()
{
return $this->url;
}




public function hasComposerFile($identifier)
{
$this->composerInfo = $this->perforce->getComposerInformation('//' . $this->depot . '/' . $identifier);
$this->composerInfoIdentifier = $identifier;

return !empty($this->composerInfo);
}




public function getContents($url)
{
return false;
}




public static function supports(IOInterface $io, Config $config, $url, $deep = false)
{
if ($deep || preg_match('#\b(perforce|p4)\b#i', $url)) {
return Perforce::checkServerExists($url, new ProcessExecutor($io));
}

return false;
}




public function cleanup()
{
$this->perforce->cleanupClientSpec();
$this->perforce = null;
}

public function getDepot()
{
return $this->depot;
}

public function getBranch()
{
return $this->branch;
}
}
<?php











namespace Composer\Repository\Vcs;

use Composer\Cache;
use Composer\Config;
use Composer\Json\JsonFile;
use Composer\Util\ProcessExecutor;
use Composer\Util\Filesystem;
use Composer\Util\Svn as SvnUtil;
use Composer\IO\IOInterface;
use Composer\Downloader\TransportException;





class SvnDriver extends VcsDriver
{



protected $cache;
protected $baseUrl;
protected $tags;
protected $branches;
protected $rootIdentifier;
protected $infoCache = array();

protected $trunkPath = 'trunk';
protected $branchesPath = 'branches';
protected $tagsPath = 'tags';
protected $packagePath = '';
protected $cacheCredentials = true;




private $util;




public function initialize()
{
$this->url = $this->baseUrl = rtrim(self::normalizeUrl($this->url), '/');

SvnUtil::cleanEnv();

if (isset($this->repoConfig['trunk-path'])) {
$this->trunkPath = $this->repoConfig['trunk-path'];
}
if (isset($this->repoConfig['branches-path'])) {
$this->branchesPath = $this->repoConfig['branches-path'];
}
if (isset($this->repoConfig['tags-path'])) {
$this->tagsPath = $this->repoConfig['tags-path'];
}
if (array_key_exists('svn-cache-credentials', $this->repoConfig)) {
$this->cacheCredentials = (bool) $this->repoConfig['svn-cache-credentials'];
}
if (isset($this->repoConfig['package-path'])) {
$this->packagePath = '/' . trim($this->repoConfig['package-path'], '/');
}

if (false !== ($pos = strrpos($this->url, '/' . $this->trunkPath))) {
$this->baseUrl = substr($this->url, 0, $pos);
}

$this->cache = new Cache($this->io, $this->config->get('cache-repo-dir').'/'.preg_replace('{[^a-z0-9.]}i', '-', $this->baseUrl));

$this->getBranches();
$this->getTags();
}




public function getRootIdentifier()
{
return $this->rootIdentifier ?: $this->trunkPath;
}




public function getUrl()
{
return $this->url;
}




public function getSource($identifier)
{
return array('type' => 'svn', 'url' => $this->baseUrl, 'reference' => $identifier);
}




public function getDist($identifier)
{
return null;
}




public function getComposerInformation($identifier)
{
$identifier = '/' . trim($identifier, '/') . '/';

if ($res = $this->cache->read($identifier.'.json')) {
$this->infoCache[$identifier] = JsonFile::parseJson($res);
}

if (!isset($this->infoCache[$identifier])) {
preg_match('{^(.+?)(@\d+)?/$}', $identifier, $match);
if (!empty($match[2])) {
$path = $match[1];
$rev = $match[2];
} else {
$path = $identifier;
$rev = '';
}

try {
$resource = $path.'composer.json';
$output = $this->execute('svn cat', $this->baseUrl . $resource . $rev);
if (!trim($output)) {
return;
}
} catch (\RuntimeException $e) {
throw new TransportException($e->getMessage());
}

$composer = JsonFile::parseJson($output, $this->baseUrl . $resource . $rev);

if (empty($composer['time'])) {
$output = $this->execute('svn info', $this->baseUrl . $path . $rev);
foreach ($this->process->splitLines($output) as $line) {
if ($line && preg_match('{^Last Changed Date: ([^(]+)}', $line, $match)) {
$date = new \DateTime($match[1], new \DateTimeZone('UTC'));
$composer['time'] = $date->format('Y-m-d H:i:s');
break;
}
}
}

$this->cache->write($identifier.'.json', json_encode($composer));
$this->infoCache[$identifier] = $composer;
}

return $this->infoCache[$identifier];
}




public function getTags()
{
if (null === $this->tags) {
$this->tags = array();

if ($this->tagsPath !== false) {
$output = $this->execute('svn ls --verbose', $this->baseUrl . '/' . $this->tagsPath);
if ($output) {
foreach ($this->process->splitLines($output) as $line) {
$line = trim($line);
if ($line && preg_match('{^\s*(\S+).*?(\S+)\s*$}', $line, $match)) {
if (isset($match[1]) && isset($match[2]) && $match[2] !== './') {
$this->tags[rtrim($match[2], '/')] = $this->buildIdentifier(
'/' . $this->tagsPath . '/' . $match[2],
$match[1]
);
}
}
}
}
}
}

return $this->tags;
}




public function getBranches()
{
if (null === $this->branches) {
$this->branches = array();

if (false === $this->trunkPath) {
$trunkParent = $this->baseUrl . '/';
} else {
$trunkParent = $this->baseUrl . '/' . $this->trunkPath;
}

$output = $this->execute('svn ls --verbose', $trunkParent);
if ($output) {
foreach ($this->process->splitLines($output) as $line) {
$line = trim($line);
if ($line && preg_match('{^\s*(\S+).*?(\S+)\s*$}', $line, $match)) {
if (isset($match[1]) && isset($match[2]) && $match[2] === './') {
$this->branches['trunk'] = $this->buildIdentifier(
'/' . $this->trunkPath,
$match[1]
);
$this->rootIdentifier = $this->branches['trunk'];
break;
}
}
}
}
unset($output);

if ($this->branchesPath !== false) {
$output = $this->execute('svn ls --verbose', $this->baseUrl . '/' . $this->branchesPath);
if ($output) {
foreach ($this->process->splitLines(trim($output)) as $line) {
$line = trim($line);
if ($line && preg_match('{^\s*(\S+).*?(\S+)\s*$}', $line, $match)) {
if (isset($match[1]) && isset($match[2]) && $match[2] !== './') {
$this->branches[rtrim($match[2], '/')] = $this->buildIdentifier(
'/' . $this->branchesPath . '/' . $match[2],
$match[1]
);
}
}
}
}
}
}

return $this->branches;
}




public static function supports(IOInterface $io, Config $config, $url, $deep = false)
{
$url = self::normalizeUrl($url);
if (preg_match('#(^svn://|^svn\+ssh://|svn\.)#i', $url)) {
return true;
}


 if (!$deep && !Filesystem::isLocalPath($url)) {
return false;
}

$processExecutor = new ProcessExecutor();

$exit = $processExecutor->execute(
"svn info --non-interactive {$url}",
$ignoredOutput
);

if ($exit === 0) {

 return true;
}

if (false !== stripos($processExecutor->getErrorOutput(), 'authorization failed:')) {

 
 return true;
}

return false;
}








protected static function normalizeUrl($url)
{
$fs = new Filesystem();
if ($fs->isAbsolutePath($url)) {
return 'file://' . strtr($url, '\\', '/');
}

return $url;
}










protected function execute($command, $url)
{
if (null === $this->util) {
$this->util = new SvnUtil($this->baseUrl, $this->io, $this->config, $this->process);
$this->util->setCacheCredentials($this->cacheCredentials);
}

try {
return $this->util->execute($command, $url);
} catch (\RuntimeException $e) {
if (0 !== $this->process->execute('svn --version', $ignoredOutput)) {
throw new \RuntimeException('Failed to load '.$this->url.', svn was not found, check that it is installed and in your PATH env.' . "\n\n" . $this->process->getErrorOutput());
}

throw new \RuntimeException(
'Repository '.$this->url.' could not be processed, '.$e->getMessage()
);
}
}









protected function buildIdentifier($baseDir, $revision)
{
return rtrim($baseDir, '/') . $this->packagePath . '/@' . $revision;
}
}
<?php











namespace Composer\Repository\Vcs;

use Composer\Downloader\TransportException;
use Composer\Config;
use Composer\IO\IOInterface;
use Composer\Util\ProcessExecutor;
use Composer\Util\RemoteFilesystem;
use Composer\Util\Filesystem;






abstract class VcsDriver implements VcsDriverInterface
{
protected $url;
protected $originUrl;
protected $repoConfig;
protected $io;
protected $config;
protected $process;
protected $remoteFilesystem;










final public function __construct(array $repoConfig, IOInterface $io, Config $config, ProcessExecutor $process = null, RemoteFilesystem $remoteFilesystem = null)
{
if (Filesystem::isLocalPath($repoConfig['url'])) {
$repoConfig['url'] = Filesystem::getPlatformPath($repoConfig['url']);
}

$this->url = $repoConfig['url'];
$this->originUrl = $repoConfig['url'];
$this->repoConfig = $repoConfig;
$this->io = $io;
$this->config = $config;
$this->process = $process ?: new ProcessExecutor($io);
$this->remoteFilesystem = $remoteFilesystem ?: new RemoteFilesystem($io, $config);
}




public function hasComposerFile($identifier)
{
try {
return (bool) $this->getComposerInformation($identifier);
} catch (TransportException $e) {
}

return false;
}








protected function getScheme()
{
if (extension_loaded('openssl')) {
return 'https';
}

return 'http';
}








protected function getContents($url)
{
return $this->remoteFilesystem->getContents($this->originUrl, $url, false);
}




public function cleanup()
{
return;
}
}
<?php











namespace Composer\Repository\Vcs;

use Composer\Config;
use Composer\IO\IOInterface;




interface VcsDriverInterface
{



public function initialize();







public function getComposerInformation($identifier);






public function getRootIdentifier();






public function getBranches();






public function getTags();





public function getDist($identifier);





public function getSource($identifier);






public function getUrl();








public function hasComposerFile($identifier);





public function cleanup();










public static function supports(IOInterface $io, Config $config, $url, $deep = false);
}
<?php











namespace Composer\Repository;

use Composer\Downloader\TransportException;
use Composer\Repository\Vcs\VcsDriverInterface;
use Composer\Package\Version\VersionParser;
use Composer\Package\Loader\ArrayLoader;
use Composer\Package\Loader\ValidatingArrayLoader;
use Composer\Package\Loader\InvalidPackageException;
use Composer\Package\Loader\LoaderInterface;
use Composer\EventDispatcher\EventDispatcher;
use Composer\IO\IOInterface;
use Composer\Config;




class VcsRepository extends ArrayRepository
{
protected $url;
protected $packageName;
protected $verbose;
protected $io;
protected $config;
protected $versionParser;
protected $type;
protected $loader;
protected $repoConfig;
protected $branchErrorOccurred = false;

public function __construct(array $repoConfig, IOInterface $io, Config $config, EventDispatcher $dispatcher = null, array $drivers = null)
{
$this->drivers = $drivers ?: array(
'github' => 'Composer\Repository\Vcs\GitHubDriver',
'git-bitbucket' => 'Composer\Repository\Vcs\GitBitbucketDriver',
'git' => 'Composer\Repository\Vcs\GitDriver',
'hg-bitbucket' => 'Composer\Repository\Vcs\HgBitbucketDriver',
'hg' => 'Composer\Repository\Vcs\HgDriver',
'perforce' => 'Composer\Repository\Vcs\PerforceDriver',

 'svn' => 'Composer\Repository\Vcs\SvnDriver',
);

$this->url = $repoConfig['url'];
$this->io = $io;
$this->type = isset($repoConfig['type']) ? $repoConfig['type'] : 'vcs';
$this->verbose = $io->isVerbose();
$this->config = $config;
$this->repoConfig = $repoConfig;
}

public function getRepoConfig()
{
return $this->repoConfig;
}

public function setLoader(LoaderInterface $loader)
{
$this->loader = $loader;
}

public function getDriver()
{
if (isset($this->drivers[$this->type])) {
$class = $this->drivers[$this->type];
$driver = new $class($this->repoConfig, $this->io, $this->config);
$driver->initialize();

return $driver;
}

foreach ($this->drivers as $driver) {
if ($driver::supports($this->io, $this->config, $this->url)) {
$driver = new $driver($this->repoConfig, $this->io, $this->config);
$driver->initialize();

return $driver;
}
}

foreach ($this->drivers as $driver) {
if ($driver::supports($this->io, $this->config, $this->url, true)) {
$driver = new $driver($this->repoConfig, $this->io, $this->config);
$driver->initialize();

return $driver;
}
}
}

public function hadInvalidBranches()
{
return $this->branchErrorOccurred;
}

protected function initialize()
{
parent::initialize();

$verbose = $this->verbose;

$driver = $this->getDriver();
if (!$driver) {
throw new \InvalidArgumentException('No driver found to handle VCS repository '.$this->url);
}

$this->versionParser = new VersionParser;
if (!$this->loader) {
$this->loader = new ArrayLoader($this->versionParser);
}

try {
if ($driver->hasComposerFile($driver->getRootIdentifier())) {
$data = $driver->getComposerInformation($driver->getRootIdentifier());
$this->packageName = !empty($data['name']) ? $data['name'] : null;
}
} catch (\Exception $e) {
if ($verbose) {
$this->io->writeError('<error>Skipped parsing '.$driver->getRootIdentifier().', '.$e->getMessage().'</error>');
}
}

foreach ($driver->getTags() as $tag => $identifier) {
$msg = 'Reading composer.json of <info>' . ($this->packageName ?: $this->url) . '</info> (<comment>' . $tag . '</comment>)';
if ($verbose) {
$this->io->writeError($msg);
} else {
$this->io->overwriteError($msg, false);
}


 $tag = str_replace('release-', '', $tag);

if (!$parsedTag = $this->validateTag($tag)) {
if ($verbose) {
$this->io->writeError('<warning>Skipped tag '.$tag.', invalid tag name</warning>');
}
continue;
}

try {
if (!$data = $driver->getComposerInformation($identifier)) {
if ($verbose) {
$this->io->writeError('<warning>Skipped tag '.$tag.', no composer file</warning>');
}
continue;
}


 if (isset($data['version'])) {
$data['version_normalized'] = $this->versionParser->normalize($data['version']);
} else {

 $data['version'] = $tag;
$data['version_normalized'] = $parsedTag;
}


 $data['version'] = preg_replace('{[.-]?dev$}i', '', $data['version']);
$data['version_normalized'] = preg_replace('{(^dev-|[.-]?dev$)}i', '', $data['version_normalized']);


 if ($data['version_normalized'] !== $parsedTag) {
if ($verbose) {
$this->io->writeError('<warning>Skipped tag '.$tag.', tag ('.$parsedTag.') does not match version ('.$data['version_normalized'].') in composer.json</warning>');
}
continue;
}

if ($verbose) {
$this->io->writeError('Importing tag '.$tag.' ('.$data['version_normalized'].')');
}

$this->addPackage($this->loader->load($this->preProcess($driver, $data, $identifier)));
} catch (\Exception $e) {
if ($verbose) {
$this->io->writeError('<warning>Skipped tag '.$tag.', '.($e instanceof TransportException ? 'no composer file was found' : $e->getMessage()).'</warning>');
}
continue;
}
}

if (!$verbose) {
$this->io->overwriteError('', false);
}

foreach ($driver->getBranches() as $branch => $identifier) {
$msg = 'Reading composer.json of <info>' . ($this->packageName ?: $this->url) . '</info> (<comment>' . $branch . '</comment>)';
if ($verbose) {
$this->io->writeError($msg);
} else {
$this->io->overwriteError($msg, false);
}

if (!$parsedBranch = $this->validateBranch($branch)) {
if ($verbose) {
$this->io->writeError('<warning>Skipped branch '.$branch.', invalid name</warning>');
}
continue;
}

try {
if (!$data = $driver->getComposerInformation($identifier)) {
if ($verbose) {
$this->io->writeError('<warning>Skipped branch '.$branch.', no composer file</warning>');
}
continue;
}


 $data['version'] = $branch;
$data['version_normalized'] = $parsedBranch;


 if ('dev-' === substr($parsedBranch, 0, 4) || '9999999-dev' === $parsedBranch) {
$data['version'] = 'dev-' . $data['version'];
} else {
$data['version'] = preg_replace('{(\.9{7})+}', '.x', $parsedBranch);
}

if ($verbose) {
$this->io->writeError('Importing branch '.$branch.' ('.$data['version'].')');
}

$packageData = $this->preProcess($driver, $data, $identifier);
$package = $this->loader->load($packageData);
if ($this->loader instanceof ValidatingArrayLoader && $this->loader->getWarnings()) {
throw new InvalidPackageException($this->loader->getErrors(), $this->loader->getWarnings(), $packageData);
}
$this->addPackage($package);
} catch (TransportException $e) {
if ($verbose) {
$this->io->writeError('<warning>Skipped branch '.$branch.', no composer file was found</warning>');
}
continue;
} catch (\Exception $e) {
if (!$verbose) {
$this->io->writeError('');
}
$this->branchErrorOccurred = true;
$this->io->writeError('<error>Skipped branch '.$branch.', '.$e->getMessage().'</error>');
$this->io->writeError('');
continue;
}
}
$driver->cleanup();

if (!$verbose) {
$this->io->overwriteError('', false);
}

if (!$this->getPackages()) {
throw new InvalidRepositoryException('No valid composer.json was found in any branch or tag of '.$this->url.', could not load a package from it.');
}
}

protected function preProcess(VcsDriverInterface $driver, array $data, $identifier)
{

 $data['name'] = $this->packageName ?: $data['name'];

if (!isset($data['dist'])) {
$data['dist'] = $driver->getDist($identifier);
}
if (!isset($data['source'])) {
$data['source'] = $driver->getSource($identifier);
}

return $data;
}

private function validateBranch($branch)
{
try {
return $this->versionParser->normalizeBranch($branch);
} catch (\Exception $e) {
}

return false;
}

private function validateTag($version)
{
try {
return $this->versionParser->normalize($version);
} catch (\Exception $e) {
}

return false;
}
}
<?php











namespace Composer\Repository;

use Composer\Package\AliasPackage;






class WritableArrayRepository extends ArrayRepository implements WritableRepositoryInterface
{



public function write()
{
}




public function reload()
{
}




public function getCanonicalPackages()
{
$packages = $this->getPackages();


 $packagesByName = array();
foreach ($packages as $package) {
if (!isset($packagesByName[$package->getName()]) || $packagesByName[$package->getName()] instanceof AliasPackage) {
$packagesByName[$package->getName()] = $package;
}
}

$canonicalPackages = array();


 foreach ($packagesByName as $package) {
while ($package instanceof AliasPackage) {
$package = $package->getAliasOf();
}

$canonicalPackages[] = $package;
}

return $canonicalPackages;
}
}
<?php











namespace Composer\Repository;

use Composer\Package\PackageInterface;






interface WritableRepositoryInterface extends RepositoryInterface
{



public function write();






public function addPackage(PackageInterface $package);






public function removePackage(PackageInterface $package);






public function getCanonicalPackages();




public function reload();
}
<?php











namespace Composer\Script;






class CommandEvent extends Event
{
}
<?php











namespace Composer\Script;

use Composer\Composer;
use Composer\IO\IOInterface;
use Composer\EventDispatcher\Event as BaseEvent;







class Event extends BaseEvent
{



private $composer;




private $io;




private $devMode;











public function __construct($name, Composer $composer, IOInterface $io, $devMode = false, array $args = array(), array $flags = array())
{
parent::__construct($name, $args, $flags);
$this->composer = $composer;
$this->io = $io;
$this->devMode = $devMode;
}






public function getComposer()
{
return $this->composer;
}






public function getIO()
{
return $this->io;
}






public function isDevMode()
{
return $this->devMode;
}
}
<?php











namespace Composer\Script;

use Composer\Installer\PackageEvent as BasePackageEvent;






class PackageEvent extends BasePackageEvent
{
}
<?php











namespace Composer\Script;







class ScriptEvents
{







const PRE_INSTALL_CMD = 'pre-install-cmd';








const POST_INSTALL_CMD = 'post-install-cmd';








const PRE_UPDATE_CMD = 'pre-update-cmd';








const POST_UPDATE_CMD = 'post-update-cmd';








const PRE_STATUS_CMD = 'pre-status-cmd';








const POST_STATUS_CMD = 'post-status-cmd';








const PRE_AUTOLOAD_DUMP = 'pre-autoload-dump';








const POST_AUTOLOAD_DUMP = 'post-autoload-dump';








const POST_ROOT_PACKAGE_INSTALL = 'post-root-package-install';









const POST_CREATE_PROJECT_CMD = 'post-create-project-cmd';








const PRE_ARCHIVE_CMD = 'pre-archive-cmd';








const POST_ARCHIVE_CMD = 'post-archive-cmd';











const PRE_PACKAGE_INSTALL = 'pre-package-install';









const POST_PACKAGE_INSTALL = 'post-package-install';









const PRE_PACKAGE_UPDATE = 'pre-package-update';









const POST_PACKAGE_UPDATE = 'post-package-update';









const PRE_PACKAGE_UNINSTALL = 'pre-package-uninstall';









const POST_PACKAGE_UNINSTALL = 'post-package-uninstall';
}
<?php











namespace Composer\Util;

use Composer\Config;
use Composer\IO\IOInterface;




class AuthHelper
{
protected $io;
protected $config;

public function __construct(IOInterface $io, Config $config)
{
$this->io = $io;
$this->config = $config;
}

public function storeAuth($originUrl, $storeAuth)
{
$store = false;
$configSource = $this->config->getAuthConfigSource();
if ($storeAuth === true) {
$store = $configSource;
} elseif ($storeAuth === 'prompt') {
$answer = $this->io->askAndValidate(
'Do you want to store credentials for '.$originUrl.' in '.$configSource->getName().' ? [Yn] ',
function ($value) {
$input = strtolower(substr(trim($value), 0, 1));
if (in_array($input, array('y','n'))) {
return $input;
}
throw new \RuntimeException('Please answer (y)es or (n)o');
},
null,
'y'
);

if ($answer === 'y') {
$store = $configSource;
}
}
if ($store) {
$store->addConfigSetting(
'http-basic.'.$originUrl,
$this->io->getAuthentication($originUrl)
);
}
}
}
<?php











namespace Composer\Util;






class ComposerMirror
{
public static function processUrl($mirrorUrl, $packageName, $version, $reference, $type)
{
if ($reference) {
$reference = preg_match('{^([a-f0-9]*|%reference%)$}', $reference) ? $reference : md5($reference);
}
$version = strpos($version, '/') === false ? $version : md5($version);

return str_replace(
array('%package%', '%version%', '%reference%', '%type%'),
array($packageName, $version, $reference, $type),
$mirrorUrl
);
}

public static function processGitUrl($mirrorUrl, $packageName, $url, $type)
{
if (preg_match('#^(?:(?:https?|git)://github\.com/|git@github\.com:)([^/]+)/(.+?)(?:\.git)?$#', $url, $match)) {
$url = 'gh-'.$match[1].'/'.$match[2];
} elseif (preg_match('#^https://bitbucket\.org/([^/]+)/(.+?)(?:\.git)?/?$#', $url, $match)) {
$url = 'bb-'.$match[1].'/'.$match[2];
} else {
$url = preg_replace('{[^a-z0-9_.-]}i', '-', trim($url, '/'));
}

return str_replace(
array('%package%', '%normalizedUrl%', '%type%'),
array($packageName, $url, $type),
$mirrorUrl
);
}

public static function processHgUrl($mirrorUrl, $packageName, $url, $type)
{
return self::processGitUrl($mirrorUrl, $packageName, $url, $type);
}
}
<?php











namespace Composer\Util;

use Composer\Package\Loader\ArrayLoader;
use Composer\Package\Loader\ValidatingArrayLoader;
use Composer\Package\Loader\InvalidPackageException;
use Composer\Json\JsonValidationException;
use Composer\IO\IOInterface;
use Composer\Json\JsonFile;







class ConfigValidator
{
private $io;

public function __construct(IOInterface $io)
{
$this->io = $io;
}









public function validate($file, $arrayLoaderValidationFlags = ValidatingArrayLoader::CHECK_ALL)
{
$errors = array();
$publishErrors = array();
$warnings = array();


 $laxValid = false;
try {
$json = new JsonFile($file, new RemoteFilesystem($this->io));
$manifest = $json->read();

$json->validateSchema(JsonFile::LAX_SCHEMA);
$laxValid = true;
$json->validateSchema();
} catch (JsonValidationException $e) {
foreach ($e->getErrors() as $message) {
if ($laxValid) {
$publishErrors[] = $message;
} else {
$errors[] = $message;
}
}
} catch (\Exception $e) {
$errors[] = $e->getMessage();

return array($errors, $publishErrors, $warnings);
}


 if (!empty($manifest['license'])) {

 if (is_array($manifest['license'])) {
foreach ($manifest['license'] as $key => $license) {
if ('proprietary' === $license) {
unset($manifest['license'][$key]);
}
}
}

$licenseValidator = new SpdxLicense();
if ('proprietary' !== $manifest['license'] && array() !== $manifest['license'] && !$licenseValidator->validate($manifest['license'])) {
$warnings[] = sprintf(
'License %s is not a valid SPDX license identifier, see http://www.spdx.org/licenses/ if you use an open license.'
."\nIf the software is closed-source, you may use \"proprietary\" as license.",
json_encode($manifest['license'])
);
}
} else {
$warnings[] = 'No license specified, it is recommended to do so. For closed-source software you may use "proprietary" as license.';
}

if (isset($manifest['version'])) {
$warnings[] = 'The version field is present, it is recommended to leave it out if the package is published on Packagist.';
}

if (!empty($manifest['name']) && preg_match('{[A-Z]}', $manifest['name'])) {
$suggestName = preg_replace('{(?:([a-z])([A-Z])|([A-Z])([A-Z][a-z]))}', '\\1\\3-\\2\\4', $manifest['name']);
$suggestName = strtolower($suggestName);

$warnings[] = sprintf(
'Name "%s" does not match the best practice (e.g. lower-cased/with-dashes). We suggest using "%s" instead. As such you will not be able to submit it to Packagist.',
$manifest['name'],
$suggestName
);
}

if (!empty($manifest['type']) && $manifest['type'] == 'composer-installer') {
$warnings[] = "The package type 'composer-installer' is deprecated. Please distribute your custom installers as plugins from now on. See http://getcomposer.org/doc/articles/plugins.md for plugin documentation.";
}


 if (isset($manifest['require']) && isset($manifest['require-dev'])) {
$requireOverrides = array_intersect_key($manifest['require'], $manifest['require-dev']);

if (!empty($requireOverrides)) {
$plural = (count($requireOverrides) > 1) ? 'are' : 'is';
$warnings[] = implode(', ', array_keys($requireOverrides)). " {$plural} required both in require and require-dev, this can lead to unexpected behavior";
}
}

try {
$loader = new ValidatingArrayLoader(new ArrayLoader(), true, null, $arrayLoaderValidationFlags);
if (!isset($manifest['version'])) {
$manifest['version'] = '1.0.0';
}
if (!isset($manifest['name'])) {
$manifest['name'] = 'dummy/dummy';
}
$loader->load($manifest);
} catch (InvalidPackageException $e) {
$errors = array_merge($errors, $e->getErrors());
}

$warnings = array_merge($warnings, $loader->getWarnings());

return array($errors, $publishErrors, $warnings);
}
}
<?php











namespace Composer\Util;






class ErrorHandler
{











public static function handle($level, $message, $file, $line)
{

 if (!error_reporting()) {
return;
}

if (ini_get('xdebug.scream')) {
$message .= "\n\nWarning: You have xdebug.scream enabled, the warning above may be".
"\na legitimately suppressed error that you were not supposed to see.";
}

throw new \ErrorException($message, 0, $level, $file, $line);
}






public static function register()
{
set_error_handler(array(__CLASS__, 'handle'));
}
}
<?php











namespace Composer\Util;

use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use Symfony\Component\Finder\Finder;





class Filesystem
{
private $processExecutor;

public function __construct(ProcessExecutor $executor = null)
{
$this->processExecutor = $executor ?: new ProcessExecutor();
}

public function remove($file)
{
if (is_dir($file)) {
return $this->removeDirectory($file);
}

if (file_exists($file)) {
return $this->unlink($file);
}

return false;
}







public function isDirEmpty($dir)
{
$finder = Finder::create()
->ignoreVCS(false)
->ignoreDotFiles(false)
->depth(0)
->in($dir);

return count($finder) === 0;
}

public function emptyDirectory($dir, $ensureDirectoryExists = true)
{
if (file_exists($dir) && is_link($dir)) {
$this->unlink($dir);
}

if ($ensureDirectoryExists) {
$this->ensureDirectoryExists($dir);
}

if (is_dir($dir)) {
$finder = Finder::create()
->ignoreVCS(false)
->ignoreDotFiles(false)
->depth(0)
->in($dir);

foreach ($finder as $path) {
$this->remove((string) $path);
}
}
}












public function removeDirectory($directory)
{
if ($this->isSymlinkedDirectory($directory)) {
return $this->unlinkSymlinkedDirectory($directory);
}

if (!file_exists($directory) || !is_dir($directory)) {
return true;
}

if (preg_match('{^(?:[a-z]:)?[/\\\\]+$}i', $directory)) {
throw new \RuntimeException('Aborting an attempted deletion of '.$directory.', this was probably not intended, if it is a real use case please report it.');
}

if (!function_exists('proc_open')) {
return $this->removeDirectoryPhp($directory);
}

if (defined('PHP_WINDOWS_VERSION_BUILD')) {
$cmd = sprintf('rmdir /S /Q %s', ProcessExecutor::escape(realpath($directory)));
} else {
$cmd = sprintf('rm -rf %s', ProcessExecutor::escape($directory));
}

$result = $this->getProcess()->execute($cmd, $output) === 0;


 clearstatcache();

if ($result && !file_exists($directory)) {
return true;
}

return $this->removeDirectoryPhp($directory);
}











public function removeDirectoryPhp($directory)
{
$it = new RecursiveDirectoryIterator($directory, RecursiveDirectoryIterator::SKIP_DOTS);
$ri = new RecursiveIteratorIterator($it, RecursiveIteratorIterator::CHILD_FIRST);

foreach ($ri as $file) {
if ($file->isDir()) {
$this->rmdir($file->getPathname());
} else {
$this->unlink($file->getPathname());
}
}

return $this->rmdir($directory);
}

public function ensureDirectoryExists($directory)
{
if (!is_dir($directory)) {
if (file_exists($directory)) {
throw new \RuntimeException(
$directory.' exists and is not a directory.'
);
}
if (!@mkdir($directory, 0777, true)) {
throw new \RuntimeException(
$directory.' does not exist and could not be created.'
);
}
}
}









public function unlink($path)
{
if (!@$this->unlinkImplementation($path)) {

 if (!defined('PHP_WINDOWS_VERSION_BUILD') || (usleep(350000) && !@$this->unlinkImplementation($path))) {
$error = error_get_last();
$message = 'Could not delete '.$path.': ' . @$error['message'];
if (defined('PHP_WINDOWS_VERSION_BUILD')) {
$message .= "\nThis can be due to an antivirus or the Windows Search Indexer locking the file while they are analyzed";
}

throw new \RuntimeException($message);
}
}

return true;
}









public function rmdir($path)
{
if (!@rmdir($path)) {

 if (!defined('PHP_WINDOWS_VERSION_BUILD') || (usleep(350000) && !@rmdir($path))) {
$error = error_get_last();
$message = 'Could not delete '.$path.': ' . @$error['message'];
if (defined('PHP_WINDOWS_VERSION_BUILD')) {
$message .= "\nThis can be due to an antivirus or the Windows Search Indexer locking the file while they are analyzed";
}

throw new \RuntimeException($message);
}
}

return true;
}










public function copyThenRemove($source, $target)
{
if (!is_dir($source)) {
copy($source, $target);
$this->unlink($source);

return;
}

$it = new RecursiveDirectoryIterator($source, RecursiveDirectoryIterator::SKIP_DOTS);
$ri = new RecursiveIteratorIterator($it, RecursiveIteratorIterator::SELF_FIRST);
$this->ensureDirectoryExists($target);

foreach ($ri as $file) {
$targetPath = $target . DIRECTORY_SEPARATOR . $ri->getSubPathName();
if ($file->isDir()) {
$this->ensureDirectoryExists($targetPath);
} else {
copy($file->getPathname(), $targetPath);
}
}

$this->removeDirectoryPhp($source);
}

public function rename($source, $target)
{
if (true === @rename($source, $target)) {
return;
}

if (!function_exists('proc_open')) {
return $this->copyThenRemove($source, $target);
}

if (defined('PHP_WINDOWS_VERSION_BUILD')) {

 $command = sprintf('xcopy %s %s /E /I /Q', ProcessExecutor::escape($source), ProcessExecutor::escape($target));
$result = $this->processExecutor->execute($command, $output);


 clearstatcache();

if (0 === $result) {
$this->remove($source);

return;
}
} else {

 
 $command = sprintf('mv %s %s', ProcessExecutor::escape($source), ProcessExecutor::escape($target));
$result = $this->processExecutor->execute($command, $output);


 clearstatcache();

if (0 === $result) {
return;
}
}

return $this->copyThenRemove($source, $target);
}










public function findShortestPath($from, $to, $directories = false)
{
if (!$this->isAbsolutePath($from) || !$this->isAbsolutePath($to)) {
throw new \InvalidArgumentException(sprintf('$from (%s) and $to (%s) must be absolute paths.', $from, $to));
}

$from = lcfirst($this->normalizePath($from));
$to = lcfirst($this->normalizePath($to));

if ($directories) {
$from .= '/dummy_file';
}

if (dirname($from) === dirname($to)) {
return './'.basename($to);
}

$commonPath = $to;
while (strpos($from.'/', $commonPath.'/') !== 0 && '/' !== $commonPath && !preg_match('{^[a-z]:/?$}i', $commonPath)) {
$commonPath = strtr(dirname($commonPath), '\\', '/');
}

if (0 !== strpos($from, $commonPath) || '/' === $commonPath) {
return $to;
}

$commonPath = rtrim($commonPath, '/') . '/';
$sourcePathDepth = substr_count(substr($from, strlen($commonPath)), '/');
$commonPathCode = str_repeat('../', $sourcePathDepth);

return ($commonPathCode . substr($to, strlen($commonPath))) ?: './';
}










public function findShortestPathCode($from, $to, $directories = false)
{
if (!$this->isAbsolutePath($from) || !$this->isAbsolutePath($to)) {
throw new \InvalidArgumentException(sprintf('$from (%s) and $to (%s) must be absolute paths.', $from, $to));
}

$from = lcfirst($this->normalizePath($from));
$to = lcfirst($this->normalizePath($to));

if ($from === $to) {
return $directories ? '__DIR__' : '__FILE__';
}

$commonPath = $to;
while (strpos($from.'/', $commonPath.'/') !== 0 && '/' !== $commonPath && !preg_match('{^[a-z]:/?$}i', $commonPath) && '.' !== $commonPath) {
$commonPath = strtr(dirname($commonPath), '\\', '/');
}

if (0 !== strpos($from, $commonPath) || '/' === $commonPath || '.' === $commonPath) {
return var_export($to, true);
}

$commonPath = rtrim($commonPath, '/') . '/';
if (strpos($to, $from.'/') === 0) {
return '__DIR__ . '.var_export(substr($to, strlen($from)), true);
}
$sourcePathDepth = substr_count(substr($from, strlen($commonPath)), '/') + $directories;
$commonPathCode = str_repeat('dirname(', $sourcePathDepth).'__DIR__'.str_repeat(')', $sourcePathDepth);
$relTarget = substr($to, strlen($commonPath));

return $commonPathCode . (strlen($relTarget) ? '.' . var_export('/' . $relTarget, true) : '');
}







public function isAbsolutePath($path)
{
return substr($path, 0, 1) === '/' || substr($path, 1, 1) === ':';
}









public function size($path)
{
if (!file_exists($path)) {
throw new \RuntimeException("$path does not exist.");
}
if (is_dir($path)) {
return $this->directorySize($path);
}

return filesize($path);
}








public function normalizePath($path)
{
$parts = array();
$path = strtr($path, '\\', '/');
$prefix = '';
$absolute = false;

if (preg_match('{^([0-9a-z]+:(?://(?:[a-z]:)?)?)}i', $path, $match)) {
$prefix = $match[1];
$path = substr($path, strlen($prefix));
}

if (substr($path, 0, 1) === '/') {
$absolute = true;
$path = substr($path, 1);
}

$up = false;
foreach (explode('/', $path) as $chunk) {
if ('..' === $chunk && ($absolute || $up)) {
array_pop($parts);
$up = !(empty($parts) || '..' === end($parts));
} elseif ('.' !== $chunk && '' !== $chunk) {
$parts[] = $chunk;
$up = '..' !== $chunk;
}
}

return $prefix.($absolute ? '/' : '').implode('/', $parts);
}







public static function isLocalPath($path)
{
return (bool) preg_match('{^(file://|/|[a-z]:[\\\\/]|\.\.[\\\\/]|[a-z0-9_.-]+[\\\\/])}i', $path);
}

public static function getPlatformPath($path)
{
if (defined('PHP_WINDOWS_VERSION_BUILD')) {
$path = preg_replace('{^(?:file:///([a-z])/)}i', 'file://$1:/', $path);
}

return preg_replace('{^file://}i', '', $path);
}

protected function directorySize($directory)
{
$it = new RecursiveDirectoryIterator($directory, RecursiveDirectoryIterator::SKIP_DOTS);
$ri = new RecursiveIteratorIterator($it, RecursiveIteratorIterator::CHILD_FIRST);

$size = 0;
foreach ($ri as $file) {
if ($file->isFile()) {
$size += $file->getSize();
}
}

return $size;
}

protected function getProcess()
{
return new ProcessExecutor;
}










private function unlinkImplementation($path)
{
if (defined('PHP_WINDOWS_VERSION_BUILD') && is_dir($path) && is_link($path)) {
return rmdir($path);
}

return unlink($path);
}

private function isSymlinkedDirectory($directory)
{
if (!is_dir($directory)) {
return false;
}

$resolved = $this->resolveSymlinkedDirectorySymlink($directory);

return is_link($resolved);
}






private function unlinkSymlinkedDirectory($directory)
{
$resolved = $this->resolveSymlinkedDirectorySymlink($directory);

return $this->unlink($resolved);
}








private function resolveSymlinkedDirectorySymlink($pathname)
{
if (!is_dir($pathname)) {
return $pathname;
}

$resolved = rtrim($pathname, '/');

if (!strlen($resolved)) {
return $pathname;
}

return $resolved;
}
}
<?php











namespace Composer\Util;

use Composer\Config;
use Composer\IO\IOInterface;




class Git
{
protected $io;
protected $config;
protected $process;
protected $filesystem;

public function __construct(IOInterface $io, Config $config, ProcessExecutor $process, Filesystem $fs)
{
$this->io = $io;
$this->config = $config;
$this->process = $process;
$this->filesystem = $fs;
}

public function runCommand($commandCallable, $url, $cwd, $initialClone = false)
{
if ($initialClone) {
$origCwd = $cwd;
$cwd = null;
}

if (preg_match('{^ssh://[^@]+@[^:]+:[^0-9]+}', $url)) {
throw new \InvalidArgumentException('The source URL '.$url.' is invalid, ssh URLs should have a port number after ":".'."\n".'Use ssh://git@example.com:22/path or just git@example.com:path if you do not want to provide a password or custom port.');
}

if (!$initialClone) {

 $this->process->execute('git remote -v', $output, $cwd);
if (preg_match('{^(?:composer|origin)\s+https?://(.+):(.+)@([^/]+)}im', $output, $match)) {
$this->io->setAuthentication($match[3], urldecode($match[1]), urldecode($match[2]));
}
}

$protocols = $this->config->get('github-protocols');
if (!is_array($protocols)) {
throw new \RuntimeException('Config value "github-protocols" must be an array, got '.gettype($protocols));
}


 if (preg_match('{^(?:https?|git)://'.self::getGitHubDomainsRegex($this->config).'/(.*)}', $url, $match)) {
$messages = array();
foreach ($protocols as $protocol) {
if ('ssh' === $protocol) {
$url = "git@" . $match[1] . ":" . $match[2];
} else {
$url = $protocol ."://" . $match[1] . "/" . $match[2];
}

if (0 === $this->process->execute(call_user_func($commandCallable, $url), $ignoredOutput, $cwd)) {
return;
}
$messages[] = '- ' . $url . "\n" . preg_replace('#^#m', '  ', $this->process->getErrorOutput());
if ($initialClone) {
$this->filesystem->removeDirectory($origCwd);
}
}


 $this->throwException('Failed to clone ' . self::sanitizeUrl($url) .' via '.implode(', ', $protocols).' protocols, aborting.' . "\n\n" . implode("\n", $messages), $url);
}


 $bypassSshForGitHub = preg_match('{^git@'.self::getGitHubDomainsRegex($this->config).':(.+?)\.git$}i', $url) && !in_array('ssh', $protocols, true);

$command = call_user_func($commandCallable, $url);
if ($bypassSshForGitHub || 0 !== $this->process->execute($command, $ignoredOutput, $cwd)) {

 if (preg_match('{^git@'.self::getGitHubDomainsRegex($this->config).':(.+?)\.git$}i', $url, $match)) {
if (!$this->io->hasAuthentication($match[1])) {
$gitHubUtil = new GitHub($this->io, $this->config, $this->process);
$message = 'Cloning failed using an ssh key for authentication, enter your GitHub credentials to access private repos';

if (!$gitHubUtil->authorizeOAuth($match[1]) && $this->io->isInteractive()) {
$gitHubUtil->authorizeOAuthInteractively($match[1], $message);
}
}

if ($this->io->hasAuthentication($match[1])) {
$auth = $this->io->getAuthentication($match[1]);
$url = 'https://'.rawurlencode($auth['username']) . ':' . rawurlencode($auth['password']) . '@'.$match[1].'/'.$match[2].'.git';

$command = call_user_func($commandCallable, $url);
if (0 === $this->process->execute($command, $ignoredOutput, $cwd)) {
return;
}
}
} elseif ( 
 $this->isAuthenticationFailure($url, $match)
) {
if (strpos($match[2], '@')) {
list($authParts, $match[2]) = explode('@', $match[2], 2);
}

$storeAuth = false;
if ($this->io->hasAuthentication($match[2])) {
$auth = $this->io->getAuthentication($match[2]);
} elseif ($this->io->isInteractive()) {
$defaultUsername = null;
if (isset($authParts) && $authParts) {
if (false !== strpos($authParts, ':')) {
list($defaultUsername,) = explode(':', $authParts, 2);
} else {
$defaultUsername = $authParts;
}
}

$this->io->writeError('    Authentication required (<info>'.parse_url($url, PHP_URL_HOST).'</info>):');
$auth = array(
'username' => $this->io->ask('      Username: ', $defaultUsername),
'password' => $this->io->askAndHideAnswer('      Password: '),
);
$storeAuth = $this->config->get('store-auths');
}

if ($auth) {
$url = $match[1].rawurlencode($auth['username']).':'.rawurlencode($auth['password']).'@'.$match[2].$match[3];

$command = call_user_func($commandCallable, $url);
if (0 === $this->process->execute($command, $ignoredOutput, $cwd)) {
$this->io->setAuthentication($match[2], $auth['username'], $auth['password']);
$authHelper = new AuthHelper($this->io, $this->config);
$authHelper->storeAuth($match[2], $storeAuth);

return;
}
}
}

if ($initialClone) {
$this->filesystem->removeDirectory($origCwd);
}
$this->throwException('Failed to execute ' . self::sanitizeUrl($command) . "\n\n" . $this->process->getErrorOutput(), $url);
}
}

private function isAuthenticationFailure($url, &$match)
{
if (!preg_match('{(https?://)([^/]+)(.*)$}i', $url, $match)) {
return false;
}

$authFailures = array('fatal: Authentication failed', 'remote error: Invalid username or password.');
foreach ($authFailures as $authFailure) {
if (strpos($this->process->getErrorOutput(), $authFailure) !== false) {
return true;
}
}

return false;
}

public static function cleanEnv()
{
if (ini_get('safe_mode') && false === strpos(ini_get('safe_mode_allowed_env_vars'), 'GIT_ASKPASS')) {
throw new \RuntimeException('safe_mode is enabled and safe_mode_allowed_env_vars does not contain GIT_ASKPASS, can not set env var. You can disable safe_mode with "-dsafe_mode=0" when running composer');
}


 if (getenv('GIT_ASKPASS') !== 'echo') {
putenv('GIT_ASKPASS=echo');
unset($_SERVER['GIT_ASKPASS']);
}


 if (getenv('GIT_DIR')) {
putenv('GIT_DIR');
unset($_SERVER['GIT_DIR']);
}
if (getenv('GIT_WORK_TREE')) {
putenv('GIT_WORK_TREE');
unset($_SERVER['GIT_WORK_TREE']);
}


 if (getenv('LANGUAGE') !== 'C') {
putenv('LANGUAGE=C');
}


 putenv("DYLD_LIBRARY_PATH");
unset($_SERVER['DYLD_LIBRARY_PATH']);
}

public static function getGitHubDomainsRegex(Config $config)
{
return '('.implode('|', array_map('preg_quote', $config->get('github-domains'))).')';
}

public static function sanitizeUrl($message)
{
return preg_replace('{://([^@]+?):.+?@}', '://$1:***@', $message);
}

private function throwException($message, $url)
{

 clearstatcache();

if (0 !== $this->process->execute('git --version', $ignoredOutput)) {
throw new \RuntimeException('Failed to clone '.self::sanitizeUrl($url).', git was not found, check that it is installed and in your PATH env.' . "\n\n" . $this->process->getErrorOutput());
}

throw new \RuntimeException($message);
}
}
<?php











namespace Composer\Util;

use Composer\IO\IOInterface;
use Composer\Config;
use Composer\Downloader\TransportException;
use Composer\Json\JsonFile;




class GitHub
{
protected $io;
protected $config;
protected $process;
protected $remoteFilesystem;









public function __construct(IOInterface $io, Config $config, ProcessExecutor $process = null, RemoteFilesystem $remoteFilesystem = null)
{
$this->io = $io;
$this->config = $config;
$this->process = $process ?: new ProcessExecutor;
$this->remoteFilesystem = $remoteFilesystem ?: new RemoteFilesystem($io, $config);
}







public function authorizeOAuth($originUrl)
{
if (!in_array($originUrl, $this->config->get('github-domains'))) {
return false;
}


 if (0 === $this->process->execute('git config github.accesstoken', $output)) {
$this->io->setAuthentication($originUrl, trim($output), 'x-oauth-basic');

return true;
}

return false;
}










public function authorizeOAuthInteractively($originUrl, $message = null)
{
if ($message) {
$this->io->writeError($message);
}

$note = 'Composer';
if ($this->config->get('github-expose-hostname') === true && 0 === $this->process->execute('hostname', $output)) {
$note .= ' on ' . trim($output);
}
$note .= ' ' . date('Y-m-d Hi');

$url = 'https://'.$originUrl.'/settings/tokens/new?scopes=repo&description=' . str_replace('%20', '+', rawurlencode($note));
$this->io->writeError(sprintf('Head to %s', $url));
$this->io->writeError(sprintf('to retrieve a token. It will be stored in "%s" for future use by Composer.', $this->config->getAuthConfigSource()->getName()));

$token = trim($this->io->askAndHideAnswer('Token (hidden): '));

if (!$token) {
$this->io->writeError('<warning>No token given, aborting.</warning>');
$this->io->writeError('You can also add it manually later by using "composer config github-oauth.github.com <token>"');
return false;
}

$this->io->setAuthentication($originUrl, $token, 'x-oauth-basic');

try {
$apiUrl = ('github.com' === $originUrl) ? 'api.github.com' : $originUrl . '/api/v3';

$this->remoteFilesystem->getContents($originUrl, 'https://'. $apiUrl . '/rate_limit', false, array(
'retry-auth-failure' => false,
));
} catch (TransportException $e) {
if (in_array($e->getCode(), array(403, 401))) {
$this->io->writeError('<error>Invalid token provided.</error>');
$this->io->writeError('You can also add it manually later by using "composer config github-oauth.github.com <token>"');

return false;
}

throw $e;
}


 $this->config->getConfigSource()->removeConfigSetting('github-oauth.'.$originUrl);
$this->config->getAuthConfigSource()->addConfigSetting('github-oauth.'.$originUrl, $token);

$this->io->writeError('<info>Token stored successfully.</info>');

return true;
}
}
<?php











namespace Composer\Util;




class NoProxyPattern
{



protected $rules = array();




public function __construct($pattern)
{
$this->rules = preg_split("/[\s,]+/", $pattern);
}








public function test($url)
{
$host = parse_url($url, PHP_URL_HOST);
$port = parse_url($url, PHP_URL_PORT);

if (empty($port)) {
switch (parse_url($url, PHP_URL_SCHEME)) {
case 'http':
$port = 80;
break;
case 'https':
$port = 443;
break;
}
}

foreach ($this->rules as $rule) {
if ($rule == '*') {
return true;
}

$match = false;

list($ruleHost) = explode(':', $rule);
list($base) = explode('/', $ruleHost);

if (filter_var($base, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {


if (!isset($ip)) {
$ip = gethostbyname($host);
}

if (strpos($ruleHost, '/') === false) {
$match = $ip === $ruleHost;
} else {

 
 if ($ip === $host) {
$match = false;
} else {

 $match = self::inCIDRBlock($ruleHost, $ip);
}
}
} else {


$haystack = '.' . trim($host, '.') . '.';
$needle = '.'. trim($ruleHost, '.') .'.';
$match = stripos(strrev($haystack), strrev($needle)) === 0;
}


 if ($match && strpos($rule, ':') !== false) {
list(, $rulePort) = explode(':', $rule);
if (!empty($rulePort) && $port != $rulePort) {
$match = false;
}
}

if ($match) {
return true;
}
}

return false;
}











private static function inCIDRBlock($cidr, $ip)
{

 list($base, $bits) = explode('/', $cidr);


 list($a, $b, $c, $d) = explode('.', $base);


 $i = ($a << 24) + ($b << 16) + ($c << 8) + $d;
$mask = $bits == 0 ? 0 : (~0 << (32 - $bits));


 $low = $i & $mask;


 $high = $i | (~$mask & 0xFFFFFFFF);


 list($a, $b, $c, $d) = explode('.', $ip);


 $check = ($a << 24) + ($b << 16) + ($c << 8) + $d;


 
 return $check >= $low && $check <= $high;
}
}
<?php











namespace Composer\Util;

use Composer\IO\IOInterface;
use Symfony\Component\Process\Process;




class Perforce
{
protected $path;
protected $p4Depot;
protected $p4Client;
protected $p4User;
protected $p4Password;
protected $p4Port;
protected $p4Stream;
protected $p4ClientSpec;
protected $p4DepotType;
protected $p4Branch;
protected $process;
protected $uniquePerforceClientName;
protected $windowsFlag;
protected $commandResult;

protected $io;

protected $filesystem;

public function __construct($repoConfig, $port, $path, ProcessExecutor $process, $isWindows, IOInterface $io)
{
$this->windowsFlag = $isWindows;
$this->p4Port = $port;
$this->initializePath($path);
$this->process = $process;
$this->initialize($repoConfig);
$this->io = $io;
}

public static function create($repoConfig, $port, $path, ProcessExecutor $process, IOInterface $io)
{
$isWindows = defined('PHP_WINDOWS_VERSION_BUILD');
$perforce = new Perforce($repoConfig, $port, $path, $process, $isWindows, $io);

return $perforce;
}

public static function checkServerExists($url, ProcessExecutor $processExecutor)
{
$output = null;

return 0 === $processExecutor->execute('p4 -p ' . $url . ' info -s', $output);
}

public function initialize($repoConfig)
{
$this->uniquePerforceClientName = $this->generateUniquePerforceClientName();
if (null == $repoConfig) {
return;
}
if (isset($repoConfig['unique_perforce_client_name'])) {
$this->uniquePerforceClientName = $repoConfig['unique_perforce_client_name'];
}

if (isset($repoConfig['depot'])) {
$this->p4Depot = $repoConfig['depot'];
}
if (isset($repoConfig['branch'])) {
$this->p4Branch = $repoConfig['branch'];
}
if (isset($repoConfig['p4user'])) {
$this->p4User = $repoConfig['p4user'];
} else {
$this->p4User = $this->getP4variable('P4USER');
}
if (isset($repoConfig['p4password'])) {
$this->p4Password = $repoConfig['p4password'];
}
}

public function initializeDepotAndBranch($depot, $branch)
{
if (isset($depot)) {
$this->p4Depot = $depot;
}
if (isset($branch)) {
$this->p4Branch = $branch;
}
}

public function generateUniquePerforceClientName()
{
return gethostname() . "_" . time();
}

public function cleanupClientSpec()
{
$client = $this->getClient();
$task = 'client -d ' . $client;
$useP4Client = false;
$command = $this->generateP4Command($task, $useP4Client);
$this->executeCommand($command);
$clientSpec = $this->getP4ClientSpec();
$fileSystem = $this->getFilesystem();
$fileSystem->remove($clientSpec);
}

protected function executeCommand($command)
{
$this->commandResult = "";
$exit_code = $this->process->execute($command, $this->commandResult);

return $exit_code;
}

public function getClient()
{
if (!isset($this->p4Client)) {
$cleanStreamName = str_replace('@', '', str_replace('/', '_', str_replace('//', '', $this->getStream())));
$this->p4Client = 'composer_perforce_' . $this->uniquePerforceClientName . '_' . $cleanStreamName;
}

return $this->p4Client;
}

protected function getPath()
{
return $this->path;
}

public function initializePath($path)
{
$this->path = $path;
$fs = $this->getFilesystem();
$fs->ensureDirectoryExists($path);
}

protected function getPort()
{
return $this->p4Port;
}

public function setStream($stream)
{
$this->p4Stream = $stream;
$index = strrpos($stream, '/');

 if ($index > 2) {
$this->p4DepotType = 'stream';
}
}

public function isStream()
{
return (strcmp($this->p4DepotType, 'stream') === 0);
}

public function getStream()
{
if (!isset($this->p4Stream)) {
if ($this->isStream()) {
$this->p4Stream = '//' . $this->p4Depot . '/' . $this->p4Branch;
} else {
$this->p4Stream = '//' . $this->p4Depot;
}
}

return $this->p4Stream;
}

public function getStreamWithoutLabel($stream)
{
$index = strpos($stream, '@');
if ($index === false) {
return $stream;
}

return substr($stream, 0, $index);
}

public function getP4ClientSpec()
{
$p4clientSpec = $this->path . '/' . $this->getClient() . '.p4.spec';

return $p4clientSpec;
}

public function getUser()
{
return $this->p4User;
}

public function setUser($user)
{
$this->p4User = $user;
}

public function queryP4User()
{
$this->getUser();
if (strlen($this->p4User) > 0) {
return;
}
$this->p4User = $this->getP4variable('P4USER');
if (strlen($this->p4User) > 0) {
return;
}
$this->p4User = $this->io->ask('Enter P4 User:');
if ($this->windowsFlag) {
$command = 'p4 set P4USER=' . $this->p4User;
} else {
$command = 'export P4USER=' . $this->p4User;
}
$this->executeCommand($command);
}

protected function getP4variable($name)
{
if ($this->windowsFlag) {
$command = 'p4 set';
$this->executeCommand($command);
$result = trim($this->commandResult);
$resArray = explode(PHP_EOL, $result);
foreach ($resArray as $line) {
$fields = explode('=', $line);
if (strcmp($name, $fields[0]) == 0) {
$index = strpos($fields[1], ' ');
if ($index === false) {
$value = $fields[1];
} else {
$value = substr($fields[1], 0, $index);
}
$value = trim($value);

return $value;
}
}
} else {
$command = 'echo $' . $name;
$this->executeCommand($command);
$result = trim($this->commandResult);

return $result;
}
}

public function queryP4Password()
{
if (isset($this->p4Password)) {
return $this->p4Password;
}
$password = $this->getP4variable('P4PASSWD');
if (strlen($password) <= 0) {
$password = $this->io->askAndHideAnswer('Enter password for Perforce user ' . $this->getUser() . ': ');
}
$this->p4Password = $password;

return $password;
}

public function generateP4Command($command, $useClient = true)
{
$p4Command = 'p4 ';
$p4Command = $p4Command . '-u ' . $this->getUser() . ' ';
if ($useClient) {
$p4Command = $p4Command . '-c ' . $this->getClient() . ' ';
}
$p4Command = $p4Command . '-p ' . $this->getPort() . ' ';
$p4Command = $p4Command . $command;

return $p4Command;
}

public function isLoggedIn()
{
$command = $this->generateP4Command('login -s', false);
$exitCode = $this->executeCommand($command);
if ($exitCode) {
$errorOutput = $this->process->getErrorOutput();
$index = strpos($errorOutput, $this->getUser());
if ($index === false) {
$index = strpos($errorOutput, 'p4');
if ($index === false) {
return false;
}
throw new \Exception('p4 command not found in path: ' . $errorOutput);
}
throw new \Exception('Invalid user name: ' . $this->getUser() );
}

return true;
}

public function connectClient()
{
$p4CreateClientCommand = $this->generateP4Command('client -i < ' . str_replace( " ", "\\ ", $this->getP4ClientSpec() ));
$this->executeCommand($p4CreateClientCommand);
}

public function syncCodeBase($sourceReference)
{
$prevDir = getcwd();
chdir($this->path);
$p4SyncCommand = $this->generateP4Command('sync -f ');
if (null != $sourceReference) {
$p4SyncCommand = $p4SyncCommand . '@' . $sourceReference;
}
$this->executeCommand($p4SyncCommand);
chdir($prevDir);
}

public function writeClientSpecToFile($spec)
{
fwrite($spec, 'Client: ' . $this->getClient() . PHP_EOL . PHP_EOL);
fwrite($spec, 'Update: ' . date('Y/m/d H:i:s') . PHP_EOL . PHP_EOL);
fwrite($spec, 'Access: ' . date('Y/m/d H:i:s') . PHP_EOL);
fwrite($spec, 'Owner:  ' . $this->getUser() . PHP_EOL . PHP_EOL);
fwrite($spec, 'Description:' . PHP_EOL);
fwrite($spec, '  Created by ' . $this->getUser() . ' from composer.' . PHP_EOL . PHP_EOL);
fwrite($spec, 'Root: ' . $this->getPath() . PHP_EOL . PHP_EOL);
fwrite($spec, 'Options:  noallwrite noclobber nocompress unlocked modtime rmdir' . PHP_EOL . PHP_EOL);
fwrite($spec, 'SubmitOptions:  revertunchanged' . PHP_EOL . PHP_EOL);
fwrite($spec, 'LineEnd:  local' . PHP_EOL . PHP_EOL);
if ($this->isStream()) {
fwrite($spec, 'Stream:' . PHP_EOL);
fwrite($spec, '  ' . $this->getStreamWithoutLabel($this->p4Stream) . PHP_EOL);
} else {
fwrite(
$spec,
'View:  ' . $this->getStream() . '/...  //' . $this->getClient() . '/... ' . PHP_EOL
);
}
}

public function writeP4ClientSpec()
{
$clientSpec = $this->getP4ClientSpec();
$spec = fopen($clientSpec, 'w');
try {
$this->writeClientSpecToFile($spec);
} catch (\Exception $e) {
fclose($spec);
throw $e;
}
fclose($spec);
}

protected function read($pipe, $name)
{
if (feof($pipe)) {
return;
}
$line = fgets($pipe);
while ($line != false) {
$line = fgets($pipe);
}

return;
}

public function windowsLogin($password)
{
$command = $this->generateP4Command(' login -a');
$process = new Process($command, null, null, $password);

return $process->run();
}

public function p4Login()
{
$this->queryP4User();
if (!$this->isLoggedIn()) {
$password = $this->queryP4Password();
if ($this->windowsFlag) {
$this->windowsLogin($password);
} else {
$command = 'echo ' . $password . ' | ' . $this->generateP4Command(' login -a', false);
$exitCode = $this->executeCommand($command);
$result = trim($this->commandResult);
if ($exitCode) {
throw new \Exception("Error logging in:" . $this->process->getErrorOutput());
}
}
}
}

public function getComposerInformation($identifier)
{
$index = strpos($identifier, '@');
if ($index === false) {
$composerJson = $identifier. '/composer.json';

return $this->getComposerInformationFromPath($composerJson);
}

return $this->getComposerInformationFromLabel($identifier, $index);
}

public function getComposerInformationFromPath($composerJson)
{
$command = $this->generateP4Command(' print ' . $composerJson);
$this->executeCommand($command);
$result = $this->commandResult;
$index = strpos($result, '{');
if ($index === false) {
return '';
}
if ($index >= 0) {
$rawData = substr($result, $index);
$composer_info = json_decode($rawData, true);

return $composer_info;
}

return '';
}

public function getComposerInformationFromLabel($identifier, $index)
{
$composerJsonPath = substr($identifier, 0, $index) . '/composer.json' . substr($identifier, $index);
$command = $this->generateP4Command(' files ' . $composerJsonPath, false);
$this->executeCommand($command);
$result = $this->commandResult;
$index2 = strpos($result, 'no such file(s).');
if ($index2 === false) {
$index3 = strpos($result, 'change');
if (!($index3 === false)) {
$phrase = trim(substr($result, $index3));
$fields = explode(' ', $phrase);
$id = $fields[1];
$composerJson = substr($identifier, 0, $index) . '/composer.json@' . $id;

return $this->getComposerInformationFromPath($composerJson);
}
}

return "";
}

public function getBranches()
{
$possibleBranches = array();
if (!$this->isStream()) {
$possibleBranches[$this->p4Branch] = $this->getStream();
} else {
$command = $this->generateP4Command('streams //' . $this->p4Depot . '/...');
$this->executeCommand($command);
$result = $this->commandResult;
$resArray = explode(PHP_EOL, $result);
foreach ($resArray as $line) {
$resBits = explode(' ', $line);
if (count($resBits) > 4) {
$branch = preg_replace('/[^A-Za-z0-9 ]/', '', $resBits[4]);
$possibleBranches[$branch] = $resBits[1];
}
}
}
$command = $this->generateP4Command('changes '. $this->getStream() . '/...', false);
$this->executeCommand($command);
$result = $this->commandResult;
$resArray = explode(PHP_EOL, $result);
$lastCommit = $resArray[0];
$lastCommitArr = explode(' ', $lastCommit);
$lastCommitNum = $lastCommitArr[1];

$branches = array('master' => $possibleBranches[$this->p4Branch] . '@'. $lastCommitNum);

return $branches;
}

public function getTags()
{
$command = $this->generateP4Command('labels');
$this->executeCommand($command);
$result = $this->commandResult;
$resArray = explode(PHP_EOL, $result);
$tags = array();
foreach ($resArray as $line) {
$index = strpos($line, 'Label');
if (!($index === false)) {
$fields = explode(' ', $line);
$tags[$fields[1]] = $this->getStream() . '@' . $fields[1];
}
}

return $tags;
}

public function checkStream()
{
$command = $this->generateP4Command('depots', false);
$this->executeCommand($command);
$result = $this->commandResult;
$resArray = explode(PHP_EOL, $result);
foreach ($resArray as $line) {
$index = strpos($line, 'Depot');
if (!($index === false)) {
$fields = explode(' ', $line);
if (strcmp($this->p4Depot, $fields[1]) === 0) {
$this->p4DepotType = $fields[3];

return $this->isStream();
}
}
}

return false;
}

protected function getChangeList($reference)
{
$index = strpos($reference, '@');
if ($index === false) {
return;
}
$label = substr($reference, $index);
$command = $this->generateP4Command(' changes -m1 ' . $label);
$this->executeCommand($command);
$changes = $this->commandResult;
if (strpos($changes, 'Change') !== 0) {
return;
}
$fields = explode(' ', $changes);
$changeList = $fields[1];

return $changeList;
}

public function getCommitLogs($fromReference, $toReference)
{
$fromChangeList = $this->getChangeList($fromReference);
if ($fromChangeList == null) {
return;
}
$toChangeList = $this->getChangeList($toReference);
if ($toChangeList == null) {
return;
}
$index = strpos($fromReference, '@');
$main = substr($fromReference, 0, $index) . '/...';
$command = $this->generateP4Command('filelog ' . $main . '@' . $fromChangeList. ',' . $toChangeList);
$this->executeCommand($command);
$result = $this->commandResult;

return $result;
}

public function getFilesystem()
{
if (empty($this->filesystem)) {
$this->filesystem = new Filesystem($this->process);
}

return $this->filesystem;
}

public function setFilesystem(Filesystem $fs)
{
$this->filesystem = $fs;
}
}
<?php











namespace Composer\Util;

use Symfony\Component\Process\Process;
use Symfony\Component\Process\ProcessUtils;
use Composer\IO\IOInterface;




class ProcessExecutor
{
protected static $timeout = 300;

protected $captureOutput;
protected $errorOutput;
protected $io;

public function __construct(IOInterface $io = null)
{
$this->io = $io;
}










public function execute($command, &$output = null, $cwd = null)
{
if ($this->io && $this->io->isDebug()) {
$safeCommand = preg_replace('{(://[^:/\s]+:)[^@\s/]+}i', '$1****', $command);
$this->io->writeError('Executing command ('.($cwd ?: 'CWD').'): '.$safeCommand);
}


 
 if (null === $cwd && defined('PHP_WINDOWS_VERSION_BUILD') && false !== strpos($command, 'git') && getcwd()) {
$cwd = realpath(getcwd());
}

$this->captureOutput = count(func_get_args()) > 1;
$this->errorOutput = null;
$process = new Process($command, $cwd, null, null, static::getTimeout());

$callback = is_callable($output) ? $output : array($this, 'outputHandler');
$process->run($callback);

if ($this->captureOutput && !is_callable($output)) {
$output = $process->getOutput();
}

$this->errorOutput = $process->getErrorOutput();

return $process->getExitCode();
}

public function splitLines($output)
{
$output = trim($output);

return ((string) $output === '') ? array() : preg_split('{\r?\n}', $output);
}






public function getErrorOutput()
{
return $this->errorOutput;
}

public function outputHandler($type, $buffer)
{
if ($this->captureOutput) {
return;
}

echo $buffer;
}

public static function getTimeout()
{
return static::$timeout;
}

public static function setTimeout($timeout)
{
static::$timeout = $timeout;
}









public static function escape($argument)
{
return ProcessUtils::escapeArgument($argument);
}
}
<?php











namespace Composer\Util;

use Composer\Composer;
use Composer\Config;
use Composer\IO\IOInterface;
use Composer\Downloader\TransportException;






class RemoteFilesystem
{
private $io;
private $config;
private $bytesMax;
private $originUrl;
private $fileUrl;
private $fileName;
private $retry;
private $progress;
private $lastProgress;
private $options;
private $retryAuthFailure;
private $lastHeaders;
private $storeAuth;








public function __construct(IOInterface $io, Config $config = null, array $options = array())
{
$this->io = $io;
$this->config = $config;
$this->options = $options;
}












public function copy($originUrl, $fileUrl, $fileName, $progress = true, $options = array())
{
return $this->get($originUrl, $fileUrl, $options, $fileName, $progress);
}











public function getContents($originUrl, $fileUrl, $progress = true, $options = array())
{
return $this->get($originUrl, $fileUrl, $options, null, $progress);
}






public function getOptions()
{
return $this->options;
}






public function getLastHeaders()
{
return $this->lastHeaders;
}















protected function get($originUrl, $fileUrl, $additionalOptions = array(), $fileName = null, $progress = true)
{
if (strpos($originUrl, '.github.com') === (strlen($originUrl) - 11)) {
$originUrl = 'github.com';
}

$this->bytesMax = 0;
$this->originUrl = $originUrl;
$this->fileUrl = $fileUrl;
$this->fileName = $fileName;
$this->progress = $progress;
$this->lastProgress = null;
$this->retryAuthFailure = true;
$this->lastHeaders = array();


 if (preg_match('{^https?://(.+):(.+)@([^/]+)}i', $fileUrl, $match)) {
$this->io->setAuthentication($originUrl, urldecode($match[1]), urldecode($match[2]));
}

if (isset($additionalOptions['retry-auth-failure'])) {
$this->retryAuthFailure = (bool) $additionalOptions['retry-auth-failure'];

unset($additionalOptions['retry-auth-failure']);
}

$options = $this->getOptionsForUrl($originUrl, $additionalOptions);

if ($this->io->isDebug()) {
$this->io->writeError((substr($fileUrl, 0, 4) === 'http' ? 'Downloading ' : 'Reading ') . $fileUrl);
}
if (isset($options['github-token'])) {
$fileUrl .= (false === strpos($fileUrl, '?') ? '?' : '&') . 'access_token='.$options['github-token'];
unset($options['github-token']);
}
if (isset($options['http'])) {
$options['http']['ignore_errors'] = true;
}
$ctx = StreamContextFactory::getContext($fileUrl, $options, array('notification' => array($this, 'callbackGet')));

if ($this->progress) {
$this->io->writeError("    Downloading: <comment>Connecting...</comment>", false);
}

$errorMessage = '';
$errorCode = 0;
$result = false;
set_error_handler(function ($code, $msg) use (&$errorMessage) {
if ($errorMessage) {
$errorMessage .= "\n";
}
$errorMessage .= preg_replace('{^file_get_contents\(.*?\): }', '', $msg);
});
try {
$result = file_get_contents($fileUrl, false, $ctx);
} catch (\Exception $e) {
if ($e instanceof TransportException && !empty($http_response_header[0])) {
$e->setHeaders($http_response_header);
}
if ($e instanceof TransportException && $result !== false) {
$e->setResponse($result);
}
$result = false;
}
if ($errorMessage && !ini_get('allow_url_fopen')) {
$errorMessage = 'allow_url_fopen must be enabled in php.ini ('.$errorMessage.')';
}
restore_error_handler();
if (isset($e) && !$this->retry) {
throw $e;
}


 if (!empty($http_response_header[0]) && preg_match('{^HTTP/\S+ ([45]\d\d)}i', $http_response_header[0], $match)) {
$errorCode = $match[1];
if (!$this->retry) {
$e = new TransportException('The "'.$this->fileUrl.'" file could not be downloaded ('.$http_response_header[0].')', $errorCode);
$e->setHeaders($http_response_header);
$e->setResponse($result);
throw $e;
}
$result = false;
}


 if ($result && extension_loaded('zlib') && substr($fileUrl, 0, 4) === 'http') {
$decode = false;
foreach ($http_response_header as $header) {
if (preg_match('{^content-encoding: *gzip *$}i', $header)) {
$decode = true;
continue;
} elseif (preg_match('{^HTTP/}i', $header)) {
$decode = false;
}
}

if ($decode) {
if (PHP_VERSION_ID >= 50400) {
$result = zlib_decode($result);
} else {

 $result = file_get_contents('compress.zlib://data:application/octet-stream;base64,'.base64_encode($result));
}

if (!$result) {
throw new TransportException('Failed to decode zlib stream');
}
}
}

if ($this->progress && !$this->retry) {
$this->io->overwriteError("    Downloading: <comment>100%</comment>");
}


 if (false !== $result && null !== $fileName) {
if ('' === $result) {
throw new TransportException('"'.$this->fileUrl.'" appears broken, and returned an empty 200 response');
}

$errorMessage = '';
set_error_handler(function ($code, $msg) use (&$errorMessage) {
if ($errorMessage) {
$errorMessage .= "\n";
}
$errorMessage .= preg_replace('{^file_put_contents\(.*?\): }', '', $msg);
});
$result = (bool) file_put_contents($fileName, $result);
restore_error_handler();
if (false === $result) {
throw new TransportException('The "'.$this->fileUrl.'" file could not be written to '.$fileName.': '.$errorMessage);
}
}

if ($this->retry) {
$this->retry = false;

$result = $this->get($this->originUrl, $this->fileUrl, $additionalOptions, $this->fileName, $this->progress);

$authHelper = new AuthHelper($this->io, $this->config);
$authHelper->storeAuth($this->originUrl, $this->storeAuth);
$this->storeAuth = false;

return $result;
}

if (false === $result) {
$e = new TransportException('The "'.$this->fileUrl.'" file could not be downloaded: '.$errorMessage, $errorCode);
if (!empty($http_response_header[0])) {
$e->setHeaders($http_response_header);
}

throw $e;
}

if (!empty($http_response_header[0])) {
$this->lastHeaders = $http_response_header;
}

return $result;
}












protected function callbackGet($notificationCode, $severity, $message, $messageCode, $bytesTransferred, $bytesMax)
{
switch ($notificationCode) {
case STREAM_NOTIFY_FAILURE:
case STREAM_NOTIFY_AUTH_REQUIRED:
if (401 === $messageCode) {

 if (!$this->retryAuthFailure) {
break;
}

$this->promptAuthAndRetry($messageCode);
break;
}
break;

case STREAM_NOTIFY_AUTH_RESULT:
if (403 === $messageCode) {

 if (!$this->retryAuthFailure) {
break;
}

$this->promptAuthAndRetry($messageCode, $message);
break;
}
break;

case STREAM_NOTIFY_FILE_SIZE_IS:
if ($this->bytesMax < $bytesMax) {
$this->bytesMax = $bytesMax;
}
break;

case STREAM_NOTIFY_PROGRESS:
if ($this->bytesMax > 0 && $this->progress) {
$progression = 0;

if ($this->bytesMax > 0) {
$progression = round($bytesTransferred / $this->bytesMax * 100);
}

if ((0 === $progression % 5) && 100 !== $progression && $progression !== $this->lastProgress) {
$this->lastProgress = $progression;
$this->io->overwriteError("    Downloading: <comment>$progression%</comment>", false);
}
}
break;

default:
break;
}
}

protected function promptAuthAndRetry($httpStatus, $reason = null)
{
if ($this->config && in_array($this->originUrl, $this->config->get('github-domains'), true)) {
$message = "\n".'Could not fetch '.$this->fileUrl.', please create a GitHub OAuth token '.($httpStatus === 404 ? 'to access private repos' : 'to go over the API rate limit');
$gitHubUtil = new GitHub($this->io, $this->config, null);
if (!$gitHubUtil->authorizeOAuth($this->originUrl)
&& (!$this->io->isInteractive() || !$gitHubUtil->authorizeOAuthInteractively($this->originUrl, $message))
) {
throw new TransportException('Could not authenticate against '.$this->originUrl, 401);
}
} else {

 if ($httpStatus === 404) {
return;
}


 if (!$this->io->isInteractive()) {
if ($httpStatus === 401) {
$message = "The '" . $this->fileUrl . "' URL required authentication.\nYou must be using the interactive console to authenticate";
}
if ($httpStatus === 403) {
$message = "The '" . $this->fileUrl . "' URL could not be accessed: " . $reason;
}

throw new TransportException($message, $httpStatus);
}

 if ($this->io->hasAuthentication($this->originUrl)) {
throw new TransportException("Invalid credentials for '" . $this->fileUrl . "', aborting.", $httpStatus);
}

$this->io->overwriteError('    Authentication required (<info>'.parse_url($this->fileUrl, PHP_URL_HOST).'</info>):');
$username = $this->io->ask('      Username: ');
$password = $this->io->askAndHideAnswer('      Password: ');
$this->io->setAuthentication($this->originUrl, $username, $password);
$this->storeAuth = $this->config->get('store-auths');
}

$this->retry = true;
throw new TransportException('RETRY');
}

protected function getOptionsForUrl($originUrl, $additionalOptions)
{
if (defined('HHVM_VERSION')) {
$phpVersion = 'HHVM ' . HHVM_VERSION;
} else {
$phpVersion = 'PHP ' . PHP_MAJOR_VERSION . '.' . PHP_MINOR_VERSION . '.' . PHP_RELEASE_VERSION;
}

$headers = array(
sprintf(
'User-Agent: Composer/%s (%s; %s; %s)',
Composer::VERSION === '@package_version@' ? 'source' : Composer::VERSION,
php_uname('s'),
php_uname('r'),
$phpVersion
)
);

if (extension_loaded('zlib')) {
$headers[] = 'Accept-Encoding: gzip';
}

$options = array_replace_recursive($this->options, $additionalOptions);
$options['http']['protocol_version'] = 1.1;
$headers[] = 'Connection: close';

if ($this->io->hasAuthentication($originUrl)) {
$auth = $this->io->getAuthentication($originUrl);
if ('github.com' === $originUrl && 'x-oauth-basic' === $auth['password']) {
$options['github-token'] = $auth['username'];
} else {
$authStr = base64_encode($auth['username'] . ':' . $auth['password']);
$headers[] = 'Authorization: Basic '.$authStr;
}
}

if (isset($options['http']['header']) && !is_array($options['http']['header'])) {
$options['http']['header'] = explode("\r\n", trim($options['http']['header'], "\r\n"));
}
foreach ($headers as $header) {
$options['http']['header'][] = $header;
}

return $options;
}
}
<?php











namespace Composer\Util;

use Composer\Json\JsonFile;







class SpdxLicense
{



private $licenses;

public function __construct()
{
$this->loadLicenses();
}

private function loadLicenses()
{
if (is_array($this->licenses)) {
return $this->licenses;
}

$jsonFile = new JsonFile(__DIR__ . '/../../../res/spdx-licenses.json');
$this->licenses = $jsonFile->read();

return $this->licenses;
}








public function getLicenseByIdentifier($identifier)
{
if (!isset($this->licenses[$identifier])) {
return;
}

$license = $this->licenses[$identifier];


 $license[2] = 'http://spdx.org/licenses/' . $identifier . '#licenseText';

return $license;
}








public function getIdentifierByName($name)
{
foreach ($this->licenses as $identifier => $licenseData) {
if ($licenseData[0] === $name) { 
 return $identifier;
}
}
}






public function isOsiApprovedByIdentifier($identifier)
{
return $this->licenses[$identifier][1]; 
 }








private function isValidLicenseIdentifier($identifier)
{
$identifiers = array_keys($this->licenses);

return in_array($identifier, $identifiers);
}







public function validate($license)
{
if (is_array($license)) {
$count = count($license);
if ($count !== count(array_filter($license, 'is_string'))) {
throw new \InvalidArgumentException('Array of strings expected.');
}
$license = $count > 1 ? '('.implode(' or ', $license).')' : (string) reset($license);
}

if (!is_string($license)) {
throw new \InvalidArgumentException(sprintf(
'Array or String expected, %s given.', gettype($license)
));
}

return $this->isValidLicenseString($license);
}







private function isValidLicenseString($license)
{
$tokens = array(
'po' => '\(',
'pc' => '\)',
'op' => '(?:or|and)',
'lix' => '(?:NONE|NOASSERTION)',
'lir' => 'LicenseRef-\d+',
'lic' => '[-+_.a-zA-Z0-9]{3,}',
'ws' => '\s+',
'_' => '.',
);

$next = function () use ($license, $tokens) {
static $offset = 0;

if ($offset >= strlen($license)) {
return null;
}

foreach ($tokens as $name => $token) {
if (false === $r = preg_match('{' . $token . '}', $license, $matches, PREG_OFFSET_CAPTURE, $offset)) {
throw new \RuntimeException('Pattern for token %s failed (regex error).', $name);
}
if ($r === 0) {
continue;
}
if ($matches[0][1] !== $offset) {
continue;
}
$offset += strlen($matches[0][0]);

return array($name, $matches[0][0]);
}

throw new \RuntimeException('At least the last pattern needs to match, but it did not (dot-match-all is missing?).');
};

$open = 0;
$require = 1;
$lastop = null;

while (list($token, $string) = $next()) {
switch ($token) {
case 'po':
if ($open || !$require) {
return false;
}
$open = 1;
break;
case 'pc':
if ($open !== 1 || $require || !$lastop) {
return false;
}
$open = 2;
break;
case 'op':
if ($require || !$open) {
return false;
}
$lastop || $lastop = $string;
if ($lastop !== $string) {
return false;
}
$require = 1;
break;
case 'lix':
if ($open) {
return false;
}
goto lir;
case 'lic':
if (!$this->isValidLicenseIdentifier($string)) {
return false;
}

 case 'lir':
lir:
if (!$require) {
return false;
}
$require = 0;
break;
case 'ws':
break;
case '_':
return false;
default:
throw new \RuntimeException(sprintf('Unparsed token: %s.', print_r($token, true)));
}
}

return !($open % 2 || $require);
}
}
<?php











namespace Composer\Util;

use Composer\Json\JsonFormatter;







class SpdxLicensesUpdater
{
private $licensesUrl = 'http://www.spdx.org/licenses/';

public function update()
{
$json = json_encode($this->getLicenses(), true);
$prettyJson = JsonFormatter::format($json, true, true);
file_put_contents(__DIR__ . '/../../../res/spdx-licenses.json', $prettyJson);
}

private function getLicenses()
{
$licenses = array();

$dom = new \DOMDocument;
$dom->loadHTMLFile($this->licensesUrl);

$xPath = new \DOMXPath($dom);
$trs = $xPath->query('//table//tbody//tr');


 foreach ($trs as $tr) {
$tds = $tr->getElementsByTagName('td'); 

if ($tds->length < 4) {
throw new \Exception('Obtaining the license table failed. Wrong table format. Found less than 4 cells in a row.');
}

if (trim($tds->item(3)->nodeValue) == 'License Text') {
$fullname = trim($tds->item(0)->nodeValue);
$identifier = trim($tds->item(1)->nodeValue);
$osiApproved = ((isset($tds->item(2)->nodeValue) && $tds->item(2)->nodeValue === 'Y')) ? true : false;


 
 

$licenses += array($identifier => array($fullname, $osiApproved));
}
}

return $licenses;
}
}
<?php











namespace Composer\Util;







final class StreamContextFactory
{









public static function getContext($url, array $defaultOptions = array(), array $defaultParams = array())
{
$options = array('http' => array(

 'follow_location' => 1,
'max_redirects' => 20,
));


 if (!empty($_SERVER['HTTP_PROXY']) || !empty($_SERVER['http_proxy'])) {

 $proxy = parse_url(!empty($_SERVER['http_proxy']) ? $_SERVER['http_proxy'] : $_SERVER['HTTP_PROXY']);
}


 if (preg_match('{^https://}i', $url) && (!empty($_SERVER['HTTPS_PROXY']) || !empty($_SERVER['https_proxy']))) {
$proxy = parse_url(!empty($_SERVER['https_proxy']) ? $_SERVER['https_proxy'] : $_SERVER['HTTPS_PROXY']);
}


 if (!empty($_SERVER['no_proxy']) && parse_url($url, PHP_URL_HOST)) {
$pattern = new NoProxyPattern($_SERVER['no_proxy']);
if ($pattern->test($url)) {
unset($proxy);
}
}

if (!empty($proxy)) {
$proxyURL = isset($proxy['scheme']) ? $proxy['scheme'] . '://' : '';
$proxyURL .= isset($proxy['host']) ? $proxy['host'] : '';

if (isset($proxy['port'])) {
$proxyURL .= ":" . $proxy['port'];
} elseif ('http://' == substr($proxyURL, 0, 7)) {
$proxyURL .= ":80";
} elseif ('https://' == substr($proxyURL, 0, 8)) {
$proxyURL .= ":443";
}


 $proxyURL = str_replace(array('http://', 'https://'), array('tcp://', 'ssl://'), $proxyURL);

if (0 === strpos($proxyURL, 'ssl:') && !extension_loaded('openssl')) {
throw new \RuntimeException('You must enable the openssl extension to use a proxy over https');
}

$options['http']['proxy'] = $proxyURL;


 switch (parse_url($url, PHP_URL_SCHEME)) {
case 'http': 
 $reqFullUriEnv = getenv('HTTP_PROXY_REQUEST_FULLURI');
if ($reqFullUriEnv === false || $reqFullUriEnv === '' || (strtolower($reqFullUriEnv) !== 'false' && (bool) $reqFullUriEnv)) {
$options['http']['request_fulluri'] = true;
}
break;
case 'https': 
 $reqFullUriEnv = getenv('HTTPS_PROXY_REQUEST_FULLURI');
if ($reqFullUriEnv === false || $reqFullUriEnv === '' || (strtolower($reqFullUriEnv) !== 'false' && (bool) $reqFullUriEnv)) {
$options['http']['request_fulluri'] = true;
}
break;
}


 if ('https' === parse_url($url, PHP_URL_SCHEME)) {
$options['ssl']['SNI_enabled'] = true;
if (PHP_VERSION_ID < 50600) {
$options['ssl']['SNI_server_name'] = parse_url($url, PHP_URL_HOST);
}
}


 if (isset($proxy['user'])) {
$auth = urldecode($proxy['user']);
if (isset($proxy['pass'])) {
$auth .= ':' . urldecode($proxy['pass']);
}
$auth = base64_encode($auth);


 if (isset($defaultOptions['http']['header'])) {
if (is_string($defaultOptions['http']['header'])) {
$defaultOptions['http']['header'] = array($defaultOptions['http']['header']);
}
$defaultOptions['http']['header'][] = "Proxy-Authorization: Basic {$auth}";
} else {
$options['http']['header'] = array("Proxy-Authorization: Basic {$auth}");
}
}
}

$options = array_replace_recursive($options, $defaultOptions);

if (isset($options['http']['header'])) {
$options['http']['header'] = self::fixHttpHeaderField($options['http']['header']);
}

return stream_context_create($options, $defaultParams);
}











private static function fixHttpHeaderField($header)
{
if (!is_array($header)) {
$header = explode("\r\n", $header);
}
uasort($header, function ($el) {
return preg_match('{^content-type}i', $el) ? 1 : -1;
});

return $header;
}
}
<?php











namespace Composer\Util;

use Composer\Config;
use Composer\IO\IOInterface;





class Svn
{
const MAX_QTY_AUTH_TRIES = 5;




protected $credentials;




protected $hasAuth;




protected $io;




protected $url;




protected $cacheCredentials = true;




protected $process;




protected $qtyAuthTries = 0;




protected $config;







public function __construct($url, IOInterface $io, Config $config, ProcessExecutor $process = null)
{
$this->url = $url;
$this->io = $io;
$this->config = $config;
$this->process = $process ?: new ProcessExecutor;
}

public static function cleanEnv()
{

 putenv("DYLD_LIBRARY_PATH");
unset($_SERVER['DYLD_LIBRARY_PATH']);
}















public function execute($command, $url, $cwd = null, $path = null, $verbose = false)
{
$svnCommand = $this->getCommand($command, $url, $path);
$output = null;
$io = $this->io;
$handler = function ($type, $buffer) use (&$output, $io, $verbose) {
if ($type !== 'out') {
return;
}
if ('Redirecting to URL ' === substr($buffer, 0, 19)) {
return;
}
$output .= $buffer;
if ($verbose) {
$io->writeError($buffer, false);
}
};
$status = $this->process->execute($svnCommand, $handler, $cwd);
if (0 === $status) {
return $output;
}

$errorOutput = $this->process->getErrorOutput();
$fullOutput = implode("\n", array($output, $errorOutput));


 if (false === stripos($fullOutput, 'Could not authenticate to server:')
&& false === stripos($fullOutput, 'authorization failed')
&& false === stripos($fullOutput, 'svn: E170001:')
&& false === stripos($fullOutput, 'svn: E215004:')) {
throw new \RuntimeException($fullOutput);
}

if (!$this->hasAuth()) {
$this->doAuthDance();
}


 if ($this->qtyAuthTries++ < self::MAX_QTY_AUTH_TRIES) {

 return $this->execute($command, $url, $cwd, $path, $verbose);
}

throw new \RuntimeException(
'wrong credentials provided ('.$fullOutput.')'
);
}




public function setCacheCredentials($cacheCredentials)
{
$this->cacheCredentials = $cacheCredentials;
}







protected function doAuthDance()
{

 if (!$this->io->isInteractive()) {
throw new \RuntimeException(
'can not ask for authentication in non interactive mode'
);
}

$this->io->writeError("The Subversion server ({$this->url}) requested credentials:");

$this->hasAuth = true;
$this->credentials['username'] = $this->io->ask("Username: ");
$this->credentials['password'] = $this->io->askAndHideAnswer("Password: ");

$this->cacheCredentials = $this->io->askConfirmation("Should Subversion cache these credentials? (yes/no) ", true);

return $this;
}










protected function getCommand($cmd, $url, $path = null)
{
$cmd = sprintf('%s %s%s %s',
$cmd,
'--non-interactive ',
$this->getCredentialString(),
ProcessExecutor::escape($url)
);

if ($path) {
$cmd .= ' ' . ProcessExecutor::escape($path);
}

return $cmd;
}








protected function getCredentialString()
{
if (!$this->hasAuth()) {
return '';
}

return sprintf(
' %s--username %s --password %s ',
$this->getAuthCache(),
ProcessExecutor::escape($this->getUsername()),
ProcessExecutor::escape($this->getPassword())
);
}







protected function getPassword()
{
if ($this->credentials === null) {
throw new \LogicException("No svn auth detected.");
}

return isset($this->credentials['password']) ? $this->credentials['password'] : '';
}







protected function getUsername()
{
if ($this->credentials === null) {
throw new \LogicException("No svn auth detected.");
}

return $this->credentials['username'];
}






protected function hasAuth()
{
if (null !== $this->hasAuth) {
return $this->hasAuth;
}

if (false === $this->createAuthFromConfig()) {
$this->createAuthFromUrl();
}

return $this->hasAuth;
}






protected function getAuthCache()
{
return $this->cacheCredentials ? '' : '--no-auth-cache ';
}






private function createAuthFromConfig()
{
if (!$this->config->has('http-basic')) {
return $this->hasAuth = false;
}

$authConfig = $this->config->get('http-basic');

$host = parse_url($this->url, PHP_URL_HOST);
if (isset($authConfig[$host])) {
$this->credentials['username'] = $authConfig[$host]['username'];
$this->credentials['password'] = $authConfig[$host]['password'];

return $this->hasAuth = true;
}

return $this->hasAuth = false;
}






private function createAuthFromUrl()
{
$uri = parse_url($this->url);
if (empty($uri['user'])) {
return $this->hasAuth = false;
}

$this->credentials['username'] = $uri['user'];
if (!empty($uri['pass'])) {
$this->credentials['password'] = $uri['pass'];
}

return $this->hasAuth = true;
}
}
<?php











function includeIfExists($file)
{
return file_exists($file) ? include $file : false;
}

if ((!$loader = includeIfExists(__DIR__.'/../vendor/autoload.php')) && (!$loader = includeIfExists(__DIR__.'/../../../autoload.php'))) {
echo 'You must set up the project dependencies, run the following commands:'.PHP_EOL.
'curl -sS https://getcomposer.org/installer | php'.PHP_EOL.
'php composer.phar install'.PHP_EOL;
exit(1);
}

return $loader;
<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer\Autoload;

/**
 * ClassLoader implements a PSR-0 class loader
 *
 * See https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md
 *
 *     $loader = new \Composer\Autoload\ClassLoader();
 *
 *     // register classes with namespaces
 *     $loader->add('Symfony\Component', __DIR__.'/component');
 *     $loader->add('Symfony',           __DIR__.'/framework');
 *
 *     // activate the autoloader
 *     $loader->register();
 *
 *     // to enable searching the include path (eg. for PEAR packages)
 *     $loader->setUseIncludePath(true);
 *
 * In this example, if you try to use a class in the Symfony\Component
 * namespace or one of its children (Symfony\Component\Console for instance),
 * the autoloader will first look for the class under the component/
 * directory, and it will then fallback to the framework/ directory if not
 * found before giving up.
 *
 * This class is loosely based on the Symfony UniversalClassLoader.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Jordi Boggiano <j.boggiano@seld.be>
 */
class ClassLoader
{
    // PSR-4
    private $prefixLengthsPsr4 = array();
    private $prefixDirsPsr4 = array();
    private $fallbackDirsPsr4 = array();

    // PSR-0
    private $prefixesPsr0 = array();
    private $fallbackDirsPsr0 = array();

    private $useIncludePath = false;
    private $classMap = array();

    private $classMapAuthoritative = false;

    public function getPrefixes()
    {
        if (!empty($this->prefixesPsr0)) {
            return call_user_func_array('array_merge', $this->prefixesPsr0);
        }

        return array();
    }

    public function getPrefixesPsr4()
    {
        return $this->prefixDirsPsr4;
    }

    public function getFallbackDirs()
    {
        return $this->fallbackDirsPsr0;
    }

    public function getFallbackDirsPsr4()
    {
        return $this->fallbackDirsPsr4;
    }

    public function getClassMap()
    {
        return $this->classMap;
    }

    /**
     * @param array $classMap Class to filename map
     */
    public function addClassMap(array $classMap)
    {
        if ($this->classMap) {
            $this->classMap = array_merge($this->classMap, $classMap);
        } else {
            $this->classMap = $classMap;
        }
    }

    /**
     * Registers a set of PSR-0 directories for a given prefix, either
     * appending or prepending to the ones previously set for this prefix.
     *
     * @param string       $prefix  The prefix
     * @param array|string $paths   The PSR-0 root directories
     * @param bool         $prepend Whether to prepend the directories
     */
    public function add($prefix, $paths, $prepend = false)
    {
        if (!$prefix) {
            if ($prepend) {
                $this->fallbackDirsPsr0 = array_merge(
                    (array) $paths,
                    $this->fallbackDirsPsr0
                );
            } else {
                $this->fallbackDirsPsr0 = array_merge(
                    $this->fallbackDirsPsr0,
                    (array) $paths
                );
            }

            return;
        }

        $first = $prefix[0];
        if (!isset($this->prefixesPsr0[$first][$prefix])) {
            $this->prefixesPsr0[$first][$prefix] = (array) $paths;

            return;
        }
        if ($prepend) {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                (array) $paths,
                $this->prefixesPsr0[$first][$prefix]
            );
        } else {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                $this->prefixesPsr0[$first][$prefix],
                (array) $paths
            );
        }
    }

    /**
     * Registers a set of PSR-4 directories for a given namespace, either
     * appending or prepending to the ones previously set for this namespace.
     *
     * @param string       $prefix  The prefix/namespace, with trailing '\\'
     * @param array|string $paths   The PSR-0 base directories
     * @param bool         $prepend Whether to prepend the directories
     *
     * @throws \InvalidArgumentException
     */
    public function addPsr4($prefix, $paths, $prepend = false)
    {
        if (!$prefix) {
            // Register directories for the root namespace.
            if ($prepend) {
                $this->fallbackDirsPsr4 = array_merge(
                    (array) $paths,
                    $this->fallbackDirsPsr4
                );
            } else {
                $this->fallbackDirsPsr4 = array_merge(
                    $this->fallbackDirsPsr4,
                    (array) $paths
                );
            }
        } elseif (!isset($this->prefixDirsPsr4[$prefix])) {
            // Register directories for a new namespace.
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = (array) $paths;
        } elseif ($prepend) {
            // Prepend directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                (array) $paths,
                $this->prefixDirsPsr4[$prefix]
            );
        } else {
            // Append directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                $this->prefixDirsPsr4[$prefix],
                (array) $paths
            );
        }
    }

    /**
     * Registers a set of PSR-0 directories for a given prefix,
     * replacing any others previously set for this prefix.
     *
     * @param string       $prefix The prefix
     * @param array|string $paths  The PSR-0 base directories
     */
    public function set($prefix, $paths)
    {
        if (!$prefix) {
            $this->fallbackDirsPsr0 = (array) $paths;
        } else {
            $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;
        }
    }

    /**
     * Registers a set of PSR-4 directories for a given namespace,
     * replacing any others previously set for this namespace.
     *
     * @param string       $prefix The prefix/namespace, with trailing '\\'
     * @param array|string $paths  The PSR-4 base directories
     *
     * @throws \InvalidArgumentException
     */
    public function setPsr4($prefix, $paths)
    {
        if (!$prefix) {
            $this->fallbackDirsPsr4 = (array) $paths;
        } else {
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = (array) $paths;
        }
    }

    /**
     * Turns on searching the include path for class files.
     *
     * @param bool $useIncludePath
     */
    public function setUseIncludePath($useIncludePath)
    {
        $this->useIncludePath = $useIncludePath;
    }

    /**
     * Can be used to check if the autoloader uses the include path to check
     * for classes.
     *
     * @return bool
     */
    public function getUseIncludePath()
    {
        return $this->useIncludePath;
    }

    /**
     * Turns off searching the prefix and fallback directories for classes
     * that have not been registered with the class map.
     *
     * @param bool $classMapAuthoritative
     */
    public function setClassMapAuthoritative($classMapAuthoritative)
    {
        $this->classMapAuthoritative = $classMapAuthoritative;
    }

    /**
     * Should class lookup fail if not found in the current class map?
     *
     * @return bool
     */
    public function isClassMapAuthoritative()
    {
        return $this->classMapAuthoritative;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    /**
     * Unregisters this instance as an autoloader.
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }

    /**
     * Loads the given class or interface.
     *
     * @param  string    $class The name of the class
     * @return bool|null True if loaded, null otherwise
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            includeFile($file);

            return true;
        }
    }

    /**
     * Finds the path to the file where the class is defined.
     *
     * @param string $class The name of the class
     *
     * @return string|false The path if found, false otherwise
     */
    public function findFile($class)
    {
        // work around for PHP 5.3.0 - 5.3.2 https://bugs.php.net/50731
        if ('\\' == $class[0]) {
            $class = substr($class, 1);
        }

        // class map lookup
        if (isset($this->classMap[$class])) {
            return $this->classMap[$class];
        }
        if ($this->classMapAuthoritative) {
            return false;
        }

        $file = $this->findFileWithExtension($class, '.php');

        // Search for Hack files if we are running on HHVM
        if ($file === null && defined('HHVM_VERSION')) {
            $file = $this->findFileWithExtension($class, '.hh');
        }

        if ($file === null) {
            // Remember that this class does not exist.
            return $this->classMap[$class] = false;
        }

        return $file;
    }

    private function findFileWithExtension($class, $ext)
    {
        // PSR-4 lookup
        $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;

        $first = $class[0];
        if (isset($this->prefixLengthsPsr4[$first])) {
            foreach ($this->prefixLengthsPsr4[$first] as $prefix => $length) {
                if (0 === strpos($class, $prefix)) {
                    foreach ($this->prefixDirsPsr4[$prefix] as $dir) {
                        if (is_file($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-4 fallback dirs
        foreach ($this->fallbackDirsPsr4 as $dir) {
            if (is_file($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
                return $file;
            }
        }

        // PSR-0 lookup
        if (false !== $pos = strrpos($class, '\\')) {
            // namespaced class name
            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
                . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
        } else {
            // PEAR-like class name
            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
        }

        if (isset($this->prefixesPsr0[$first])) {
            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
                if (0 === strpos($class, $prefix)) {
                    foreach ($dirs as $dir) {
                        if (is_file($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-0 fallback dirs
        foreach ($this->fallbackDirsPsr0 as $dir) {
            if (is_file($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                return $file;
            }
        }

        // PSR-0 include paths.
        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
            return $file;
        }
    }
}

/**
 * Scope isolated include.
 *
 * Prevents access to $this/self from included files.
 */
function includeFile($file)
{
    include $file;
}
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "name": "Package",
    "type": "object",
    "additionalProperties": false,
    "required": [ "name", "description" ],
    "properties": {
        "name": {
            "type": "string",
            "description": "Package name, including 'vendor-name/' prefix."
        },
        "type": {
            "description": "Package type, either 'library' for common packages, 'composer-plugin' for plugins, 'metapackage' for empty packages, or a custom type ([a-z0-9-]+) defined by whatever project this package applies to.",
            "type": "string"
        },
        "target-dir": {
            "description": "DEPRECATED: Forces the package to be installed into the given subdirectory path. This is used for autoloading PSR-0 packages that do not contain their full path. Use forward slashes for cross-platform compatibility.",
            "type": "string"
        },
        "description": {
            "type": "string",
            "description": "Short package description."
        },
        "keywords": {
            "type": "array",
            "items": {
                "type": "string",
                "description": "A tag/keyword that this package relates to."
            }
        },
        "homepage": {
            "type": "string",
            "description": "Homepage URL for the project.",
            "format": "uri"
        },
        "version": {
            "type": "string",
            "description": "Package version, see https://getcomposer.org/doc/04-schema.md#version for more info on valid schemes."
        },
        "time": {
            "type": "string",
            "description": "Package release date, in 'YYYY-MM-DD', 'YYYY-MM-DD HH:MM:SS' or 'YYYY-MM-DDTHH:MM:SSZ' format."
        },
        "license": {
            "type": ["string", "array"],
            "description": "License name. Or an array of license names."
        },
        "authors": {
            "type": "array",
            "description": "List of authors that contributed to the package. This is typically the main maintainers, not the full list.",
            "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [ "name"],
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Full name of the author."
                    },
                    "email": {
                        "type": "string",
                        "description": "Email address of the author.",
                        "format": "email"
                    },
                    "homepage": {
                        "type": "string",
                        "description": "Homepage URL for the author.",
                        "format": "uri"
                    },
                    "role": {
                        "type": "string",
                        "description": "Author's role in the project."
                    }
                }
            }
        },
        "require": {
            "type": "object",
            "description": "This is a hash of package name (keys) and version constraints (values) that are required to run this package.",
            "additionalProperties": true
        },
        "replace": {
            "type": "object",
            "description": "This is a hash of package name (keys) and version constraints (values) that can be replaced by this package.",
            "additionalProperties": true
        },
        "conflict": {
            "type": "object",
            "description": "This is a hash of package name (keys) and version constraints (values) that conflict with this package.",
            "additionalProperties": true
        },
        "provide": {
            "type": "object",
            "description": "This is a hash of package name (keys) and version constraints (values) that this package provides in addition to this package's name.",
            "additionalProperties": true
        },
        "require-dev": {
            "type": "object",
            "description": "This is a hash of package name (keys) and version constraints (values) that this package requires for developing it (testing tools and such).",
            "additionalProperties": true
        },
        "suggest": {
            "type": "object",
            "description": "This is a hash of package name (keys) and descriptions (values) that this package suggests work well with it (this will be suggested to the user during installation).",
            "additionalProperties": true
        },
        "config": {
            "type": "object",
            "description": "Composer options.",
            "properties": {
                "process-timeout": {
                    "type": "integer",
                    "description": "The timeout in seconds for process executions, defaults to 300 (5mins)."
                },
                "use-include-path": {
                    "type": "boolean",
                    "description": "If true, the Composer autoloader will also look for classes in the PHP include path."
                },
                "preferred-install": {
                    "type": "string",
                    "description": "The install method Composer will prefer to use, defaults to auto and can be any of source, dist or auto."
                },
                "notify-on-install": {
                    "type": "boolean",
                    "description": "Composer allows repositories to define a notification URL, so that they get notified whenever a package from that repository is installed. This option allows you to disable that behaviour, defaults to true."
                },
                "github-protocols": {
                    "type": "array",
                    "description": "A list of protocols to use for github.com clones, in priority order, defaults to [\"git\", \"https\", \"http\"].",
                    "items": {
                        "type": "string"
                    }
                },
                "github-oauth": {
                    "type": "object",
                    "description": "A hash of domain name => github API oauth tokens, typically {\"github.com\":\"<token>\"}.",
                    "additionalProperties": true
                },
                "http-basic": {
                    "type": "object",
                    "description": "A hash of domain name => {\"username\": \"...\", \"password\": \"...\"}.",
                    "additionalProperties": true
                },
                "store-auths": {
                    "type": ["string", "boolean"],
                    "description": "What to do after prompting for authentication, one of: true (store), false (do not store) or \"prompt\" (ask every time), defaults to prompt."
                },
                "platform": {
                    "type": "object",
                    "description": "This is a hash of package name (keys) and version (values) that will be used to mock the platform packages on this machine.",
                    "additionalProperties": true
                },
                "vendor-dir": {
                    "type": "string",
                    "description": "The location where all packages are installed, defaults to \"vendor\"."
                },
                "bin-dir": {
                    "type": "string",
                    "description": "The location where all binaries are linked, defaults to \"vendor/bin\"."
                },
                "cache-dir": {
                    "type": "string",
                    "description": "The location where all caches are located, defaults to \"~/.composer/cache\" on *nix and \"%LOCALAPPDATA%\\Composer\" on windows."
                },
                "cache-files-dir": {
                    "type": "string",
                    "description": "The location where files (zip downloads) are cached, defaults to \"{$cache-dir}/files\"."
                },
                "cache-repo-dir": {
                    "type": "string",
                    "description": "The location where repo (git/hg repo clones) are cached, defaults to \"{$cache-dir}/repo\"."
                },
                "cache-vcs-dir": {
                    "type": "string",
                    "description": "The location where vcs infos (git clones, github api calls, etc. when reading vcs repos) are cached, defaults to \"{$cache-dir}/vcs\"."
                },
                "cache-ttl": {
                    "type": "integer",
                    "description": "The default cache time-to-live, defaults to 15552000 (6 months)."
                },
                "cache-files-ttl": {
                    "type": "integer",
                    "description": "The cache time-to-live for files, defaults to the value of cache-ttl."
                },
                "cache-files-maxsize": {
                    "type": ["string", "integer"],
                    "description": "The cache max size for the files cache, defaults to \"300MiB\"."
                },
                "discard-changes": {
                    "type": ["string", "boolean"],
                    "description": "The default style of handling dirty updates, defaults to false and can be any of true, false or \"stash\"."
                },
                "autoloader-suffix": {
                    "type": "string",
                    "description": "Optional string to be used as a suffix for the generated Composer autoloader. When null a random one will be generated."
                },
                "optimize-autoloader": {
                    "type": "boolean",
                    "description": "Always optimize when dumping the autoloader."
                },
                "prepend-autoloader": {
                    "type": "boolean",
                    "description": "If false, the composer autoloader will not be prepended to existing autoloaders, defaults to true."
                },
                "classmap-authoritative": {
                    "type": "boolean",
                    "description": "If true, the composer autoloader will not scan the filesystem for classes that are not found in the class map, defaults to false."
                },
                "github-domains": {
                    "type": "array",
                    "description": "A list of domains to use in github mode. This is used for GitHub Enterprise setups, defaults to [\"github.com\"].",
                    "items": {
                        "type": "string"
                    }
                },
                "github-expose-hostname": {
                    "type": "boolean",
                    "description": "Defaults to true. If set to false, the OAuth tokens created to access the github API will have a date instead of the machine hostname."
                }
            }
        },
        "extra": {
            "type": ["object", "array"],
            "description": "Arbitrary extra data that can be used by plugins, for example, package of type composer-plugin may have a 'class' key defining an installer class name.",
            "additionalProperties": true
        },
        "autoload": {
            "type": "object",
            "description": "Description of how the package can be autoloaded.",
            "properties": {
                "psr-0": {
                    "type": "object",
                    "description": "This is a hash of namespaces (keys) and the directories they can be found into (values, can be arrays of paths) by the autoloader.",
                    "additionalProperties": true
                },
                "psr-4": {
                    "type": "object",
                    "description": "This is a hash of namespaces (keys) and the PSR-4 directories they can map to (values, can be arrays of paths) by the autoloader.",
                    "additionalProperties": true
                },
                "classmap": {
                    "type": "array",
                    "description": "This is an array of directories that contain classes to be included in the class-map generation process."
                },
                "files": {
                    "type": "array",
                    "description": "This is an array of files that are always required on every request."
                }
            }
        },
        "autoload-dev": {
            "type": "object",
            "description": "Description of additional autoload rules for development purpose (eg. a test suite).",
            "properties": {
                "psr-0": {
                    "type": "object",
                    "description": "This is a hash of namespaces (keys) and the directories they can be found into (values, can be arrays of paths) by the autoloader.",
                    "additionalProperties": true
                },
                "psr-4": {
                    "type": "object",
                    "description": "This is a hash of namespaces (keys) and the PSR-4 directories they can map to (values, can be arrays of paths) by the autoloader.",
                    "additionalProperties": true
                },
                "classmap": {
                    "type": "array",
                    "description": "This is an array of directories that contain classes to be included in the class-map generation process."
                },
                "files": {
                    "type": "array",
                    "description": "This is an array of files that are always required on every request."
                }
            }
        },
        "archive": {
            "type": ["object"],
            "description": "Options for creating package archives for distribution.",
            "properties": {
                "exclude": {
                    "type": "array",
                    "description": "A list of patterns for paths to exclude or include if prefixed with an exclamation mark."
                }
            }
        },
        "repositories": {
            "type": ["object", "array"],
            "description": "A set of additional repositories where packages can be found.",
            "additionalProperties": true
        },
        "minimum-stability": {
            "type": ["string"],
            "description": "The minimum stability the packages must have to be install-able. Possible values are: dev, alpha, beta, RC, stable.",
            "pattern": "^dev|alpha|beta|rc|RC|stable$"
        },
        "prefer-stable": {
            "type": ["boolean"],
            "description": "If set to true, stable packages will be preferred to dev packages when possible, even if the minimum-stability allows unstable packages."
        },
        "bin": {
            "type": ["array"],
            "description": "A set of files that should be treated as binaries and symlinked into bin-dir (from config).",
            "items": {
                "type": "string"
            }
        },
        "include-path": {
            "type": ["array"],
            "description": "DEPRECATED: A list of directories which should get added to PHP's include path. This is only present to support legacy projects, and all new code should preferably use autoloading.",
            "items": {
                "type": "string"
            }
        },
        "scripts": {
            "type": ["object"],
            "description": "Scripts listeners that will be executed before/after some events.",
            "properties": {
                "pre-install-cmd": {
                    "type": ["array", "string"],
                    "description": "Occurs before the install command is executed, contains one or more Class::method callables or shell commands."
                },
                "post-install-cmd": {
                    "type": ["array", "string"],
                    "description": "Occurs after the install command is executed, contains one or more Class::method callables or shell commands."
                },
                "pre-update-cmd": {
                    "type": ["array", "string"],
                    "description": "Occurs before the update command is executed, contains one or more Class::method callables or shell commands."
                },
                "post-update-cmd": {
                    "type": ["array", "string"],
                    "description": "Occurs after the update command is executed, contains one or more Class::method callables or shell commands."
                },
                "pre-status-cmd": {
                    "type": ["array", "string"],
                    "description": "Occurs before the status command is executed, contains one or more Class::method callables or shell commands."
                },
                "post-status-cmd": {
                    "type": ["array", "string"],
                    "description": "Occurs after the status command is executed, contains one or more Class::method callables or shell commands."
                },
                "pre-package-install": {
                    "type": ["array", "string"],
                    "description": "Occurs before a package is installed, contains one or more Class::method callables or shell commands."
                },
                "post-package-install": {
                    "type": ["array", "string"],
                    "description": "Occurs after a package is installed, contains one or more Class::method callables or shell commands."
                },
                "pre-package-update": {
                    "type": ["array", "string"],
                    "description": "Occurs before a package is updated, contains one or more Class::method callables or shell commands."
                },
                "post-package-update": {
                    "type": ["array", "string"],
                    "description": "Occurs after a package is updated, contains one or more Class::method callables or shell commands."
                },
                "pre-package-uninstall": {
                    "type": ["array", "string"],
                    "description": "Occurs before a package has been uninstalled, contains one or more Class::method callables or shell commands."
                },
                "post-package-uninstall": {
                    "type": ["array", "string"],
                    "description": "Occurs after a package has been uninstalled, contains one or more Class::method callables or shell commands."
                },
                "pre-autoload-dump": {
                    "type": ["array", "string"],
                    "description": "Occurs before the autoloader is dumped, contains one or more Class::method callables or shell commands."
                },
                "post-autoload-dump": {
                    "type": ["array", "string"],
                    "description": "Occurs after the autoloader is dumped, contains one or more Class::method callables or shell commands."
                },
                "post-root-package-install": {
                    "type": ["array", "string"],
                    "description": "Occurs after the root-package is installed, contains one or more Class::method callables or shell commands."
                },
                "post-create-project-cmd": {
                    "type": ["array", "string"],
                    "description": "Occurs after the create-project command is executed, contains one or more Class::method callables or shell commands."
                }
            }
        },
        "support": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string",
                    "description": "Email address for support.",
                    "format": "email"
                },
                "issues": {
                    "type": "string",
                    "description": "URL to the issue tracker.",
                    "format": "uri"
                },
                "forum": {
                    "type": "string",
                    "description": "URL to the forum.",
                    "format": "uri"
                },
                "wiki": {
                    "type": "string",
                    "description": "URL to the wiki.",
                    "format": "uri"
                },
                "irc": {
                    "type": "string",
                    "description": "IRC channel for support, as irc://server/channel.",
                    "format": "uri"
                },
                "source": {
                    "type": "string",
                    "description": "URL to browse or download the sources.",
                    "format": "uri"
                },
                "docs": {
                    "type": "string",
                    "description": "URL to the documentation.",
                    "format": "uri"
                }
            }
        },
        "non-feature-branches": {
            "type": ["array"],
            "description": "A set of string or regex patterns for non-numeric branch names that will not be handled as feature branches.",
            "items": {
                "type": "string"
            }
        }
    }
}
{
    "Glide": [
        "3dfx Glide License",
        false
    ],
    "Abstyles": [
        "Abstyles License",
        false
    ],
    "AFL-1.1": [
        "Academic Free License v1.1",
        true
    ],
    "AFL-1.2": [
        "Academic Free License v1.2",
        true
    ],
    "AFL-2.0": [
        "Academic Free License v2.0",
        true
    ],
    "AFL-2.1": [
        "Academic Free License v2.1",
        true
    ],
    "AFL-3.0": [
        "Academic Free License v3.0",
        true
    ],
    "AMPAS": [
        "Academy of Motion Picture Arts and Sciences BSD",
        false
    ],
    "APL-1.0": [
        "Adaptive Public License 1.0",
        true
    ],
    "Adobe-Glyph": [
        "Adobe Glyph List License",
        false
    ],
    "APAFML": [
        "Adobe Postscript AFM License",
        false
    ],
    "Adobe-2006": [
        "Adobe Systems Incorporated Source Code License Agreement",
        false
    ],
    "AGPL-1.0": [
        "Affero General Public License v1.0",
        false
    ],
    "Afmparse": [
        "Afmparse License",
        false
    ],
    "Aladdin": [
        "Aladdin Free Public License",
        false
    ],
    "ADSL": [
        "Amazon Digital Services License",
        false
    ],
    "AMDPLPA": [
        "AMD's plpa_map.c License",
        false
    ],
    "ANTLR-PD": [
        "ANTLR Software Rights Notice",
        false
    ],
    "Apache-1.0": [
        "Apache License 1.0",
        false
    ],
    "Apache-1.1": [
        "Apache License 1.1",
        true
    ],
    "Apache-2.0": [
        "Apache License 2.0",
        true
    ],
    "AML": [
        "Apple MIT License",
        false
    ],
    "APSL-1.0": [
        "Apple Public Source License 1.0",
        true
    ],
    "APSL-1.1": [
        "Apple Public Source License 1.1",
        true
    ],
    "APSL-1.2": [
        "Apple Public Source License 1.2",
        true
    ],
    "APSL-2.0": [
        "Apple Public Source License 2.0",
        true
    ],
    "Artistic-1.0": [
        "Artistic License 1.0",
        true
    ],
    "Artistic-1.0-Perl": [
        "Artistic License 1.0 (Perl)",
        true
    ],
    "Artistic-1.0-cl8": [
        "Artistic License 1.0 w/clause 8",
        true
    ],
    "Artistic-2.0": [
        "Artistic License 2.0",
        true
    ],
    "AAL": [
        "Attribution Assurance License",
        true
    ],
    "Bahyph": [
        "Bahyph License",
        false
    ],
    "Barr": [
        "Barr License",
        false
    ],
    "Beerware": [
        "Beerware License",
        false
    ],
    "BitTorrent-1.0": [
        "BitTorrent Open Source License v1.0",
        false
    ],
    "BitTorrent-1.1": [
        "BitTorrent Open Source License v1.1",
        false
    ],
    "BSL-1.0": [
        "Boost Software License 1.0",
        true
    ],
    "Borceux": [
        "Borceux license",
        false
    ],
    "BSD-2-Clause": [
        "BSD 2-clause \"Simplified\" License",
        true
    ],
    "BSD-2-Clause-FreeBSD": [
        "BSD 2-clause FreeBSD License",
        false
    ],
    "BSD-2-Clause-NetBSD": [
        "BSD 2-clause NetBSD License",
        false
    ],
    "BSD-3-Clause": [
        "BSD 3-clause \"New\" or \"Revised\" License",
        true
    ],
    "BSD-3-Clause-Clear": [
        "BSD 3-clause Clear License",
        false
    ],
    "BSD-4-Clause": [
        "BSD 4-clause \"Original\" or \"Old\" License",
        false
    ],
    "BSD-Protection": [
        "BSD Protection License",
        false
    ],
    "BSD-3-Clause-Attribution": [
        "BSD with attribution",
        false
    ],
    "BSD-4-Clause-UC": [
        "BSD-4-Clause (University of California-Specific)",
        false
    ],
    "bzip2-1.0.5": [
        "bzip2 and libbzip2 License v1.0.5",
        false
    ],
    "bzip2-1.0.6": [
        "bzip2 and libbzip2 License v1.0.6",
        false
    ],
    "Caldera": [
        "Caldera License",
        false
    ],
    "CECILL-1.0": [
        "CeCILL Free Software License Agreement v1.0",
        false
    ],
    "CECILL-1.1": [
        "CeCILL Free Software License Agreement v1.1",
        false
    ],
    "CECILL-2.0": [
        "CeCILL Free Software License Agreement v2.0",
        false
    ],
    "CECILL-B": [
        "CeCILL-B Free Software License Agreement",
        false
    ],
    "CECILL-C": [
        "CeCILL-C Free Software License Agreement",
        false
    ],
    "ClArtistic": [
        "Clarified Artistic License",
        false
    ],
    "MIT-CMU": [
        "CMU License",
        false
    ],
    "CNRI-Python": [
        "CNRI Python License",
        true
    ],
    "CNRI-Python-GPL-Compatible": [
        "CNRI Python Open Source GPL Compatible License Agreement",
        false
    ],
    "CPOL-1.02": [
        "Code Project Open License 1.02",
        false
    ],
    "CDDL-1.0": [
        "Common Development and Distribution License 1.0",
        true
    ],
    "CDDL-1.1": [
        "Common Development and Distribution License 1.1",
        false
    ],
    "CPAL-1.0": [
        "Common Public Attribution License 1.0",
        true
    ],
    "CPL-1.0": [
        "Common Public License 1.0",
        true
    ],
    "CATOSL-1.1": [
        "Computer Associates Trusted Open Source License 1.1",
        true
    ],
    "Condor-1.1": [
        "Condor Public License v1.1",
        false
    ],
    "CC-BY-1.0": [
        "Creative Commons Attribution 1.0",
        false
    ],
    "CC-BY-2.0": [
        "Creative Commons Attribution 2.0",
        false
    ],
    "CC-BY-2.5": [
        "Creative Commons Attribution 2.5",
        false
    ],
    "CC-BY-3.0": [
        "Creative Commons Attribution 3.0",
        false
    ],
    "CC-BY-4.0": [
        "Creative Commons Attribution 4.0",
        false
    ],
    "CC-BY-ND-1.0": [
        "Creative Commons Attribution No Derivatives 1.0",
        false
    ],
    "CC-BY-ND-2.0": [
        "Creative Commons Attribution No Derivatives 2.0",
        false
    ],
    "CC-BY-ND-2.5": [
        "Creative Commons Attribution No Derivatives 2.5",
        false
    ],
    "CC-BY-ND-3.0": [
        "Creative Commons Attribution No Derivatives 3.0",
        false
    ],
    "CC-BY-ND-4.0": [
        "Creative Commons Attribution No Derivatives 4.0",
        false
    ],
    "CC-BY-NC-1.0": [
        "Creative Commons Attribution Non Commercial 1.0",
        false
    ],
    "CC-BY-NC-2.0": [
        "Creative Commons Attribution Non Commercial 2.0",
        false
    ],
    "CC-BY-NC-2.5": [
        "Creative Commons Attribution Non Commercial 2.5",
        false
    ],
    "CC-BY-NC-3.0": [
        "Creative Commons Attribution Non Commercial 3.0",
        false
    ],
    "CC-BY-NC-4.0": [
        "Creative Commons Attribution Non Commercial 4.0",
        false
    ],
    "CC-BY-NC-ND-1.0": [
        "Creative Commons Attribution Non Commercial No Derivatives 1.0",
        false
    ],
    "CC-BY-NC-ND-2.0": [
        "Creative Commons Attribution Non Commercial No Derivatives 2.0",
        false
    ],
    "CC-BY-NC-ND-2.5": [
        "Creative Commons Attribution Non Commercial No Derivatives 2.5",
        false
    ],
    "CC-BY-NC-ND-3.0": [
        "Creative Commons Attribution Non Commercial No Derivatives 3.0",
        false
    ],
    "CC-BY-NC-ND-4.0": [
        "Creative Commons Attribution Non Commercial No Derivatives 4.0",
        false
    ],
    "CC-BY-NC-SA-1.0": [
        "Creative Commons Attribution Non Commercial Share Alike 1.0",
        false
    ],
    "CC-BY-NC-SA-2.0": [
        "Creative Commons Attribution Non Commercial Share Alike 2.0",
        false
    ],
    "CC-BY-NC-SA-2.5": [
        "Creative Commons Attribution Non Commercial Share Alike 2.5",
        false
    ],
    "CC-BY-NC-SA-3.0": [
        "Creative Commons Attribution Non Commercial Share Alike 3.0",
        false
    ],
    "CC-BY-NC-SA-4.0": [
        "Creative Commons Attribution Non Commercial Share Alike 4.0",
        false
    ],
    "CC-BY-SA-1.0": [
        "Creative Commons Attribution Share Alike 1.0",
        false
    ],
    "CC-BY-SA-2.0": [
        "Creative Commons Attribution Share Alike 2.0",
        false
    ],
    "CC-BY-SA-2.5": [
        "Creative Commons Attribution Share Alike 2.5",
        false
    ],
    "CC-BY-SA-3.0": [
        "Creative Commons Attribution Share Alike 3.0",
        false
    ],
    "CC-BY-SA-4.0": [
        "Creative Commons Attribution Share Alike 4.0",
        false
    ],
    "CC0-1.0": [
        "Creative Commons Zero v1.0 Universal",
        false
    ],
    "Crossword": [
        "Crossword License",
        false
    ],
    "CUA-OPL-1.0": [
        "CUA Office Public License v1.0",
        true
    ],
    "Cube": [
        "Cube License",
        false
    ],
    "D-FSL-1.0": [
        "Deutsche Freie Software Lizenz",
        false
    ],
    "diffmark": [
        "diffmark license",
        false
    ],
    "WTFPL": [
        "Do What The F*ck You Want To Public License",
        false
    ],
    "DOC": [
        "DOC License",
        false
    ],
    "Dotseqn": [
        "Dotseqn License",
        false
    ],
    "DSDP": [
        "DSDP License",
        false
    ],
    "dvipdfm": [
        "dvipdfm License",
        false
    ],
    "EPL-1.0": [
        "Eclipse Public License 1.0",
        true
    ],
    "eCos-2.0": [
        "eCos license version 2.0",
        false
    ],
    "ECL-1.0": [
        "Educational Community License v1.0",
        true
    ],
    "ECL-2.0": [
        "Educational Community License v2.0",
        true
    ],
    "eGenix": [
        "eGenix.com Public License 1.1.0",
        false
    ],
    "EFL-1.0": [
        "Eiffel Forum License v1.0",
        true
    ],
    "EFL-2.0": [
        "Eiffel Forum License v2.0",
        true
    ],
    "MIT-advertising": [
        "Enlightenment License (e16)",
        false
    ],
    "MIT-enna": [
        "enna License",
        false
    ],
    "Entessa": [
        "Entessa Public License v1.0",
        true
    ],
    "ErlPL-1.1": [
        "Erlang Public License v1.1",
        false
    ],
    "EUDatagrid": [
        "EU DataGrid Software License",
        true
    ],
    "EUPL-1.0": [
        "European Union Public License 1.0",
        false
    ],
    "EUPL-1.1": [
        "European Union Public License 1.1",
        true
    ],
    "Eurosym": [
        "Eurosym License",
        false
    ],
    "Fair": [
        "Fair License",
        true
    ],
    "MIT-feh": [
        "feh License",
        false
    ],
    "Frameworx-1.0": [
        "Frameworx Open License 1.0",
        true
    ],
    "FTL": [
        "Freetype Project License",
        false
    ],
    "FSFUL": [
        "FSF Unlimited License",
        false
    ],
    "FSFULLR": [
        "FSF Unlimited License (with License Retention)",
        false
    ],
    "Giftware": [
        "Giftware License",
        false
    ],
    "GL2PS": [
        "GL2PS License",
        false
    ],
    "Glulxe": [
        "Glulxe License",
        false
    ],
    "AGPL-3.0": [
        "GNU Affero General Public License v3.0",
        true
    ],
    "GFDL-1.1": [
        "GNU Free Documentation License v1.1",
        false
    ],
    "GFDL-1.2": [
        "GNU Free Documentation License v1.2",
        false
    ],
    "GFDL-1.3": [
        "GNU Free Documentation License v1.3",
        false
    ],
    "GPL-1.0": [
        "GNU General Public License v1.0 only",
        false
    ],
    "GPL-1.0+": [
        "GNU General Public License v1.0 or later",
        false
    ],
    "GPL-2.0": [
        "GNU General Public License v2.0 only",
        true
    ],
    "GPL-2.0+": [
        "GNU General Public License v2.0 or later",
        true
    ],
    "GPL-2.0-with-autoconf-exception": [
        "GNU General Public License v2.0 w/Autoconf exception",
        true
    ],
    "GPL-2.0-with-bison-exception": [
        "GNU General Public License v2.0 w/Bison exception",
        true
    ],
    "GPL-2.0-with-classpath-exception": [
        "GNU General Public License v2.0 w/Classpath exception",
        true
    ],
    "GPL-2.0-with-font-exception": [
        "GNU General Public License v2.0 w/Font exception",
        true
    ],
    "GPL-2.0-with-GCC-exception": [
        "GNU General Public License v2.0 w/GCC Runtime Library exception",
        true
    ],
    "GPL-3.0": [
        "GNU General Public License v3.0 only",
        true
    ],
    "GPL-3.0+": [
        "GNU General Public License v3.0 or later",
        true
    ],
    "GPL-3.0-with-autoconf-exception": [
        "GNU General Public License v3.0 w/Autoconf exception",
        true
    ],
    "GPL-3.0-with-GCC-exception": [
        "GNU General Public License v3.0 w/GCC Runtime Library exception",
        true
    ],
    "LGPL-2.1": [
        "GNU Lesser General Public License v2.1 only",
        true
    ],
    "LGPL-2.1+": [
        "GNU Lesser General Public License v2.1 or later",
        true
    ],
    "LGPL-3.0": [
        "GNU Lesser General Public License v3.0 only",
        true
    ],
    "LGPL-3.0+": [
        "GNU Lesser General Public License v3.0 or later",
        true
    ],
    "LGPL-2.0": [
        "GNU Library General Public License v2 only",
        true
    ],
    "LGPL-2.0+": [
        "GNU Library General Public License v2 or later",
        true
    ],
    "gnuplot": [
        "gnuplot License",
        false
    ],
    "gSOAP-1.3b": [
        "gSOAP Public License v1.3b",
        false
    ],
    "HaskellReport": [
        "Haskell Language Report License",
        false
    ],
    "HPND": [
        "Historic Permission Notice and Disclaimer",
        true
    ],
    "IBM-pibs": [
        "IBM PowerPC Initialization and Boot Software",
        false
    ],
    "IPL-1.0": [
        "IBM Public License v1.0",
        true
    ],
    "ImageMagick": [
        "ImageMagick License",
        false
    ],
    "iMatix": [
        "iMatix Standard Function Library Agreement",
        false
    ],
    "Imlib2": [
        "Imlib2 License",
        false
    ],
    "IJG": [
        "Independent JPEG Group License",
        false
    ],
    "Intel-ACPI": [
        "Intel ACPI Software License Agreement",
        false
    ],
    "Intel": [
        "Intel Open Source License",
        true
    ],
    "IPA": [
        "IPA Font License",
        true
    ],
    "ISC": [
        "ISC License",
        true
    ],
    "JasPer-2.0": [
        "JasPer License",
        false
    ],
    "JSON": [
        "JSON License",
        false
    ],
    "LPPL-1.3a": [
        "LaTeX Project Public License 1.3a",
        false
    ],
    "LPPL-1.0": [
        "LaTeX Project Public License v1.0",
        false
    ],
    "LPPL-1.1": [
        "LaTeX Project Public License v1.1",
        false
    ],
    "LPPL-1.2": [
        "LaTeX Project Public License v1.2",
        false
    ],
    "LPPL-1.3c": [
        "LaTeX Project Public License v1.3c",
        true
    ],
    "Latex2e": [
        "Latex2e License",
        false
    ],
    "BSD-3-Clause-LBNL": [
        "Lawrence Berkeley National Labs BSD variant license",
        false
    ],
    "Leptonica": [
        "Leptonica License",
        false
    ],
    "Libpng": [
        "libpng License",
        false
    ],
    "libtiff": [
        "libtiff License",
        false
    ],
    "LPL-1.02": [
        "Lucent Public License v1.02",
        true
    ],
    "LPL-1.0": [
        "Lucent Public License Version 1.0",
        true
    ],
    "MakeIndex": [
        "MakeIndex License",
        false
    ],
    "MTLL": [
        "Matrix Template Library License",
        false
    ],
    "MS-PL": [
        "Microsoft Public License",
        true
    ],
    "MS-RL": [
        "Microsoft Reciprocal License",
        true
    ],
    "MirOS": [
        "MirOS Licence",
        true
    ],
    "MITNFA": [
        "MIT +no-false-attribs license",
        false
    ],
    "MIT": [
        "MIT License",
        true
    ],
    "Motosoto": [
        "Motosoto License",
        true
    ],
    "MPL-1.0": [
        "Mozilla Public License 1.0",
        true
    ],
    "MPL-1.1": [
        "Mozilla Public License 1.1",
        true
    ],
    "MPL-2.0": [
        "Mozilla Public License 2.0",
        true
    ],
    "MPL-2.0-no-copyleft-exception": [
        "Mozilla Public License 2.0 (no copyleft exception)",
        true
    ],
    "mpich2": [
        "mpich2 License",
        false
    ],
    "Multics": [
        "Multics License",
        true
    ],
    "Mup": [
        "Mup License",
        false
    ],
    "NASA-1.3": [
        "NASA Open Source Agreement 1.3",
        true
    ],
    "Naumen": [
        "Naumen Public License",
        true
    ],
    "NBPL-1.0": [
        "Net Boolean Public License v1",
        false
    ],
    "NetCDF": [
        "NetCDF license",
        false
    ],
    "NGPL": [
        "Nethack General Public License",
        true
    ],
    "NOSL": [
        "Netizen Open Source License",
        false
    ],
    "NPL-1.0": [
        "Netscape Public License v1.0",
        false
    ],
    "NPL-1.1": [
        "Netscape Public License v1.1",
        false
    ],
    "Newsletr": [
        "Newsletr License",
        false
    ],
    "NLPL": [
        "No Limit Public License",
        false
    ],
    "Nokia": [
        "Nokia Open Source License",
        true
    ],
    "NPOSL-3.0": [
        "Non-Profit Open Software License 3.0",
        true
    ],
    "Noweb": [
        "Noweb License",
        false
    ],
    "NRL": [
        "NRL License",
        false
    ],
    "NTP": [
        "NTP License",
        true
    ],
    "Nunit": [
        "Nunit License",
        false
    ],
    "OCLC-2.0": [
        "OCLC Research Public License 2.0",
        true
    ],
    "ODbL-1.0": [
        "ODC Open Database License v1.0",
        false
    ],
    "PDDL-1.0": [
        "ODC Public Domain Dedication & License 1.0",
        false
    ],
    "OGTSL": [
        "Open Group Test Suite License",
        true
    ],
    "OLDAP-2.2.2": [
        "Open LDAP Public License  2.2.2",
        false
    ],
    "OLDAP-1.1": [
        "Open LDAP Public License v1.1",
        false
    ],
    "OLDAP-1.2": [
        "Open LDAP Public License v1.2",
        false
    ],
    "OLDAP-1.3": [
        "Open LDAP Public License v1.3",
        false
    ],
    "OLDAP-1.4": [
        "Open LDAP Public License v1.4",
        false
    ],
    "OLDAP-2.0": [
        "Open LDAP Public License v2.0 (or possibly 2.0A and 2.0B)",
        false
    ],
    "OLDAP-2.0.1": [
        "Open LDAP Public License v2.0.1",
        false
    ],
    "OLDAP-2.1": [
        "Open LDAP Public License v2.1",
        false
    ],
    "OLDAP-2.2": [
        "Open LDAP Public License v2.2",
        false
    ],
    "OLDAP-2.2.1": [
        "Open LDAP Public License v2.2.1",
        false
    ],
    "OLDAP-2.3": [
        "Open LDAP Public License v2.3",
        false
    ],
    "OLDAP-2.4": [
        "Open LDAP Public License v2.4",
        false
    ],
    "OLDAP-2.5": [
        "Open LDAP Public License v2.5",
        false
    ],
    "OLDAP-2.6": [
        "Open LDAP Public License v2.6",
        false
    ],
    "OLDAP-2.7": [
        "Open LDAP Public License v2.7",
        false
    ],
    "OML": [
        "Open Market License",
        false
    ],
    "OPL-1.0": [
        "Open Public License v1.0",
        false
    ],
    "OSL-1.0": [
        "Open Software License 1.0",
        true
    ],
    "OSL-1.1": [
        "Open Software License 1.1",
        false
    ],
    "OSL-2.0": [
        "Open Software License 2.0",
        true
    ],
    "OSL-2.1": [
        "Open Software License 2.1",
        true
    ],
    "OSL-3.0": [
        "Open Software License 3.0",
        true
    ],
    "OLDAP-2.8": [
        "OpenLDAP Public License v2.8",
        false
    ],
    "OpenSSL": [
        "OpenSSL License",
        false
    ],
    "PHP-3.0": [
        "PHP License v3.0",
        true
    ],
    "PHP-3.01": [
        "PHP License v3.01",
        false
    ],
    "Plexus": [
        "Plexus Classworlds License",
        false
    ],
    "PostgreSQL": [
        "PostgreSQL License",
        true
    ],
    "psfrag": [
        "psfrag License",
        false
    ],
    "psutils": [
        "psutils License",
        false
    ],
    "Python-2.0": [
        "Python License 2.0",
        true
    ],
    "QPL-1.0": [
        "Q Public License 1.0",
        true
    ],
    "Qhull": [
        "Qhull License",
        false
    ],
    "Rdisc": [
        "Rdisc License",
        false
    ],
    "RPSL-1.0": [
        "RealNetworks Public Source License v1.0",
        true
    ],
    "RPL-1.1": [
        "Reciprocal Public License 1.1",
        true
    ],
    "RPL-1.5": [
        "Reciprocal Public License 1.5",
        true
    ],
    "RHeCos-1.1": [
        "Red Hat eCos Public License v1.1",
        false
    ],
    "RSCPL": [
        "Ricoh Source Code Public License",
        true
    ],
    "Ruby": [
        "Ruby License",
        false
    ],
    "SAX-PD": [
        "Sax Public Domain Notice",
        false
    ],
    "Saxpath": [
        "Saxpath License",
        false
    ],
    "SCEA": [
        "SCEA Shared Source License",
        false
    ],
    "SWL": [
        "Scheme Widget Library (SWL) Software License Agreement",
        false
    ],
    "SGI-B-1.0": [
        "SGI Free Software License B v1.0",
        false
    ],
    "SGI-B-1.1": [
        "SGI Free Software License B v1.1",
        false
    ],
    "SGI-B-2.0": [
        "SGI Free Software License B v2.0",
        false
    ],
    "OFL-1.0": [
        "SIL Open Font License 1.0",
        false
    ],
    "OFL-1.1": [
        "SIL Open Font License 1.1",
        true
    ],
    "SimPL-2.0": [
        "Simple Public License 2.0",
        true
    ],
    "Sleepycat": [
        "Sleepycat License",
        true
    ],
    "SNIA": [
        "SNIA Public License 1.1",
        false
    ],
    "SMLNJ": [
        "Standard ML of New Jersey License",
        false
    ],
    "StandardML-NJ": [
        "Standard ML of New Jersey License",
        false
    ],
    "SugarCRM-1.1.3": [
        "SugarCRM Public License v1.1.3",
        false
    ],
    "SISSL": [
        "Sun Industry Standards Source License v1.1",
        true
    ],
    "SISSL-1.2": [
        "Sun Industry Standards Source License v1.2",
        false
    ],
    "SPL-1.0": [
        "Sun Public License v1.0",
        true
    ],
    "Watcom-1.0": [
        "Sybase Open Watcom Public License 1.0",
        true
    ],
    "TCL": [
        "TCL/TK License",
        false
    ],
    "Unlicense": [
        "The Unlicense",
        false
    ],
    "TMate": [
        "TMate Open Source License",
        false
    ],
    "TORQUE-1.1": [
        "TORQUE v2.5+ Software License v1.1",
        false
    ],
    "TOSL": [
        "Trusster Open Source License",
        false
    ],
    "Unicode-TOU": [
        "Unicode Terms of Use",
        false
    ],
    "NCSA": [
        "University of Illinois/NCSA Open Source License",
        true
    ],
    "Vim": [
        "Vim License",
        false
    ],
    "VOSTROM": [
        "VOSTROM Public License for Open Source",
        false
    ],
    "VSL-1.0": [
        "Vovida Software License v1.0",
        true
    ],
    "W3C": [
        "W3C Software Notice and License",
        true
    ],
    "Wsuipa": [
        "Wsuipa License",
        false
    ],
    "WXwindows": [
        "wxWindows Library License",
        true
    ],
    "Xnet": [
        "X.Net License",
        true
    ],
    "X11": [
        "X11 License",
        false
    ],
    "Xerox": [
        "Xerox License",
        false
    ],
    "XFree86-1.1": [
        "XFree86 License 1.1",
        false
    ],
    "xinetd": [
        "xinetd License",
        false
    ],
    "xpp": [
        "XPP License",
        false
    ],
    "XSkat": [
        "XSkat License",
        false
    ],
    "YPL-1.0": [
        "Yahoo! Public License v1.0",
        false
    ],
    "YPL-1.1": [
        "Yahoo! Public License v1.1",
        false
    ],
    "Zed": [
        "Zed License",
        false
    ],
    "Zend-2.0": [
        "Zend License v2.0",
        false
    ],
    "Zimbra-1.3": [
        "Zimbra Public License v1.3",
        false
    ],
    "Zlib": [
        "zlib License",
        true
    ],
    "zlib-acknowledgement": [
        "zlib/libpng License with Acknowledgement",
        false
    ],
    "ZPL-1.1": [
        "Zope Public License 1.1",
        false
    ],
    "ZPL-2.0": [
        "Zope Public License 2.0",
        true
    ],
    "ZPL-2.1": [
        "Zope Public License 2.1",
        false
    ]
}MZê       ˇˇ  ∏       @                                   Ë   ∫ ¥	Õ!∏LÕ!This program cannot be run in DOS mode.
$       ∆,Õ;ßBû;ßBû;ßBû2ﬂ◊û:ßBû2ﬂ¡û-ßBû2ﬂ∆û9ßBû2ﬂ—û?ßBûa9û8ßBû;ßCûßBû2ﬂ»û:ßBû2ﬂ÷û:ßBû2ﬂ”û:ßBûRich;ßBû        PE  L ¨MoO        ‡ 	  
         8           @                      `     ?ú   @Å                           ê"  P    @                      P  p   !                             8!  @               ÿ                           .text   	      
                    `.rdata  Œ	       
                 @  @.data   ê   0                    @  ¿.rsrc       @                    @  @.reloc  Ã   P      "              @  B                                                                                                                                                                                                                                                                                                                                                        j$∏Ê@ Ëx  jˆˇ @ Ée– ãçE–PVˇ  @ ãE–É‡˚PVˇ @ çM‘ˇX @ Ée¸ çE‘Pˇ5H @ ˇL @ YYˇ5\ @ çE‘Pˇ5` @ ˇD @ YYã»ˇP @ ÉM¸ˇçM‘ˇT @ 3¿ËH  √; 0@ uÛ√È¨  hÄ@ Ë£  °l3@ «$40@ ˇ5h3@ £40@ h$0@ h(0@ h 0@ ˇ† @ Éƒ£00@ Ö¿}jËπ  Y√jh"@ Ë  3€â]¸d°   ãpâ]‰øÄ3@ SVWˇ0 @ ;√t;∆u3ˆFâu‰ÎhË  ˇ4 @ Î⁄3ˆF°|3@ ;∆u
jË\  YÎ;°|3@ Ö¿u,â5|3@ h @ h‰ @ Ëß  YYÖ¿t«E¸˛ˇˇˇ∏ˇ   È›   â5<0@ °|3@ ;∆uh‡ @ hÿ @ Ël  YY«|3@    9]‰uSWˇ8 @ 9å3@ thå3@ ËÉ  YÖ¿t
SjSˇå3@ °$0@ ãº @ âˇ5$0@ ˇ5(0@ ˇ5 0@ Ë˛ˇˇÉƒ£80@ 9,0@ u7Pˇ¿ @ ãEÏãã	âM‡PQËé  YY√ãeËãE‡£80@ 3€9,0@ uPˇh @ 9<0@ uˇú @ «E¸˛ˇˇˇ°80@ Ë˚  √∏MZ  f9  @ t3¿ÎM°< @ çÄ  @ Å8PE  uÈ∑HÅ˘  tÅ˘  u’É∏Ñ   vÃ3…9à¯   ÎÉxtvº3…9àË   ï¡ã¡j£,0@ ˇp @ jˇˇl @ YY£Ñ3@ £à3@ ˇÃ @ ãt3@ âˇà @ ãp3@ â°® @ ã £x3@ ËV  Ë¨  É=0@  uhµ@ ˇ¨ @ YËg  É=0@ ˇu	jˇˇ∞ @ Y3¿√Ë{  Èü˝ˇˇãˇUãÏÅÏ(  £H1@ âD1@ â@1@ â<1@ â581@ â=41@ få`1@ fåT1@ få01@ få,1@ få%(1@ få-$1@ úèX1@ ãE £L1@ ãE£P1@ çE£\1@ ãÖ‡¸ˇˇ«ò0@   °P1@ £L0@ «@0@ 	 ¿«D0@    ° 0@ âÖÿ¸ˇˇ°0@ âÖ‹¸ˇˇˇ @ £ê0@ jË?  Yj ˇ  @ h!@ ˇ$ @ É=ê0@  ujË  Yh	 ¿ˇ( @ Pˇ, @ …√ãˇUãÏãEã Å8csm‡u*Éxu$ã@= ìt=!ìt="ìt= @ôuË–  3¿]¬ hH@ ˇ  @ 3¿√ˇ%§ @ jh("@ Ëb  ˇ5à3@ ã5å @ ˇ÷YâE‰É¯ˇuˇuˇƒ @ YÎgjËí  YÉe¸ ˇ5à3@ ˇ÷âE‰ˇ5Ñ3@ ˇ÷YYâE‡çE‡PçE‰Pˇuã5l @ ˇ÷YPËU  âE‹ˇu‰ˇ÷£à3@ ˇu‡ˇ÷Éƒ£Ñ3@ «E¸˛ˇˇˇË	   ãE‹Ë  √jË  Y√ãˇUãÏˇuËNˇˇˇ˜ÿ¿˜ÿYH]√ãˇV∏¸!@ æ¸!@ Wã¯;∆sãÖ¿tˇ–É«;˛rÒ_^√ãˇV∏"@ æ"@ Wã¯;∆sãÖ¿tˇ–É«;˛rÒ_^√ˇ%» @ ÃÃÃÃãˇUãÏãM∏MZ  f9t3¿]√ãA<¡Å8PE  uÔ3“π  f9Hî¬ã¬]√ÃÃÃÃÃÃÃÃÃÃÃãˇUãÏãEãH<»∑ASV∑q3“WçDÖˆvã}ãH;˘r	ãXŸ;˚r
BÉ¿(;÷rË3¿_^[]√ÃÃÃÃÃÃÃÃÃÃÃÃãˇUãÏj˛hH"@ he@ d°    PÉÏSVW° 0@ 1E¯3≈PçEd£    âeË«E¸    h  @ Ë*ˇˇˇÉƒÖ¿tUãE-  @ Ph  @ ËPˇˇˇÉƒÖ¿t;ã@$¡Ë˜–É‡«E¸˛ˇˇˇãMdâ    Y_^[ãÂ]√ãEÏãã3“=  ¿î¬ã¬√ãeË«E¸˛ˇˇˇ3¿ãMdâ    Y_^[ãÂ]√Ãˇ%∏ @ ˇ%¥ @ ÃÃhe@ dˇ5    ãD$âl$çl$+‡SVW° 0@ 1E¸3≈PâeËˇu¯ãE¸«E¸˛ˇˇˇâE¯çEd£    √ãMdâ    Y__^[ãÂ]Q√ãˇUãÏˇuˇuˇuˇuhá@ h 0@ ËÁ   Éƒ]√ãˇVh   h   3ˆVËŸ   ÉƒÖ¿tVVVVVË¬   Éƒ^√3¿√ãˇUãÏÉÏ° 0@ Ée¯ Ée¸ SWøNÊ@ªª  ˇˇ;«tÖ√t	˜–£0@ Î`VçE¯Pˇ< @ ãu¸3u¯ˇ @ 3ˇ @ 3ˇ @ 3çEPˇ @ ãEÙ3E3;˜uæOÊ@ªÎÖÛuã∆¡‡â5 0@ ˜÷â50@ ^_[…√ˇ%t @ ˇ%x @ ˇ%| @ ˇ%Ä @ ˇ%Ñ @ ˇ%ê @ ˇ%î @ ˇ%ò @ ˇ%– @ Pdˇ5    çD$+d$SVWâ(ãË° 0@ 3≈PâEˇu¸«E¸ˇˇˇˇçEÙd£    √ãMÙdâ    Y__^[ãÂ]Q√ãM3ÕËØ˜ˇˇÈ›ˇˇˇçM‘ˇ%T @ ãT$çBãJÃ3»Ëê˜ˇˇãJ¸3»ËÜ˜ˇˇ∏l"@ Èsˇˇˇ                                                                                                                                                                                                                                                     ∏#   #  ‹#  à)  r)  b)  H)  4)  )  ˙(  Ê(  “(  ¥(  ¨(  ñ(  û)      ˙#  ‡$  %   %  &  d&  Æ&  §$      ('  ƒ'  ÷'  Ë'  ˛'  (  ((  6(  ¶'  H(  Z(  t(  Ü(  '  '   '  ñ'  Ç'  l'  ^'  R'  F'  >'  >(  0'  ∂'  ∏)          ñ@         W@ ä@                     ¨MoO       l   Ä!  Ä  @0@ ò0@ bad allocation      H                                                            0@ !@    RSDS—å≥¥èJ®!ˆÃÎLZ    c:\users\seld\documents\visual studio 2010\Projects\hiddeninp\Release\hiddeninp.pdb     e  Ê                  ˛ˇˇˇ    –ˇˇˇ    ˛ˇˇˇ@ @     ˛ˇˇˇ    Ãˇˇˇ    ˛ˇˇˇ    :@     ˛ˇˇˇ    ÿˇˇˇ    ˛ˇˇˇÀ@ ﬂ@ ˇˇˇˇ›@ "ì   d"@                        ‡"          Ï#      $#          Ù&  D   H#          (  h                       ∏#   #  ‹#  à)  r)  b)  H)  4)  )  ˙(  Ê(  “(  ¥(  ¨(  ñ(  û)      ˙#  ‡$  %   %  &  d&  Æ&  §$      ('  ƒ'  ÷'  Ë'  ˛'  (  ((  6(  ¶'  H(  Z(  t(  Ü(  '  '   '  ñ'  Ç'  l'  ^'  R'  F'  >'  >(  0'  ∂'  ∏)      ïGetConsoleMode  ∑SetConsoleMode  ;GetStdHandle  KERNEL32.dll   ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ë?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A  J?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A ¬ ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z  _??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ  {??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ  ≥?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z  MSVCP90.dll _amsg_exit  ü __getmainargs ,_cexit  |_exit f _XcptFilter Ãexit  † __initenv _initterm _initterm_e <_configthreadlocale „ __setusermatherr  _adjust_fdiv  À __p__commode  œ __p__fmode  j_encode_pointer ‡ __set_app_type  K_crt_debugger_hook  C ?terminate@@YAXXZ MSVCR90.dll Ê_unlock ñ __dllonexit v_lock _onexit `_decode_pointer s_except_handler4_common _invoke_watson  ?_controlfp_s  ΩInterlockedExchange !Sleep ∫InterlockedCompareExchange  -TerminateProcess  ©GetCurrentProcess >UnhandledExceptionFilter  SetUnhandledExceptionFilter —IsDebuggerPresent TQueryPerformanceCounter fGetTickCount  ≠GetCurrentThreadId  ™GetCurrentProcessId OGetSystemTimeAsFileTime s __CxxFrameHandler3                                                    NÊ@ª±øDˇˇˇˇˇˇˇˇ˛ˇˇˇ   $!@                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Ä   8  Ä                 P  Ä                 h  Ä              	  Ä                 	  ê   †@  (  ‰      »C  V  ‰      (4   V S _ V E R S I O N _ I N F O     ΩÔ˛                                          Ü   S t r i n g F i l e I n f o   b   0 4 0 9 0 4 b 0     Q  F i l e D e s c r i p t i o n     R e a d s   f r o m   s t d i n   w i t h o u t   l e a k i n g   i n f o   t o   t h e   t e r m i n a l   a n d   o u t p u t s   b a c k   t o   s t d o u t     6   F i l e V e r s i o n     1 ,   0 ,   0 ,   0     8   I n t e r n a l N a m e   h i d d e n i n p u t   P   L e g a l C o p y r i g h t   J o r d i   B o g g i a n o   -   2 0 1 2   H   O r i g i n a l F i l e n a m e   h i d d e n i n p u t . e x e   :   P r o d u c t N a m e     H i d d e n   I n p u t     :   P r o d u c t V e r s i o n   1 ,   0 ,   0 ,   0     D    V a r F i l e I n f o     $    T r a n s l a t i o n     	∞<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"></requestedExecutionLevel>
      </requestedPrivileges>
    </security>
  </trustInfo>
  <dependency>
    <dependentAssembly>
      <assemblyIdentity type="win32" name="Microsoft.VC90.CRT" version="9.0.21022.8" processorArchitecture="x86" publicKeyToken="1fc8b3b9a1e18e3b"></assemblyIdentity>
    </dependentAssembly>
  </dependency>
</assembly>PAPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDING   @  00!0/080F0L0T0^0d0n0{0â0ó0°0®0Æ0≥0∏0Ω0¬0»0–0‰0ˇ01#1-1@1J1O1T1v1{1Ñ1â1ñ1ß1≠1¥1»1Õ1”1€1·1Á1Ù1˙12"2*23292A2M2_2j2p2π2ø2«2Œ2”2Ÿ2ﬂ2Á2Ì2Ù2˚2333%303N3T3Z3`3f3l3s3z3Å3à3è3ñ3ù3•3≠3µ3¡3 3œ3’3ﬂ3Ë3Û3ˇ34444%4;4B4ã4ë4ö4°4¨4≤4∆4€4Ê4˛45!5^5c5Ñ5â5®5H6M6_6}6ë6ó6 777*7w7|7¡7‰7Ò7˝7888=8E8P8V8\8b8h8n8t8z8Ä8ú8‚89      $   ‹0Ë0Ï01 1t1x12 2@2\2`2h2t2 0     0                                                                                                                                                  <?php










namespace Symfony\Component\Console;

use Symfony\Component\Console\Descriptor\TextDescriptor;
use Symfony\Component\Console\Descriptor\XmlDescriptor;
use Symfony\Component\Console\Helper\DebugFormatterHelper;
use Symfony\Component\Console\Helper\ProcessHelper;
use Symfony\Component\Console\Helper\QuestionHelper;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\ArgvInput;
use Symfony\Component\Console\Input\ArrayInput;
use Symfony\Component\Console\Input\InputDefinition;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputAwareInterface;
use Symfony\Component\Console\Output\BufferedOutput;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Output\ConsoleOutput;
use Symfony\Component\Console\Output\ConsoleOutputInterface;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Command\HelpCommand;
use Symfony\Component\Console\Command\ListCommand;
use Symfony\Component\Console\Helper\HelperSet;
use Symfony\Component\Console\Helper\FormatterHelper;
use Symfony\Component\Console\Helper\DialogHelper;
use Symfony\Component\Console\Helper\ProgressHelper;
use Symfony\Component\Console\Helper\TableHelper;
use Symfony\Component\Console\Event\ConsoleCommandEvent;
use Symfony\Component\Console\Event\ConsoleExceptionEvent;
use Symfony\Component\Console\Event\ConsoleTerminateEvent;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;


















class Application
{
private $commands = array();
private $wantHelps = false;
private $runningCommand;
private $name;
private $version;
private $catchExceptions = true;
private $autoExit = true;
private $definition;
private $helperSet;
private $dispatcher;
private $terminalDimensions;
private $defaultCommand;









public function __construct($name = 'UNKNOWN', $version = 'UNKNOWN')
{
$this->name = $name;
$this->version = $version;
$this->defaultCommand = 'list';
$this->helperSet = $this->getDefaultHelperSet();
$this->definition = $this->getDefaultInputDefinition();

foreach ($this->getDefaultCommands() as $command) {
$this->add($command);
}
}

public function setDispatcher(EventDispatcherInterface $dispatcher)
{
$this->dispatcher = $dispatcher;
}













public function run(InputInterface $input = null, OutputInterface $output = null)
{
if (null === $input) {
$input = new ArgvInput();
}

if (null === $output) {
$output = new ConsoleOutput();
}

$this->configureIO($input, $output);

try {
$exitCode = $this->doRun($input, $output);
} catch (\Exception $e) {
if (!$this->catchExceptions) {
throw $e;
}

if ($output instanceof ConsoleOutputInterface) {
$this->renderException($e, $output->getErrorOutput());
} else {
$this->renderException($e, $output);
}

$exitCode = $e->getCode();
if (is_numeric($exitCode)) {
$exitCode = (int) $exitCode;
if (0 === $exitCode) {
$exitCode = 1;
}
} else {
$exitCode = 1;
}
}

if ($this->autoExit) {
if ($exitCode > 255) {
$exitCode = 255;
}

exit($exitCode);
}

return $exitCode;
}









public function doRun(InputInterface $input, OutputInterface $output)
{
if (true === $input->hasParameterOption(array('--version', '-V'))) {
$output->writeln($this->getLongVersion());

return 0;
}

$name = $this->getCommandName($input);
if (true === $input->hasParameterOption(array('--help', '-h'))) {
if (!$name) {
$name = 'help';
$input = new ArrayInput(array('command' => 'help'));
} else {
$this->wantHelps = true;
}
}

if (!$name) {
$name = $this->defaultCommand;
$input = new ArrayInput(array('command' => $this->defaultCommand));
}


 $command = $this->find($name);

$this->runningCommand = $command;
$exitCode = $this->doRunCommand($command, $input, $output);
$this->runningCommand = null;

return $exitCode;
}








public function setHelperSet(HelperSet $helperSet)
{
$this->helperSet = $helperSet;
}








public function getHelperSet()
{
return $this->helperSet;
}








public function setDefinition(InputDefinition $definition)
{
$this->definition = $definition;
}






public function getDefinition()
{
return $this->definition;
}






public function getHelp()
{
return $this->getLongVersion();
}








public function setCatchExceptions($boolean)
{
$this->catchExceptions = (bool) $boolean;
}








public function setAutoExit($boolean)
{
$this->autoExit = (bool) $boolean;
}








public function getName()
{
return $this->name;
}








public function setName($name)
{
$this->name = $name;
}








public function getVersion()
{
return $this->version;
}








public function setVersion($version)
{
$this->version = $version;
}








public function getLongVersion()
{
if ('UNKNOWN' !== $this->getName() && 'UNKNOWN' !== $this->getVersion()) {
return sprintf('<info>%s</info> version <comment>%s</comment>', $this->getName(), $this->getVersion());
}

return '<info>Console Tool</info>';
}










public function register($name)
{
return $this->add(new Command($name));
}








public function addCommands(array $commands)
{
foreach ($commands as $command) {
$this->add($command);
}
}












public function add(Command $command)
{
$command->setApplication($this);

if (!$command->isEnabled()) {
$command->setApplication(null);

return;
}

if (null === $command->getDefinition()) {
throw new \LogicException(sprintf('Command class "%s" is not correctly initialized. You probably forgot to call the parent constructor.', get_class($command)));
}

$this->commands[$command->getName()] = $command;

foreach ($command->getAliases() as $alias) {
$this->commands[$alias] = $command;
}

return $command;
}












public function get($name)
{
if (!isset($this->commands[$name])) {
throw new \InvalidArgumentException(sprintf('The command "%s" does not exist.', $name));
}

$command = $this->commands[$name];

if ($this->wantHelps) {
$this->wantHelps = false;

$helpCommand = $this->get('help');
$helpCommand->setCommand($command);

return $helpCommand;
}

return $command;
}










public function has($name)
{
return isset($this->commands[$name]);
}








public function getNamespaces()
{
$namespaces = array();
foreach ($this->commands as $command) {
$namespaces = array_merge($namespaces, $this->extractAllNamespaces($command->getName()));

foreach ($command->getAliases() as $alias) {
$namespaces = array_merge($namespaces, $this->extractAllNamespaces($alias));
}
}

return array_values(array_unique(array_filter($namespaces)));
}










public function findNamespace($namespace)
{
$allNamespaces = $this->getNamespaces();
$expr = preg_replace_callback('{([^:]+|)}', function ($matches) { return preg_quote($matches[1]).'[^:]*'; }, $namespace);
$namespaces = preg_grep('{^'.$expr.'}', $allNamespaces);

if (empty($namespaces)) {
$message = sprintf('There are no commands defined in the "%s" namespace.', $namespace);

if ($alternatives = $this->findAlternatives($namespace, $allNamespaces, array())) {
if (1 == count($alternatives)) {
$message .= "\n\nDid you mean this?\n    ";
} else {
$message .= "\n\nDid you mean one of these?\n    ";
}

$message .= implode("\n    ", $alternatives);
}

throw new \InvalidArgumentException($message);
}

$exact = in_array($namespace, $namespaces, true);
if (count($namespaces) > 1 && !$exact) {
throw new \InvalidArgumentException(sprintf('The namespace "%s" is ambiguous (%s).', $namespace, $this->getAbbreviationSuggestions(array_values($namespaces))));
}

return $exact ? $namespace : reset($namespaces);
}















public function find($name)
{
$allCommands = array_keys($this->commands);
$expr = preg_replace_callback('{([^:]+|)}', function ($matches) { return preg_quote($matches[1]).'[^:]*'; }, $name);
$commands = preg_grep('{^'.$expr.'}', $allCommands);

if (empty($commands) || count(preg_grep('{^'.$expr.'$}', $commands)) < 1) {
if (false !== $pos = strrpos($name, ':')) {

 $this->findNamespace(substr($name, 0, $pos));
}

$message = sprintf('Command "%s" is not defined.', $name);

if ($alternatives = $this->findAlternatives($name, $allCommands, array())) {
if (1 == count($alternatives)) {
$message .= "\n\nDid you mean this?\n    ";
} else {
$message .= "\n\nDid you mean one of these?\n    ";
}
$message .= implode("\n    ", $alternatives);
}

throw new \InvalidArgumentException($message);
}


 if (count($commands) > 1) {
$commandList = $this->commands;
$commands = array_filter($commands, function ($nameOrAlias) use ($commandList, $commands) {
$commandName = $commandList[$nameOrAlias]->getName();

return $commandName === $nameOrAlias || !in_array($commandName, $commands);
});
}

$exact = in_array($name, $commands, true);
if (count($commands) > 1 && !$exact) {
$suggestions = $this->getAbbreviationSuggestions(array_values($commands));

throw new \InvalidArgumentException(sprintf('Command "%s" is ambiguous (%s).', $name, $suggestions));
}

return $this->get($exact ? $name : reset($commands));
}












public function all($namespace = null)
{
if (null === $namespace) {
return $this->commands;
}

$commands = array();
foreach ($this->commands as $name => $command) {
if ($namespace === $this->extractNamespace($name, substr_count($namespace, ':') + 1)) {
$commands[$name] = $command;
}
}

return $commands;
}








public static function getAbbreviations($names)
{
$abbrevs = array();
foreach ($names as $name) {
for ($len = strlen($name); $len > 0; --$len) {
$abbrev = substr($name, 0, $len);
$abbrevs[$abbrev][] = $name;
}
}

return $abbrevs;
}











public function asText($namespace = null, $raw = false)
{
$descriptor = new TextDescriptor();
$output = new BufferedOutput(BufferedOutput::VERBOSITY_NORMAL, !$raw);
$descriptor->describe($output, $this, array('namespace' => $namespace, 'raw_output' => true));

return $output->fetch();
}











public function asXml($namespace = null, $asDom = false)
{
$descriptor = new XmlDescriptor();

if ($asDom) {
return $descriptor->getApplicationDocument($this, $namespace);
}

$output = new BufferedOutput();
$descriptor->describe($output, $this, array('namespace' => $namespace));

return $output->fetch();
}







public function renderException($e, $output)
{
do {
$title = sprintf('  [%s]  ', get_class($e));

$len = $this->stringWidth($title);

$width = $this->getTerminalWidth() ? $this->getTerminalWidth() - 1 : PHP_INT_MAX;

 if (defined('HHVM_VERSION') && $width > 1 << 31) {
$width = 1 << 31;
}
$formatter = $output->getFormatter();
$lines = array();
foreach (preg_split('/\r?\n/', $e->getMessage()) as $line) {
foreach ($this->splitStringByWidth($line, $width - 4) as $line) {

 $lineLength = $this->stringWidth(preg_replace('/\[[^m]*m/', '', $formatter->format($line))) + 4;
$lines[] = array($line, $lineLength);

$len = max($lineLength, $len);
}
}

$messages = array('', '');
$messages[] = $emptyLine = $formatter->format(sprintf('<error>%s</error>', str_repeat(' ', $len)));
$messages[] = $formatter->format(sprintf('<error>%s%s</error>', $title, str_repeat(' ', max(0, $len - $this->stringWidth($title)))));
foreach ($lines as $line) {
$messages[] = $formatter->format(sprintf('<error>  %s  %s</error>', $line[0], str_repeat(' ', $len - $line[1])));
}
$messages[] = $emptyLine;
$messages[] = '';
$messages[] = '';

$output->writeln($messages, OutputInterface::OUTPUT_RAW);

if (OutputInterface::VERBOSITY_VERBOSE <= $output->getVerbosity()) {
$output->writeln('<comment>Exception trace:</comment>');


 $trace = $e->getTrace();
array_unshift($trace, array(
'function' => '',
'file' => $e->getFile() !== null ? $e->getFile() : 'n/a',
'line' => $e->getLine() !== null ? $e->getLine() : 'n/a',
'args' => array(),
));

for ($i = 0, $count = count($trace); $i < $count; $i++) {
$class = isset($trace[$i]['class']) ? $trace[$i]['class'] : '';
$type = isset($trace[$i]['type']) ? $trace[$i]['type'] : '';
$function = $trace[$i]['function'];
$file = isset($trace[$i]['file']) ? $trace[$i]['file'] : 'n/a';
$line = isset($trace[$i]['line']) ? $trace[$i]['line'] : 'n/a';

$output->writeln(sprintf(' %s%s%s() at <info>%s:%s</info>', $class, $type, $function, $file, $line));
}

$output->writeln('');
$output->writeln('');
}
} while ($e = $e->getPrevious());

if (null !== $this->runningCommand) {
$output->writeln(sprintf('<info>%s</info>', sprintf($this->runningCommand->getSynopsis(), $this->getName())));
$output->writeln('');
$output->writeln('');
}
}






protected function getTerminalWidth()
{
$dimensions = $this->getTerminalDimensions();

return $dimensions[0];
}






protected function getTerminalHeight()
{
$dimensions = $this->getTerminalDimensions();

return $dimensions[1];
}






public function getTerminalDimensions()
{
if ($this->terminalDimensions) {
return $this->terminalDimensions;
}

if ('\\' === DIRECTORY_SEPARATOR) {

 if (preg_match('/^(\d+)x\d+ \(\d+x(\d+)\)$/', trim(getenv('ANSICON')), $matches)) {
return array((int) $matches[1], (int) $matches[2]);
}

 if (preg_match('/^(\d+)x(\d+)$/', $this->getConsoleMode(), $matches)) {
return array((int) $matches[1], (int) $matches[2]);
}
}

if ($sttyString = $this->getSttyColumns()) {

 if (preg_match('/rows.(\d+);.columns.(\d+);/i', $sttyString, $matches)) {
return array((int) $matches[2], (int) $matches[1]);
}

 if (preg_match('/;.(\d+).rows;.(\d+).columns/i', $sttyString, $matches)) {
return array((int) $matches[2], (int) $matches[1]);
}
}

return array(null, null);
}











public function setTerminalDimensions($width, $height)
{
$this->terminalDimensions = array($width, $height);

return $this;
}







protected function configureIO(InputInterface $input, OutputInterface $output)
{
if (true === $input->hasParameterOption(array('--ansi'))) {
$output->setDecorated(true);
} elseif (true === $input->hasParameterOption(array('--no-ansi'))) {
$output->setDecorated(false);
}

if (true === $input->hasParameterOption(array('--no-interaction', '-n'))) {
$input->setInteractive(false);
} elseif (function_exists('posix_isatty') && $this->getHelperSet()->has('question')) {
$inputStream = $this->getHelperSet()->get('question')->getInputStream();
if (!@posix_isatty($inputStream)) {
$input->setInteractive(false);
}
}

if (true === $input->hasParameterOption(array('--quiet', '-q'))) {
$output->setVerbosity(OutputInterface::VERBOSITY_QUIET);
} else {
if ($input->hasParameterOption('-vvv') || $input->hasParameterOption('--verbose=3') || $input->getParameterOption('--verbose') === 3) {
$output->setVerbosity(OutputInterface::VERBOSITY_DEBUG);
} elseif ($input->hasParameterOption('-vv') || $input->hasParameterOption('--verbose=2') || $input->getParameterOption('--verbose') === 2) {
$output->setVerbosity(OutputInterface::VERBOSITY_VERY_VERBOSE);
} elseif ($input->hasParameterOption('-v') || $input->hasParameterOption('--verbose=1') || $input->hasParameterOption('--verbose') || $input->getParameterOption('--verbose')) {
$output->setVerbosity(OutputInterface::VERBOSITY_VERBOSE);
}
}
}















protected function doRunCommand(Command $command, InputInterface $input, OutputInterface $output)
{
foreach ($command->getHelperSet() as $helper) {
if ($helper instanceof InputAwareInterface) {
$helper->setInput($input);
}
}

if (null === $this->dispatcher) {
return $command->run($input, $output);
}

$event = new ConsoleCommandEvent($command, $input, $output);
$this->dispatcher->dispatch(ConsoleEvents::COMMAND, $event);

if ($event->commandShouldRun()) {
try {
$exitCode = $command->run($input, $output);
} catch (\Exception $e) {
$event = new ConsoleTerminateEvent($command, $input, $output, $e->getCode());
$this->dispatcher->dispatch(ConsoleEvents::TERMINATE, $event);

$event = new ConsoleExceptionEvent($command, $input, $output, $e, $event->getExitCode());
$this->dispatcher->dispatch(ConsoleEvents::EXCEPTION, $event);

throw $event->getException();
}
} else {
$exitCode = ConsoleCommandEvent::RETURN_CODE_DISABLED;
}

$event = new ConsoleTerminateEvent($command, $input, $output, $exitCode);
$this->dispatcher->dispatch(ConsoleEvents::TERMINATE, $event);

return $event->getExitCode();
}








protected function getCommandName(InputInterface $input)
{
return $input->getFirstArgument();
}






protected function getDefaultInputDefinition()
{
return new InputDefinition(array(
new InputArgument('command', InputArgument::REQUIRED, 'The command to execute'),

new InputOption('--help', '-h', InputOption::VALUE_NONE, 'Display this help message'),
new InputOption('--quiet', '-q', InputOption::VALUE_NONE, 'Do not output any message'),
new InputOption('--verbose', '-v|vv|vvv', InputOption::VALUE_NONE, 'Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug'),
new InputOption('--version', '-V', InputOption::VALUE_NONE, 'Display this application version'),
new InputOption('--ansi', '', InputOption::VALUE_NONE, 'Force ANSI output'),
new InputOption('--no-ansi', '', InputOption::VALUE_NONE, 'Disable ANSI output'),
new InputOption('--no-interaction', '-n', InputOption::VALUE_NONE, 'Do not ask any interactive question'),
));
}






protected function getDefaultCommands()
{
return array(new HelpCommand(), new ListCommand());
}






protected function getDefaultHelperSet()
{
return new HelperSet(array(
new FormatterHelper(),
new DialogHelper(),
new ProgressHelper(),
new TableHelper(),
new DebugFormatterHelper(),
new ProcessHelper(),
new QuestionHelper(),
));
}






private function getSttyColumns()
{
if (!function_exists('proc_open')) {
return;
}

$descriptorspec = array(1 => array('pipe', 'w'), 2 => array('pipe', 'w'));
$process = proc_open('stty -a | grep columns', $descriptorspec, $pipes, null, null, array('suppress_errors' => true));
if (is_resource($process)) {
$info = stream_get_contents($pipes[1]);
fclose($pipes[1]);
fclose($pipes[2]);
proc_close($process);

return $info;
}
}






private function getConsoleMode()
{
if (!function_exists('proc_open')) {
return;
}

$descriptorspec = array(1 => array('pipe', 'w'), 2 => array('pipe', 'w'));
$process = proc_open('mode CON', $descriptorspec, $pipes, null, null, array('suppress_errors' => true));
if (is_resource($process)) {
$info = stream_get_contents($pipes[1]);
fclose($pipes[1]);
fclose($pipes[2]);
proc_close($process);

if (preg_match('/--------+\r?\n.+?(\d+)\r?\n.+?(\d+)\r?\n/', $info, $matches)) {
return $matches[2].'x'.$matches[1];
}
}
}








private function getAbbreviationSuggestions($abbrevs)
{
return sprintf('%s, %s%s', $abbrevs[0], $abbrevs[1], count($abbrevs) > 2 ? sprintf(' and %d more', count($abbrevs) - 2) : '');
}











public function extractNamespace($name, $limit = null)
{
$parts = explode(':', $name);
array_pop($parts);

return implode(':', null === $limit ? $parts : array_slice($parts, 0, $limit));
}










private function findAlternatives($name, $collection)
{
$threshold = 1e3;
$alternatives = array();

$collectionParts = array();
foreach ($collection as $item) {
$collectionParts[$item] = explode(':', $item);
}

foreach (explode(':', $name) as $i => $subname) {
foreach ($collectionParts as $collectionName => $parts) {
$exists = isset($alternatives[$collectionName]);
if (!isset($parts[$i]) && $exists) {
$alternatives[$collectionName] += $threshold;
continue;
} elseif (!isset($parts[$i])) {
continue;
}

$lev = levenshtein($subname, $parts[$i]);
if ($lev <= strlen($subname) / 3 || '' !== $subname && false !== strpos($parts[$i], $subname)) {
$alternatives[$collectionName] = $exists ? $alternatives[$collectionName] + $lev : $lev;
} elseif ($exists) {
$alternatives[$collectionName] += $threshold;
}
}
}

foreach ($collection as $item) {
$lev = levenshtein($name, $item);
if ($lev <= strlen($name) / 3 || false !== strpos($item, $name)) {
$alternatives[$item] = isset($alternatives[$item]) ? $alternatives[$item] - $lev : $lev;
}
}

$alternatives = array_filter($alternatives, function ($lev) use ($threshold) { return $lev < 2*$threshold; });
asort($alternatives);

return array_keys($alternatives);
}






public function setDefaultCommand($commandName)
{
$this->defaultCommand = $commandName;
}

private function stringWidth($string)
{
if (!function_exists('mb_strwidth')) {
return strlen($string);
}

if (false === $encoding = mb_detect_encoding($string)) {
return strlen($string);
}

return mb_strwidth($string, $encoding);
}

private function splitStringByWidth($string, $width)
{

 
 

if (!function_exists('mb_strwidth')) {
return str_split($string, $width);
}

if (false === $encoding = mb_detect_encoding($string)) {
return str_split($string, $width);
}

$utf8String = mb_convert_encoding($string, 'utf8', $encoding);
$lines = array();
$line = '';
foreach (preg_split('//u', $utf8String) as $char) {

 if (mb_strwidth($line.$char, 'utf8') <= $width) {
$line .= $char;
continue;
}

 $lines[] = str_pad($line, $width);
$line = $char;
}
if (strlen($line)) {
$lines[] = count($lines) ? str_pad($line, $width) : $line;
}

mb_convert_variables($encoding, 'utf8', $lines);

return $lines;
}








private function extractAllNamespaces($name)
{

 $parts = explode(':', $name, -1);
$namespaces = array();

foreach ($parts as $part) {
if (count($namespaces)) {
$namespaces[] = end($namespaces).':'.$part;
} else {
$namespaces[] = $part;
}
}

return $namespaces;
}
}
<?php










namespace Symfony\Component\Console\Command;

use Symfony\Component\Console\Descriptor\TextDescriptor;
use Symfony\Component\Console\Descriptor\XmlDescriptor;
use Symfony\Component\Console\Input\InputDefinition;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\BufferedOutput;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Application;
use Symfony\Component\Console\Helper\HelperSet;








class Command
{
private $application;
private $name;
private $processTitle;
private $aliases = array();
private $definition;
private $help;
private $description;
private $ignoreValidationErrors = false;
private $applicationDefinitionMerged = false;
private $applicationDefinitionMergedWithArgs = false;
private $code;
private $synopsis;
private $helperSet;










public function __construct($name = null)
{
$this->definition = new InputDefinition();

if (null !== $name) {
$this->setName($name);
}

$this->configure();

if (!$this->name) {
throw new \LogicException(sprintf('The command defined in "%s" cannot have an empty name.', get_class($this)));
}
}






public function ignoreValidationErrors()
{
$this->ignoreValidationErrors = true;
}








public function setApplication(Application $application = null)
{
$this->application = $application;
if ($application) {
$this->setHelperSet($application->getHelperSet());
} else {
$this->helperSet = null;
}
}






public function setHelperSet(HelperSet $helperSet)
{
$this->helperSet = $helperSet;
}






public function getHelperSet()
{
return $this->helperSet;
}








public function getApplication()
{
return $this->application;
}









public function isEnabled()
{
return true;
}




protected function configure()
{
}


















protected function execute(InputInterface $input, OutputInterface $output)
{
throw new \LogicException('You must override the execute() method in the concrete command class.');
}











protected function interact(InputInterface $input, OutputInterface $output)
{
}










protected function initialize(InputInterface $input, OutputInterface $output)
{
}




















public function run(InputInterface $input, OutputInterface $output)
{

 $this->getSynopsis();


 $this->mergeApplicationDefinition();


 try {
$input->bind($this->definition);
} catch (\Exception $e) {
if (!$this->ignoreValidationErrors) {
throw $e;
}
}

$this->initialize($input, $output);

if (null !== $this->processTitle) {
if (function_exists('cli_set_process_title')) {
cli_set_process_title($this->processTitle);
} elseif (function_exists('setproctitle')) {
setproctitle($this->processTitle);
} elseif (OutputInterface::VERBOSITY_VERY_VERBOSE === $output->getVerbosity()) {
$output->writeln('<comment>Install the proctitle PECL to be able to change the process title.</comment>');
}
}

if ($input->isInteractive()) {
$this->interact($input, $output);
}

$input->validate();

if ($this->code) {
$statusCode = call_user_func($this->code, $input, $output);
} else {
$statusCode = $this->execute($input, $output);
}

return is_numeric($statusCode) ? (int) $statusCode : 0;
}

















public function setCode($code)
{
if (!is_callable($code)) {
throw new \InvalidArgumentException('Invalid callable provided to Command::setCode.');
}

$this->code = $code;

return $this;
}








public function mergeApplicationDefinition($mergeArgs = true)
{
if (null === $this->application || (true === $this->applicationDefinitionMerged && ($this->applicationDefinitionMergedWithArgs || !$mergeArgs))) {
return;
}

if ($mergeArgs) {
$currentArguments = $this->definition->getArguments();
$this->definition->setArguments($this->application->getDefinition()->getArguments());
$this->definition->addArguments($currentArguments);
}

$this->definition->addOptions($this->application->getDefinition()->getOptions());

$this->applicationDefinitionMerged = true;
if ($mergeArgs) {
$this->applicationDefinitionMergedWithArgs = true;
}
}










public function setDefinition($definition)
{
if ($definition instanceof InputDefinition) {
$this->definition = $definition;
} else {
$this->definition->setDefinition($definition);
}

$this->applicationDefinitionMerged = false;

return $this;
}








public function getDefinition()
{
return $this->definition;
}











public function getNativeDefinition()
{
return $this->getDefinition();
}













public function addArgument($name, $mode = null, $description = '', $default = null)
{
$this->definition->addArgument(new InputArgument($name, $mode, $description, $default));

return $this;
}














public function addOption($name, $shortcut = null, $mode = null, $description = '', $default = null)
{
$this->definition->addOption(new InputOption($name, $shortcut, $mode, $description, $default));

return $this;
}

















public function setName($name)
{
$this->validateName($name);

$this->name = $name;

return $this;
}













public function setProcessTitle($title)
{
$this->processTitle = $title;

return $this;
}








public function getName()
{
return $this->name;
}










public function setDescription($description)
{
$this->description = $description;

return $this;
}








public function getDescription()
{
return $this->description;
}










public function setHelp($help)
{
$this->help = $help;

return $this;
}








public function getHelp()
{
return $this->help;
}







public function getProcessedHelp()
{
$name = $this->name;

$placeholders = array(
'%command.name%',
'%command.full_name%',
);
$replacements = array(
$name,
$_SERVER['PHP_SELF'].' '.$name,
);

return str_replace($placeholders, $replacements, $this->getHelp());
}












public function setAliases($aliases)
{
if (!is_array($aliases) && !$aliases instanceof \Traversable) {
throw new \InvalidArgumentException('$aliases must be an array or an instance of \Traversable');
}

foreach ($aliases as $alias) {
$this->validateName($alias);
}

$this->aliases = $aliases;

return $this;
}








public function getAliases()
{
return $this->aliases;
}






public function getSynopsis()
{
if (null === $this->synopsis) {
$this->synopsis = trim(sprintf('%s %s', $this->name, $this->definition->getSynopsis()));
}

return $this->synopsis;
}












public function getHelper($name)
{
return $this->helperSet->get($name);
}








public function asText()
{
$descriptor = new TextDescriptor();
$output = new BufferedOutput(BufferedOutput::VERBOSITY_NORMAL, true);
$descriptor->describe($output, $this, array('raw_output' => true));

return $output->fetch();
}










public function asXml($asDom = false)
{
$descriptor = new XmlDescriptor();

if ($asDom) {
return $descriptor->getCommandDocument($this);
}

$output = new BufferedOutput();
$descriptor->describe($output, $this);

return $output->fetch();
}










private function validateName($name)
{
if (!preg_match('/^[^\:]++(\:[^\:]++)*$/', $name)) {
throw new \InvalidArgumentException(sprintf('Command name "%s" is invalid.', $name));
}
}
}
<?php










namespace Symfony\Component\Console\Command;

use Symfony\Component\Console\Helper\DescriptorHelper;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;






class HelpCommand extends Command
{
private $command;




protected function configure()
{
$this->ignoreValidationErrors();

$this
->setName('help')
->setDefinition(array(
new InputArgument('command_name', InputArgument::OPTIONAL, 'The command name', 'help'),
new InputOption('xml', null, InputOption::VALUE_NONE, 'To output help as XML'),
new InputOption('format', null, InputOption::VALUE_REQUIRED, 'To output help in other formats', 'txt'),
new InputOption('raw', null, InputOption::VALUE_NONE, 'To output raw command help'),
))
->setDescription('Displays help for a command')
->setHelp(<<<EOF
The <info>%command.name%</info> command displays help for a given command:

  <info>php %command.full_name% list</info>

You can also output the help in other formats by using the <comment>--format</comment> option:

  <info>php %command.full_name% --format=xml list</info>

To display the list of available commands, please use the <info>list</info> command.
EOF
)
;
}






public function setCommand(Command $command)
{
$this->command = $command;
}




protected function execute(InputInterface $input, OutputInterface $output)
{
if (null === $this->command) {
$this->command = $this->getApplication()->find($input->getArgument('command_name'));
}

if ($input->getOption('xml')) {
$input->setOption('format', 'xml');
}

$helper = new DescriptorHelper();
$helper->describe($output, $this->command, array(
'format' => $input->getOption('format'),
'raw_text' => $input->getOption('raw'),
));

$this->command = null;
}
}
<?php










namespace Symfony\Component\Console\Command;

use Symfony\Component\Console\Helper\DescriptorHelper;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Input\InputDefinition;






class ListCommand extends Command
{



protected function configure()
{
$this
->setName('list')
->setDefinition($this->createDefinition())
->setDescription('Lists commands')
->setHelp(<<<EOF
The <info>%command.name%</info> command lists all commands:

  <info>php %command.full_name%</info>

You can also display the commands for a specific namespace:

  <info>php %command.full_name% test</info>

You can also output the information in other formats by using the <comment>--format</comment> option:

  <info>php %command.full_name% --format=xml</info>

It's also possible to get raw list of commands (useful for embedding command runner):

  <info>php %command.full_name% --raw</info>
EOF
)
;
}




public function getNativeDefinition()
{
return $this->createDefinition();
}




protected function execute(InputInterface $input, OutputInterface $output)
{
if ($input->getOption('xml')) {
$input->setOption('format', 'xml');
}

$helper = new DescriptorHelper();
$helper->describe($output, $this->getApplication(), array(
'format' => $input->getOption('format'),
'raw_text' => $input->getOption('raw'),
'namespace' => $input->getArgument('namespace'),
));
}




private function createDefinition()
{
return new InputDefinition(array(
new InputArgument('namespace', InputArgument::OPTIONAL, 'The namespace name'),
new InputOption('xml', null, InputOption::VALUE_NONE, 'To output list as XML'),
new InputOption('raw', null, InputOption::VALUE_NONE, 'To output raw command list'),
new InputOption('format', null, InputOption::VALUE_REQUIRED, 'To output list in other formats', 'txt'),
));
}
}
<?php










namespace Symfony\Component\Console;






final class ConsoleEvents
{












const COMMAND = 'console.command';












const TERMINATE = 'console.terminate';













const EXCEPTION = 'console.exception';
}
<?php










namespace Symfony\Component\Console\Descriptor;

use Symfony\Component\Console\Application;
use Symfony\Component\Console\Command\Command;






class ApplicationDescription
{
const GLOBAL_NAMESPACE = '_global';




private $application;




private $namespace;




private $namespaces;




private $commands;




private $aliases;







public function __construct(Application $application, $namespace = null)
{
$this->application = $application;
$this->namespace = $namespace;
}




public function getNamespaces()
{
if (null === $this->namespaces) {
$this->inspectApplication();
}

return $this->namespaces;
}




public function getCommands()
{
if (null === $this->commands) {
$this->inspectApplication();
}

return $this->commands;
}








public function getCommand($name)
{
if (!isset($this->commands[$name]) && !isset($this->aliases[$name])) {
throw new \InvalidArgumentException(sprintf('Command %s does not exist.', $name));
}

return isset($this->commands[$name]) ? $this->commands[$name] : $this->aliases[$name];
}

private function inspectApplication()
{
$this->commands = array();
$this->namespaces = array();

$all = $this->application->all($this->namespace ? $this->application->findNamespace($this->namespace) : null);
foreach ($this->sortCommands($all) as $namespace => $commands) {
$names = array();


foreach ($commands as $name => $command) {
if (!$command->getName()) {
continue;
}

if ($command->getName() === $name) {
$this->commands[$name] = $command;
} else {
$this->aliases[$name] = $command;
}

$names[] = $name;
}

$this->namespaces[$namespace] = array('id' => $namespace, 'commands' => $names);
}
}






private function sortCommands(array $commands)
{
$namespacedCommands = array();
foreach ($commands as $name => $command) {
$key = $this->application->extractNamespace($name, 1);
if (!$key) {
$key = '_global';
}

$namespacedCommands[$key][$name] = $command;
}
ksort($namespacedCommands);

foreach ($namespacedCommands as &$commands) {
ksort($commands);
}

return $namespacedCommands;
}
}
<?php










namespace Symfony\Component\Console\Descriptor;

use Symfony\Component\Console\Application;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputDefinition;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;






abstract class Descriptor implements DescriptorInterface
{



private $output;




public function describe(OutputInterface $output, $object, array $options = array())
{
$this->output = $output;

switch (true) {
case $object instanceof InputArgument:
$this->describeInputArgument($object, $options);
break;
case $object instanceof InputOption:
$this->describeInputOption($object, $options);
break;
case $object instanceof InputDefinition:
$this->describeInputDefinition($object, $options);
break;
case $object instanceof Command:
$this->describeCommand($object, $options);
break;
case $object instanceof Application:
$this->describeApplication($object, $options);
break;
default:
throw new \InvalidArgumentException(sprintf('Object of type "%s" is not describable.', get_class($object)));
}
}







protected function write($content, $decorated = false)
{
$this->output->write($content, false, $decorated ? OutputInterface::OUTPUT_NORMAL : OutputInterface::OUTPUT_RAW);
}









abstract protected function describeInputArgument(InputArgument $argument, array $options = array());









abstract protected function describeInputOption(InputOption $option, array $options = array());









abstract protected function describeInputDefinition(InputDefinition $definition, array $options = array());









abstract protected function describeCommand(Command $command, array $options = array());









abstract protected function describeApplication(Application $application, array $options = array());
}
<?php










namespace Symfony\Component\Console\Descriptor;

use Symfony\Component\Console\Output\OutputInterface;






interface DescriptorInterface
{







public function describe(OutputInterface $output, $object, array $options = array());
}
<?php










namespace Symfony\Component\Console\Descriptor;

use Symfony\Component\Console\Application;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputDefinition;
use Symfony\Component\Console\Input\InputOption;








class JsonDescriptor extends Descriptor
{



protected function describeInputArgument(InputArgument $argument, array $options = array())
{
$this->writeData($this->getInputArgumentData($argument), $options);
}




protected function describeInputOption(InputOption $option, array $options = array())
{
$this->writeData($this->getInputOptionData($option), $options);
}




protected function describeInputDefinition(InputDefinition $definition, array $options = array())
{
$this->writeData($this->getInputDefinitionData($definition), $options);
}




protected function describeCommand(Command $command, array $options = array())
{
$this->writeData($this->getCommandData($command), $options);
}




protected function describeApplication(Application $application, array $options = array())
{
$describedNamespace = isset($options['namespace']) ? $options['namespace'] : null;
$description = new ApplicationDescription($application, $describedNamespace);
$commands = array();

foreach ($description->getCommands() as $command) {
$commands[] = $this->getCommandData($command);
}

$data = $describedNamespace
? array('commands' => $commands, 'namespace' => $describedNamespace)
: array('commands' => $commands, 'namespaces' => array_values($description->getNamespaces()));

$this->writeData($data, $options);
}









private function writeData(array $data, array $options)
{
$this->write(json_encode($data, isset($options['json_encoding']) ? $options['json_encoding'] : 0));
}






private function getInputArgumentData(InputArgument $argument)
{
return array(
'name' => $argument->getName(),
'is_required' => $argument->isRequired(),
'is_array' => $argument->isArray(),
'description' => $argument->getDescription(),
'default' => $argument->getDefault(),
);
}






private function getInputOptionData(InputOption $option)
{
return array(
'name' => '--'.$option->getName(),
'shortcut' => $option->getShortcut() ? '-'.implode('|-', explode('|', $option->getShortcut())) : '',
'accept_value' => $option->acceptValue(),
'is_value_required' => $option->isValueRequired(),
'is_multiple' => $option->isArray(),
'description' => $option->getDescription(),
'default' => $option->getDefault(),
);
}






private function getInputDefinitionData(InputDefinition $definition)
{
$inputArguments = array();
foreach ($definition->getArguments() as $name => $argument) {
$inputArguments[$name] = $this->getInputArgumentData($argument);
}

$inputOptions = array();
foreach ($definition->getOptions() as $name => $option) {
$inputOptions[$name] = $this->getInputOptionData($option);
}

return array('arguments' => $inputArguments, 'options' => $inputOptions);
}






private function getCommandData(Command $command)
{
$command->getSynopsis();
$command->mergeApplicationDefinition(false);

return array(
'name' => $command->getName(),
'usage' => $command->getSynopsis(),
'description' => $command->getDescription(),
'help' => $command->getProcessedHelp(),
'aliases' => $command->getAliases(),
'definition' => $this->getInputDefinitionData($command->getNativeDefinition()),
);
}
}
<?php










namespace Symfony\Component\Console\Descriptor;

use Symfony\Component\Console\Application;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputDefinition;
use Symfony\Component\Console\Input\InputOption;








class MarkdownDescriptor extends Descriptor
{



protected function describeInputArgument(InputArgument $argument, array $options = array())
{
$this->write(
'**'.$argument->getName().':**'."\n\n"
.'* Name: '.($argument->getName() ?: '<none>')."\n"
.'* Is required: '.($argument->isRequired() ? 'yes' : 'no')."\n"
.'* Is array: '.($argument->isArray() ? 'yes' : 'no')."\n"
.'* Description: '.($argument->getDescription() ?: '<none>')."\n"
.'* Default: `'.str_replace("\n", '', var_export($argument->getDefault(), true)).'`'
);
}




protected function describeInputOption(InputOption $option, array $options = array())
{
$this->write(
'**'.$option->getName().':**'."\n\n"
.'* Name: `--'.$option->getName().'`'."\n"
.'* Shortcut: '.($option->getShortcut() ? '`-'.implode('|-', explode('|', $option->getShortcut())).'`' : '<none>')."\n"
.'* Accept value: '.($option->acceptValue() ? 'yes' : 'no')."\n"
.'* Is value required: '.($option->isValueRequired() ? 'yes' : 'no')."\n"
.'* Is multiple: '.($option->isArray() ? 'yes' : 'no')."\n"
.'* Description: '.($option->getDescription() ?: '<none>')."\n"
.'* Default: `'.str_replace("\n", '', var_export($option->getDefault(), true)).'`'
);
}




protected function describeInputDefinition(InputDefinition $definition, array $options = array())
{
if ($showArguments = count($definition->getArguments()) > 0) {
$this->write('### Arguments:');
foreach ($definition->getArguments() as $argument) {
$this->write("\n\n");
$this->write($this->describeInputArgument($argument));
}
}

if (count($definition->getOptions()) > 0) {
if ($showArguments) {
$this->write("\n\n");
}

$this->write('### Options:');
foreach ($definition->getOptions() as $option) {
$this->write("\n\n");
$this->write($this->describeInputOption($option));
}
}
}




protected function describeCommand(Command $command, array $options = array())
{
$command->getSynopsis();
$command->mergeApplicationDefinition(false);

$this->write(
$command->getName()."\n"
.str_repeat('-', strlen($command->getName()))."\n\n"
.'* Description: '.($command->getDescription() ?: '<none>')."\n"
.'* Usage: `'.$command->getSynopsis().'`'."\n"
.'* Aliases: '.(count($command->getAliases()) ? '`'.implode('`, `', $command->getAliases()).'`' : '<none>')
);

if ($help = $command->getProcessedHelp()) {
$this->write("\n\n");
$this->write($help);
}

if ($command->getNativeDefinition()) {
$this->write("\n\n");
$this->describeInputDefinition($command->getNativeDefinition());
}
}




protected function describeApplication(Application $application, array $options = array())
{
$describedNamespace = isset($options['namespace']) ? $options['namespace'] : null;
$description = new ApplicationDescription($application, $describedNamespace);

$this->write($application->getName()."\n".str_repeat('=', strlen($application->getName())));

foreach ($description->getNamespaces() as $namespace) {
if (ApplicationDescription::GLOBAL_NAMESPACE !== $namespace['id']) {
$this->write("\n\n");
$this->write('**'.$namespace['id'].':**');
}

$this->write("\n\n");
$this->write(implode("\n", array_map(function ($commandName) {
return '* '.$commandName;
}, $namespace['commands'])));
}

foreach ($description->getCommands() as $command) {
$this->write("\n\n");
$this->write($this->describeCommand($command));
}
}
}
<?php










namespace Symfony\Component\Console\Descriptor;

use Symfony\Component\Console\Application;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputDefinition;
use Symfony\Component\Console\Input\InputOption;








class TextDescriptor extends Descriptor
{



protected function describeInputArgument(InputArgument $argument, array $options = array())
{
if (null !== $argument->getDefault() && (!is_array($argument->getDefault()) || count($argument->getDefault()))) {
$default = sprintf('<comment> (default: %s)</comment>', $this->formatDefaultValue($argument->getDefault()));
} else {
$default = '';
}

$nameWidth = isset($options['name_width']) ? $options['name_width'] : strlen($argument->getName());

$this->writeText(sprintf(" <info>%-${nameWidth}s</info> %s%s",
$argument->getName(),
str_replace("\n", "\n".str_repeat(' ', $nameWidth + 2), $argument->getDescription()),
$default
), $options);
}




protected function describeInputOption(InputOption $option, array $options = array())
{
if ($option->acceptValue() && null !== $option->getDefault() && (!is_array($option->getDefault()) || count($option->getDefault()))) {
$default = sprintf('<comment> (default: %s)</comment>', $this->formatDefaultValue($option->getDefault()));
} else {
$default = '';
}

$nameWidth = isset($options['name_width']) ? $options['name_width'] : strlen($option->getName());
$nameWithShortcutWidth = $nameWidth - strlen($option->getName()) - 2;

$this->writeText(sprintf(" <info>%s</info> %-${nameWithShortcutWidth}s%s%s%s",
'--'.$option->getName(),
$option->getShortcut() ? sprintf('(-%s) ', $option->getShortcut()) : '',
str_replace("\n", "\n".str_repeat(' ', $nameWidth + 2), $option->getDescription()),
$default,
$option->isArray() ? '<comment> (multiple values allowed)</comment>' : ''
), $options);
}




protected function describeInputDefinition(InputDefinition $definition, array $options = array())
{
$nameWidth = 0;
foreach ($definition->getOptions() as $option) {
$nameLength = strlen($option->getName()) + 2;
if ($option->getShortcut()) {
$nameLength += strlen($option->getShortcut()) + 3;
}
$nameWidth = max($nameWidth, $nameLength);
}
foreach ($definition->getArguments() as $argument) {
$nameWidth = max($nameWidth, strlen($argument->getName()));
}
++$nameWidth;

if ($definition->getArguments()) {
$this->writeText('<comment>Arguments:</comment>', $options);
$this->writeText("\n");
foreach ($definition->getArguments() as $argument) {
$this->describeInputArgument($argument, array_merge($options, array('name_width' => $nameWidth)));
$this->writeText("\n");
}
}

if ($definition->getArguments() && $definition->getOptions()) {
$this->writeText("\n");
}

if ($definition->getOptions()) {
$this->writeText('<comment>Options:</comment>', $options);
$this->writeText("\n");
foreach ($definition->getOptions() as $option) {
$this->describeInputOption($option, array_merge($options, array('name_width' => $nameWidth)));
$this->writeText("\n");
}
}
}




protected function describeCommand(Command $command, array $options = array())
{
$command->getSynopsis();
$command->mergeApplicationDefinition(false);

$this->writeText('<comment>Usage:</comment>', $options);
$this->writeText("\n");
$this->writeText(' '.$command->getSynopsis(), $options);
$this->writeText("\n");

if (count($command->getAliases()) > 0) {
$this->writeText("\n");
$this->writeText('<comment>Aliases:</comment> <info>'.implode(', ', $command->getAliases()).'</info>', $options);
}

if ($definition = $command->getNativeDefinition()) {
$this->writeText("\n");
$this->describeInputDefinition($definition, $options);
}

$this->writeText("\n");

if ($help = $command->getProcessedHelp()) {
$this->writeText('<comment>Help:</comment>', $options);
$this->writeText("\n");
$this->writeText(' '.str_replace("\n", "\n ", $help), $options);
$this->writeText("\n");
}
}




protected function describeApplication(Application $application, array $options = array())
{
$describedNamespace = isset($options['namespace']) ? $options['namespace'] : null;
$description = new ApplicationDescription($application, $describedNamespace);

if (isset($options['raw_text']) && $options['raw_text']) {
$width = $this->getColumnWidth($description->getCommands());

foreach ($description->getCommands() as $command) {
$this->writeText(sprintf("%-${width}s %s", $command->getName(), $command->getDescription()), $options);
$this->writeText("\n");
}
} else {
if ('' != $help = $application->getHelp()) {
$this->writeText("$help\n\n", $options);
}

$this->writeText("<comment>Usage:</comment>\n", $options);
$this->writeText(" command [options] [arguments]\n\n", $options);
$this->writeText('<comment>Options:</comment>', $options);

$inputOptions = $application->getDefinition()->getOptions();

$width = 0;
foreach ($inputOptions as $option) {
$nameLength = strlen($option->getName()) + 2;
if ($option->getShortcut()) {
$nameLength += strlen($option->getShortcut()) + 3;
}
$width = max($width, $nameLength);
}
++$width;

foreach ($inputOptions as $option) {
$this->writeText("\n", $options);
$this->describeInputOption($option, array_merge($options, array('name_width' => $width)));
}

$this->writeText("\n\n", $options);

$width = $this->getColumnWidth($description->getCommands());

if ($describedNamespace) {
$this->writeText(sprintf("<comment>Available commands for the \"%s\" namespace:</comment>", $describedNamespace), $options);
} else {
$this->writeText('<comment>Available commands:</comment>', $options);
}


 foreach ($description->getNamespaces() as $namespace) {
if (!$describedNamespace && ApplicationDescription::GLOBAL_NAMESPACE !== $namespace['id']) {
$this->writeText("\n");
$this->writeText('<comment>'.$namespace['id'].'</comment>', $options);
}

foreach ($namespace['commands'] as $name) {
$this->writeText("\n");
$this->writeText(sprintf(" <info>%-${width}s</info> %s", $name, $description->getCommand($name)->getDescription()), $options);
}
}

$this->writeText("\n");
}
}




private function writeText($content, array $options = array())
{
$this->write(
isset($options['raw_text']) && $options['raw_text'] ? strip_tags($content) : $content,
isset($options['raw_output']) ? !$options['raw_output'] : true
);
}








private function formatDefaultValue($default)
{
if (PHP_VERSION_ID < 50400) {
return str_replace('\/', '/', json_encode($default));
}

return json_encode($default, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
}






private function getColumnWidth(array $commands)
{
$width = 0;
foreach ($commands as $command) {
$width = strlen($command->getName()) > $width ? strlen($command->getName()) : $width;
}

return $width + 2;
}
}
<?php










namespace Symfony\Component\Console\Descriptor;

use Symfony\Component\Console\Application;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputDefinition;
use Symfony\Component\Console\Input\InputOption;








class XmlDescriptor extends Descriptor
{





public function getInputDefinitionDocument(InputDefinition $definition)
{
$dom = new \DOMDocument('1.0', 'UTF-8');
$dom->appendChild($definitionXML = $dom->createElement('definition'));

$definitionXML->appendChild($argumentsXML = $dom->createElement('arguments'));
foreach ($definition->getArguments() as $argument) {
$this->appendDocument($argumentsXML, $this->getInputArgumentDocument($argument));
}

$definitionXML->appendChild($optionsXML = $dom->createElement('options'));
foreach ($definition->getOptions() as $option) {
$this->appendDocument($optionsXML, $this->getInputOptionDocument($option));
}

return $dom;
}






public function getCommandDocument(Command $command)
{
$dom = new \DOMDocument('1.0', 'UTF-8');
$dom->appendChild($commandXML = $dom->createElement('command'));

$command->getSynopsis();
$command->mergeApplicationDefinition(false);

$commandXML->setAttribute('id', $command->getName());
$commandXML->setAttribute('name', $command->getName());

$commandXML->appendChild($usageXML = $dom->createElement('usage'));
$usageXML->appendChild($dom->createTextNode(sprintf($command->getSynopsis(), '')));

$commandXML->appendChild($descriptionXML = $dom->createElement('description'));
$descriptionXML->appendChild($dom->createTextNode(str_replace("\n", "\n ", $command->getDescription())));

$commandXML->appendChild($helpXML = $dom->createElement('help'));
$helpXML->appendChild($dom->createTextNode(str_replace("\n", "\n ", $command->getProcessedHelp())));

$commandXML->appendChild($aliasesXML = $dom->createElement('aliases'));
foreach ($command->getAliases() as $alias) {
$aliasesXML->appendChild($aliasXML = $dom->createElement('alias'));
$aliasXML->appendChild($dom->createTextNode($alias));
}

$definitionXML = $this->getInputDefinitionDocument($command->getNativeDefinition());
$this->appendDocument($commandXML, $definitionXML->getElementsByTagName('definition')->item(0));

return $dom;
}







public function getApplicationDocument(Application $application, $namespace = null)
{
$dom = new \DOMDocument('1.0', 'UTF-8');
$dom->appendChild($rootXml = $dom->createElement('symfony'));

if ($application->getName() !== 'UNKNOWN') {
$rootXml->setAttribute('name', $application->getName());
if ($application->getVersion() !== 'UNKNOWN') {
$rootXml->setAttribute('version', $application->getVersion());
}
}

$rootXml->appendChild($commandsXML = $dom->createElement('commands'));

$description = new ApplicationDescription($application, $namespace);

if ($namespace) {
$commandsXML->setAttribute('namespace', $namespace);
}

foreach ($description->getCommands() as $command) {
$this->appendDocument($commandsXML, $this->getCommandDocument($command));
}

if (!$namespace) {
$rootXml->appendChild($namespacesXML = $dom->createElement('namespaces'));

foreach ($description->getNamespaces() as $namespaceDescription) {
$namespacesXML->appendChild($namespaceArrayXML = $dom->createElement('namespace'));
$namespaceArrayXML->setAttribute('id', $namespaceDescription['id']);

foreach ($namespaceDescription['commands'] as $name) {
$namespaceArrayXML->appendChild($commandXML = $dom->createElement('command'));
$commandXML->appendChild($dom->createTextNode($name));
}
}
}

return $dom;
}




protected function describeInputArgument(InputArgument $argument, array $options = array())
{
$this->writeDocument($this->getInputArgumentDocument($argument));
}




protected function describeInputOption(InputOption $option, array $options = array())
{
$this->writeDocument($this->getInputOptionDocument($option));
}




protected function describeInputDefinition(InputDefinition $definition, array $options = array())
{
$this->writeDocument($this->getInputDefinitionDocument($definition));
}




protected function describeCommand(Command $command, array $options = array())
{
$this->writeDocument($this->getCommandDocument($command));
}




protected function describeApplication(Application $application, array $options = array())
{
$this->writeDocument($this->getApplicationDocument($application, isset($options['namespace']) ? $options['namespace'] : null));
}







private function appendDocument(\DOMNode $parentNode, \DOMNode $importedParent)
{
foreach ($importedParent->childNodes as $childNode) {
$parentNode->appendChild($parentNode->ownerDocument->importNode($childNode, true));
}
}








private function writeDocument(\DOMDocument $dom)
{
$dom->formatOutput = true;
$this->write($dom->saveXML());
}






private function getInputArgumentDocument(InputArgument $argument)
{
$dom = new \DOMDocument('1.0', 'UTF-8');

$dom->appendChild($objectXML = $dom->createElement('argument'));
$objectXML->setAttribute('name', $argument->getName());
$objectXML->setAttribute('is_required', $argument->isRequired() ? 1 : 0);
$objectXML->setAttribute('is_array', $argument->isArray() ? 1 : 0);
$objectXML->appendChild($descriptionXML = $dom->createElement('description'));
$descriptionXML->appendChild($dom->createTextNode($argument->getDescription()));

$objectXML->appendChild($defaultsXML = $dom->createElement('defaults'));
$defaults = is_array($argument->getDefault()) ? $argument->getDefault() : (is_bool($argument->getDefault()) ? array(var_export($argument->getDefault(), true)) : ($argument->getDefault() ? array($argument->getDefault()) : array()));
foreach ($defaults as $default) {
$defaultsXML->appendChild($defaultXML = $dom->createElement('default'));
$defaultXML->appendChild($dom->createTextNode($default));
}

return $dom;
}






private function getInputOptionDocument(InputOption $option)
{
$dom = new \DOMDocument('1.0', 'UTF-8');

$dom->appendChild($objectXML = $dom->createElement('option'));
$objectXML->setAttribute('name', '--'.$option->getName());
$pos = strpos($option->getShortcut(), '|');
if (false !== $pos) {
$objectXML->setAttribute('shortcut', '-'.substr($option->getShortcut(), 0, $pos));
$objectXML->setAttribute('shortcuts', '-'.implode('|-', explode('|', $option->getShortcut())));
} else {
$objectXML->setAttribute('shortcut', $option->getShortcut() ? '-'.$option->getShortcut() : '');
}
$objectXML->setAttribute('accept_value', $option->acceptValue() ? 1 : 0);
$objectXML->setAttribute('is_value_required', $option->isValueRequired() ? 1 : 0);
$objectXML->setAttribute('is_multiple', $option->isArray() ? 1 : 0);
$objectXML->appendChild($descriptionXML = $dom->createElement('description'));
$descriptionXML->appendChild($dom->createTextNode($option->getDescription()));

if ($option->acceptValue()) {
$defaults = is_array($option->getDefault()) ? $option->getDefault() : (is_bool($option->getDefault()) ? array(var_export($option->getDefault(), true)) : ($option->getDefault() ? array($option->getDefault()) : array()));
$objectXML->appendChild($defaultsXML = $dom->createElement('defaults'));

if (!empty($defaults)) {
foreach ($defaults as $default) {
$defaultsXML->appendChild($defaultXML = $dom->createElement('default'));
$defaultXML->appendChild($dom->createTextNode($default));
}
}
}

return $dom;
}
}
<?php










namespace Symfony\Component\Console\Event;






class ConsoleCommandEvent extends ConsoleEvent
{



const RETURN_CODE_DISABLED = 113;






private $commandShouldRun = true;






public function disableCommand()
{
return $this->commandShouldRun = false;
}






public function enableCommand()
{
return $this->commandShouldRun = true;
}






public function commandShouldRun()
{
return $this->commandShouldRun;
}
}
<?php










namespace Symfony\Component\Console\Event;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\EventDispatcher\Event;






class ConsoleEvent extends Event
{
protected $command;

private $input;
private $output;

public function __construct(Command $command, InputInterface $input, OutputInterface $output)
{
$this->command = $command;
$this->input = $input;
$this->output = $output;
}






public function getCommand()
{
return $this->command;
}






public function getInput()
{
return $this->input;
}






public function getOutput()
{
return $this->output;
}
}
<?php










namespace Symfony\Component\Console\Event;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;






class ConsoleExceptionEvent extends ConsoleEvent
{
private $exception;
private $exitCode;

public function __construct(Command $command, InputInterface $input, OutputInterface $output, \Exception $exception, $exitCode)
{
parent::__construct($command, $input, $output);

$this->setException($exception);
$this->exitCode = (int) $exitCode;
}






public function getException()
{
return $this->exception;
}








public function setException(\Exception $exception)
{
$this->exception = $exception;
}






public function getExitCode()
{
return $this->exitCode;
}
}
<?php










namespace Symfony\Component\Console\Event;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;






class ConsoleTerminateEvent extends ConsoleEvent
{





private $exitCode;

public function __construct(Command $command, InputInterface $input, OutputInterface $output, $exitCode)
{
parent::__construct($command, $input, $output);

$this->setExitCode($exitCode);
}






public function setExitCode($exitCode)
{
$this->exitCode = (int) $exitCode;
}






public function getExitCode()
{
return $this->exitCode;
}
}
<?php










namespace Symfony\Component\Console\Formatter;








class OutputFormatter implements OutputFormatterInterface
{
private $decorated;
private $styles = array();
private $styleStack;








public static function escape($text)
{
return preg_replace('/([^\\\\]?)</is', '$1\\<', $text);
}









public function __construct($decorated = false, array $styles = array())
{
$this->decorated = (bool) $decorated;

$this->setStyle('error', new OutputFormatterStyle('white', 'red'));
$this->setStyle('info', new OutputFormatterStyle('green'));
$this->setStyle('comment', new OutputFormatterStyle('yellow'));
$this->setStyle('question', new OutputFormatterStyle('black', 'cyan'));

foreach ($styles as $name => $style) {
$this->setStyle($name, $style);
}

$this->styleStack = new OutputFormatterStyleStack();
}








public function setDecorated($decorated)
{
$this->decorated = (bool) $decorated;
}








public function isDecorated()
{
return $this->decorated;
}









public function setStyle($name, OutputFormatterStyleInterface $style)
{
$this->styles[strtolower($name)] = $style;
}










public function hasStyle($name)
{
return isset($this->styles[strtolower($name)]);
}












public function getStyle($name)
{
if (!$this->hasStyle($name)) {
throw new \InvalidArgumentException(sprintf('Undefined style: %s', $name));
}

return $this->styles[strtolower($name)];
}










public function format($message)
{
$offset = 0;
$output = '';
$tagRegex = '[a-z][a-z0-9_=;-]*';
preg_match_all("#<(($tagRegex) | /($tagRegex)?)>#isx", $message, $matches, PREG_OFFSET_CAPTURE);
foreach ($matches[0] as $i => $match) {
$pos = $match[1];
$text = $match[0];

if (0 != $pos && '\\' == $message[$pos - 1]) {
continue;
}


 $output .= $this->applyCurrentStyle(substr($message, $offset, $pos - $offset));
$offset = $pos + strlen($text);


 if ($open = '/' != $text[1]) {
$tag = $matches[1][$i][0];
} else {
$tag = isset($matches[3][$i][0]) ? $matches[3][$i][0] : '';
}

if (!$open && !$tag) {

 $this->styleStack->pop();
} elseif (false === $style = $this->createStyleFromString(strtolower($tag))) {
$output .= $this->applyCurrentStyle($text);
} elseif ($open) {
$this->styleStack->push($style);
} else {
$this->styleStack->pop($style);
}
}

$output .= $this->applyCurrentStyle(substr($message, $offset));

return str_replace('\\<', '<', $output);
}




public function getStyleStack()
{
return $this->styleStack;
}








private function createStyleFromString($string)
{
if (isset($this->styles[$string])) {
return $this->styles[$string];
}

if (!preg_match_all('/([^=]+)=([^;]+)(;|$)/', strtolower($string), $matches, PREG_SET_ORDER)) {
return false;
}

$style = new OutputFormatterStyle();
foreach ($matches as $match) {
array_shift($match);

if ('fg' == $match[0]) {
$style->setForeground($match[1]);
} elseif ('bg' == $match[0]) {
$style->setBackground($match[1]);
} else {
try {
$style->setOption($match[1]);
} catch (\InvalidArgumentException $e) {
return false;
}
}
}

return $style;
}








private function applyCurrentStyle($text)
{
return $this->isDecorated() && strlen($text) > 0 ? $this->styleStack->getCurrent()->apply($text) : $text;
}
}
<?php










namespace Symfony\Component\Console\Formatter;








interface OutputFormatterInterface
{







public function setDecorated($decorated);








public function isDecorated();









public function setStyle($name, OutputFormatterStyleInterface $style);










public function hasStyle($name);










public function getStyle($name);










public function format($message);
}
<?php










namespace Symfony\Component\Console\Formatter;








class OutputFormatterStyle implements OutputFormatterStyleInterface
{
private static $availableForegroundColors = array(
'black' => array('set' => 30, 'unset' => 39),
'red' => array('set' => 31, 'unset' => 39),
'green' => array('set' => 32, 'unset' => 39),
'yellow' => array('set' => 33, 'unset' => 39),
'blue' => array('set' => 34, 'unset' => 39),
'magenta' => array('set' => 35, 'unset' => 39),
'cyan' => array('set' => 36, 'unset' => 39),
'white' => array('set' => 37, 'unset' => 39),
);
private static $availableBackgroundColors = array(
'black' => array('set' => 40, 'unset' => 49),
'red' => array('set' => 41, 'unset' => 49),
'green' => array('set' => 42, 'unset' => 49),
'yellow' => array('set' => 43, 'unset' => 49),
'blue' => array('set' => 44, 'unset' => 49),
'magenta' => array('set' => 45, 'unset' => 49),
'cyan' => array('set' => 46, 'unset' => 49),
'white' => array('set' => 47, 'unset' => 49),
);
private static $availableOptions = array(
'bold' => array('set' => 1, 'unset' => 22),
'underscore' => array('set' => 4, 'unset' => 24),
'blink' => array('set' => 5, 'unset' => 25),
'reverse' => array('set' => 7, 'unset' => 27),
'conceal' => array('set' => 8, 'unset' => 28),
);

private $foreground;
private $background;
private $options = array();










public function __construct($foreground = null, $background = null, array $options = array())
{
if (null !== $foreground) {
$this->setForeground($foreground);
}
if (null !== $background) {
$this->setBackground($background);
}
if (count($options)) {
$this->setOptions($options);
}
}










public function setForeground($color = null)
{
if (null === $color) {
$this->foreground = null;

return;
}

if (!isset(static::$availableForegroundColors[$color])) {
throw new \InvalidArgumentException(sprintf(
'Invalid foreground color specified: "%s". Expected one of (%s)',
$color,
implode(', ', array_keys(static::$availableForegroundColors))
));
}

$this->foreground = static::$availableForegroundColors[$color];
}










public function setBackground($color = null)
{
if (null === $color) {
$this->background = null;

return;
}

if (!isset(static::$availableBackgroundColors[$color])) {
throw new \InvalidArgumentException(sprintf(
'Invalid background color specified: "%s". Expected one of (%s)',
$color,
implode(', ', array_keys(static::$availableBackgroundColors))
));
}

$this->background = static::$availableBackgroundColors[$color];
}










public function setOption($option)
{
if (!isset(static::$availableOptions[$option])) {
throw new \InvalidArgumentException(sprintf(
'Invalid option specified: "%s". Expected one of (%s)',
$option,
implode(', ', array_keys(static::$availableOptions))
));
}

if (!in_array(static::$availableOptions[$option], $this->options)) {
$this->options[] = static::$availableOptions[$option];
}
}








public function unsetOption($option)
{
if (!isset(static::$availableOptions[$option])) {
throw new \InvalidArgumentException(sprintf(
'Invalid option specified: "%s". Expected one of (%s)',
$option,
implode(', ', array_keys(static::$availableOptions))
));
}

$pos = array_search(static::$availableOptions[$option], $this->options);
if (false !== $pos) {
unset($this->options[$pos]);
}
}






public function setOptions(array $options)
{
$this->options = array();

foreach ($options as $option) {
$this->setOption($option);
}
}








public function apply($text)
{
$setCodes = array();
$unsetCodes = array();

if (null !== $this->foreground) {
$setCodes[] = $this->foreground['set'];
$unsetCodes[] = $this->foreground['unset'];
}
if (null !== $this->background) {
$setCodes[] = $this->background['set'];
$unsetCodes[] = $this->background['unset'];
}
if (count($this->options)) {
foreach ($this->options as $option) {
$setCodes[] = $option['set'];
$unsetCodes[] = $option['unset'];
}
}

if (0 === count($setCodes)) {
return $text;
}

return sprintf("\033[%sm%s\033[%sm", implode(';', $setCodes), $text, implode(';', $unsetCodes));
}
}
<?php










namespace Symfony\Component\Console\Formatter;








interface OutputFormatterStyleInterface
{







public function setForeground($color = null);








public function setBackground($color = null);








public function setOption($option);






public function unsetOption($option);






public function setOptions(array $options);








public function apply($text);
}
<?php










namespace Symfony\Component\Console\Formatter;




class OutputFormatterStyleStack
{



private $styles;




private $emptyStyle;






public function __construct(OutputFormatterStyleInterface $emptyStyle = null)
{
$this->emptyStyle = $emptyStyle ?: new OutputFormatterStyle();
$this->reset();
}




public function reset()
{
$this->styles = array();
}






public function push(OutputFormatterStyleInterface $style)
{
$this->styles[] = $style;
}










public function pop(OutputFormatterStyleInterface $style = null)
{
if (empty($this->styles)) {
return $this->emptyStyle;
}

if (null === $style) {
return array_pop($this->styles);
}

foreach (array_reverse($this->styles, true) as $index => $stackedStyle) {
if ($style->apply('') === $stackedStyle->apply('')) {
$this->styles = array_slice($this->styles, 0, $index);

return $stackedStyle;
}
}

throw new \InvalidArgumentException('Incorrectly nested style tag found.');
}






public function getCurrent()
{
if (empty($this->styles)) {
return $this->emptyStyle;
}

return $this->styles[count($this->styles) - 1];
}






public function setEmptyStyle(OutputFormatterStyleInterface $emptyStyle)
{
$this->emptyStyle = $emptyStyle;

return $this;
}




public function getEmptyStyle()
{
return $this->emptyStyle;
}
}
<?php










namespace Symfony\Component\Console\Helper;








class DebugFormatterHelper extends Helper
{
private $colors = array('black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white');
private $started = array();
private $count = -1;










public function start($id, $message, $prefix = 'RUN')
{
$this->started[$id] = array('border' => ++$this->count % count($this->colors));

return sprintf("%s<bg=blue;fg=white> %s </> <fg=blue>%s</>\n", $this->getBorder($id), $prefix, $message);
}












public function progress($id, $buffer, $error = false, $prefix = 'OUT', $errorPrefix = 'ERR')
{
$message = '';

if ($error) {
if (isset($this->started[$id]['out'])) {
$message .= "\n";
unset($this->started[$id]['out']);
}
if (!isset($this->started[$id]['err'])) {
$message .= sprintf("%s<bg=red;fg=white> %s </> ", $this->getBorder($id), $errorPrefix);
$this->started[$id]['err'] = true;
}

$message .= str_replace("\n", sprintf("\n%s<bg=red;fg=white> %s </> ", $this->getBorder($id), $errorPrefix), $buffer);
} else {
if (isset($this->started[$id]['err'])) {
$message .= "\n";
unset($this->started[$id]['err']);
}
if (!isset($this->started[$id]['out'])) {
$message .= sprintf("%s<bg=green;fg=white> %s </> ", $this->getBorder($id), $prefix);
$this->started[$id]['out'] = true;
}

$message .= str_replace("\n", sprintf("\n%s<bg=green;fg=white> %s </> ", $this->getBorder($id), $prefix), $buffer);
}

return $message;
}











public function stop($id, $message, $successful, $prefix = 'RES')
{
$trailingEOL = isset($this->started[$id]['out']) || isset($this->started[$id]['err']) ? "\n" : '';

if ($successful) {
return sprintf("%s%s<bg=green;fg=white> %s </> <fg=green>%s</>\n", $trailingEOL, $this->getBorder($id), $prefix, $message);
}

$message = sprintf("%s%s<bg=red;fg=white> %s </> <fg=red>%s</>\n", $trailingEOL, $this->getBorder($id), $prefix, $message);

unset($this->started[$id]['out'], $this->started[$id]['err']);

return $message;
}






private function getBorder($id)
{
return sprintf('<bg=%s> </>', $this->colors[$this->started[$id]['border']]);
}




public function getName()
{
return 'debug_formatter';
}
}
<?php










namespace Symfony\Component\Console\Helper;

use Symfony\Component\Console\Descriptor\DescriptorInterface;
use Symfony\Component\Console\Descriptor\JsonDescriptor;
use Symfony\Component\Console\Descriptor\MarkdownDescriptor;
use Symfony\Component\Console\Descriptor\TextDescriptor;
use Symfony\Component\Console\Descriptor\XmlDescriptor;
use Symfony\Component\Console\Output\OutputInterface;






class DescriptorHelper extends Helper
{



private $descriptors = array();




public function __construct()
{
$this
->register('txt', new TextDescriptor())
->register('xml', new XmlDescriptor())
->register('json', new JsonDescriptor())
->register('md', new MarkdownDescriptor())
;
}














public function describe(OutputInterface $output, $object, array $options = array())
{
$options = array_merge(array(
'raw_text' => false,
'format' => 'txt',
), $options);

if (!isset($this->descriptors[$options['format']])) {
throw new \InvalidArgumentException(sprintf('Unsupported format "%s".', $options['format']));
}

$descriptor = $this->descriptors[$options['format']];
$descriptor->describe($output, $object, $options);
}









public function register($format, DescriptorInterface $descriptor)
{
$this->descriptors[$format] = $descriptor;

return $this;
}




public function getName()
{
return 'descriptor';
}
}
<?php










namespace Symfony\Component\Console\Helper;

use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Formatter\OutputFormatterStyle;









class DialogHelper extends InputAwareHelper
{
private $inputStream;
private static $shell;
private static $stty;
















public function select(OutputInterface $output, $question, $choices, $default = null, $attempts = false, $errorMessage = 'Value "%s" is invalid', $multiselect = false)
{
$width = max(array_map('strlen', array_keys($choices)));

$messages = (array) $question;
foreach ($choices as $key => $value) {
$messages[] = sprintf("  [<info>%-${width}s</info>] %s", $key, $value);
}

$output->writeln($messages);

$result = $this->askAndValidate($output, '> ', function ($picked) use ($choices, $errorMessage, $multiselect) {

 $selectedChoices = str_replace(' ', '', $picked);

if ($multiselect) {

 if (!preg_match('/^[a-zA-Z0-9_-]+(?:,[a-zA-Z0-9_-]+)*$/', $selectedChoices, $matches)) {
throw new \InvalidArgumentException(sprintf($errorMessage, $picked));
}
$selectedChoices = explode(',', $selectedChoices);
} else {
$selectedChoices = array($picked);
}

$multiselectChoices = array();

foreach ($selectedChoices as $value) {
if (empty($choices[$value])) {
throw new \InvalidArgumentException(sprintf($errorMessage, $value));
}
array_push($multiselectChoices, $value);
}

if ($multiselect) {
return $multiselectChoices;
}

return $picked;
}, $attempts, $default);

return $result;
}













public function ask(OutputInterface $output, $question, $default = null, array $autocomplete = null)
{
if ($this->input && !$this->input->isInteractive()) {
return $default;
}

$output->write($question);

$inputStream = $this->inputStream ?: STDIN;

if (null === $autocomplete || !$this->hasSttyAvailable()) {
$ret = fgets($inputStream, 4096);
if (false === $ret) {
throw new \RuntimeException('Aborted');
}
$ret = trim($ret);
} else {
$ret = '';

$i = 0;
$ofs = -1;
$matches = $autocomplete;
$numMatches = count($matches);

$sttyMode = shell_exec('stty -g');


 shell_exec('stty -icanon -echo');


 $output->getFormatter()->setStyle('hl', new OutputFormatterStyle('black', 'white'));


 while (!feof($inputStream)) {
$c = fread($inputStream, 1);


 if ("\177" === $c) {
if (0 === $numMatches && 0 !== $i) {
$i--;

 $output->write("\033[1D");
}

if ($i === 0) {
$ofs = -1;
$matches = $autocomplete;
$numMatches = count($matches);
} else {
$numMatches = 0;
}


 $ret = substr($ret, 0, $i);
} elseif ("\033" === $c) {

 $c .= fread($inputStream, 2);


 if (isset($c[2]) && ('A' === $c[2] || 'B' === $c[2])) {
if ('A' === $c[2] && -1 === $ofs) {
$ofs = 0;
}

if (0 === $numMatches) {
continue;
}

$ofs += ('A' === $c[2]) ? -1 : 1;
$ofs = ($numMatches + $ofs) % $numMatches;
}
} elseif (ord($c) < 32) {
if ("\t" === $c || "\n" === $c) {
if ($numMatches > 0 && -1 !== $ofs) {
$ret = $matches[$ofs];

 $output->write(substr($ret, $i));
$i = strlen($ret);
}

if ("\n" === $c) {
$output->write($c);
break;
}

$numMatches = 0;
}

continue;
} else {
$output->write($c);
$ret .= $c;
$i++;

$numMatches = 0;
$ofs = 0;

foreach ($autocomplete as $value) {

 if (0 === strpos($value, $ret) && $i !== strlen($value)) {
$matches[$numMatches++] = $value;
}
}
}


 $output->write("\033[K");

if ($numMatches > 0 && -1 !== $ofs) {

 $output->write("\0337");

 $output->write('<hl>'.substr($matches[$ofs], $i).'</hl>');

 $output->write("\0338");
}
}


 shell_exec(sprintf('stty %s', $sttyMode));
}

return strlen($ret) > 0 ? $ret : $default;
}












public function askConfirmation(OutputInterface $output, $question, $default = true)
{
$answer = 'z';
while ($answer && !in_array(strtolower($answer[0]), array('y', 'n'))) {
$answer = $this->ask($output, $question);
}

if (false === $default) {
return $answer && 'y' == strtolower($answer[0]);
}

return !$answer || 'y' == strtolower($answer[0]);
}












public function askHiddenResponse(OutputInterface $output, $question, $fallback = true)
{
if ('\\' === DIRECTORY_SEPARATOR) {
$exe = __DIR__.'/../Resources/bin/hiddeninput.exe';


 if ('phar:' === substr(__FILE__, 0, 5)) {
$tmpExe = sys_get_temp_dir().'/hiddeninput.exe';
copy($exe, $tmpExe);
$exe = $tmpExe;
}

$output->write($question);
$value = rtrim(shell_exec($exe));
$output->writeln('');

if (isset($tmpExe)) {
unlink($tmpExe);
}

return $value;
}

if ($this->hasSttyAvailable()) {
$output->write($question);

$sttyMode = shell_exec('stty -g');

shell_exec('stty -echo');
$value = fgets($this->inputStream ?: STDIN, 4096);
shell_exec(sprintf('stty %s', $sttyMode));

if (false === $value) {
throw new \RuntimeException('Aborted');
}

$value = trim($value);
$output->writeln('');

return $value;
}

if (false !== $shell = $this->getShell()) {
$output->write($question);
$readCmd = $shell === 'csh' ? 'set mypassword = $<' : 'read -r mypassword';
$command = sprintf("/usr/bin/env %s -c 'stty -echo; %s; stty echo; echo \$mypassword'", $shell, $readCmd);
$value = rtrim(shell_exec($command));
$output->writeln('');

return $value;
}

if ($fallback) {
return $this->ask($output, $question);
}

throw new \RuntimeException('Unable to hide the response');
}



















public function askAndValidate(OutputInterface $output, $question, $validator, $attempts = false, $default = null, array $autocomplete = null)
{
$that = $this;

$interviewer = function () use ($output, $question, $default, $autocomplete, $that) {
return $that->ask($output, $question, $default, $autocomplete);
};

return $this->validateAttempts($interviewer, $output, $validator, $attempts);
}



















public function askHiddenResponseAndValidate(OutputInterface $output, $question, $validator, $attempts = false, $fallback = true)
{
$that = $this;

$interviewer = function () use ($output, $question, $fallback, $that) {
return $that->askHiddenResponse($output, $question, $fallback);
};

return $this->validateAttempts($interviewer, $output, $validator, $attempts);
}








public function setInputStream($stream)
{
$this->inputStream = $stream;
}






public function getInputStream()
{
return $this->inputStream;
}




public function getName()
{
return 'dialog';
}






private function getShell()
{
if (null !== self::$shell) {
return self::$shell;
}

self::$shell = false;

if (file_exists('/usr/bin/env')) {

 $test = "/usr/bin/env %s -c 'echo OK' 2> /dev/null";
foreach (array('bash', 'zsh', 'ksh', 'csh') as $sh) {
if ('OK' === rtrim(shell_exec(sprintf($test, $sh)))) {
self::$shell = $sh;
break;
}
}
}

return self::$shell;
}

private function hasSttyAvailable()
{
if (null !== self::$stty) {
return self::$stty;
}

exec('stty 2>&1', $output, $exitcode);

return self::$stty = $exitcode === 0;
}













private function validateAttempts($interviewer, OutputInterface $output, $validator, $attempts)
{
$error = null;
while (false === $attempts || $attempts--) {
if (null !== $error) {
$output->writeln($this->getHelperSet()->get('formatter')->formatBlock($error->getMessage(), 'error'));
}

try {
return call_user_func($validator, $interviewer());
} catch (\Exception $error) {
}
}

throw $error;
}
}
<?php










namespace Symfony\Component\Console\Helper;

use Symfony\Component\Console\Formatter\OutputFormatter;






class FormatterHelper extends Helper
{









public function formatSection($section, $message, $style = 'info')
{
return sprintf('<%s>[%s]</%s> %s', $style, $section, $style, $message);
}










public function formatBlock($messages, $style, $large = false)
{
if (!is_array($messages)) {
$messages = array($messages);
}

$len = 0;
$lines = array();
foreach ($messages as $message) {
$message = OutputFormatter::escape($message);
$lines[] = sprintf($large ? '  %s  ' : ' %s ', $message);
$len = max($this->strlen($message) + ($large ? 4 : 2), $len);
}

$messages = $large ? array(str_repeat(' ', $len)) : array();
for ($i = 0; isset($lines[$i]); ++$i) {
$messages[] = $lines[$i].str_repeat(' ', $len - $this->strlen($lines[$i]));
}
if ($large) {
$messages[] = str_repeat(' ', $len);
}

for ($i = 0; isset($messages[$i]); ++$i) {
$messages[$i] = sprintf('<%s>%s</%s>', $style, $messages[$i], $style);
}

return implode("\n", $messages);
}




public function getName()
{
return 'formatter';
}
}
<?php










namespace Symfony\Component\Console\Helper;

use Symfony\Component\Console\Formatter\OutputFormatterInterface;






abstract class Helper implements HelperInterface
{
protected $helperSet = null;






public function setHelperSet(HelperSet $helperSet = null)
{
$this->helperSet = $helperSet;
}






public function getHelperSet()
{
return $this->helperSet;
}








public static function strlen($string)
{
if (!function_exists('mb_strwidth')) {
return strlen($string);
}

if (false === $encoding = mb_detect_encoding($string)) {
return strlen($string);
}

return mb_strwidth($string, $encoding);
}

public static function formatTime($secs)
{
static $timeFormats = array(
array(0, '< 1 sec'),
array(2, '1 sec'),
array(59, 'secs', 1),
array(60, '1 min'),
array(3600, 'mins', 60),
array(5400, '1 hr'),
array(86400, 'hrs', 3600),
array(129600, '1 day'),
array(604800, 'days', 86400),
);

foreach ($timeFormats as $format) {
if ($secs >= $format[0]) {
continue;
}

if (2 == count($format)) {
return $format[1];
}

return ceil($secs / $format[2]).' '.$format[1];
}
}

public static function formatMemory($memory)
{
if ($memory >= 1024 * 1024 * 1024) {
return sprintf('%.1f GiB', $memory / 1024 / 1024 / 1024);
}

if ($memory >= 1024 * 1024) {
return sprintf('%.1f MiB', $memory / 1024 / 1024);
}

if ($memory >= 1024) {
return sprintf('%d KiB', $memory / 1024);
}

return sprintf('%d B', $memory);
}

public static function strlenWithoutDecoration(OutputFormatterInterface $formatter, $string)
{
$isDecorated = $formatter->isDecorated();
$formatter->setDecorated(false);

 $string = $formatter->format($string);

 $string = preg_replace("/\033\[[^m]*m/", '', $string);
$formatter->setDecorated($isDecorated);

return self::strlen($string);
}
}
<?php










namespace Symfony\Component\Console\Helper;








interface HelperInterface
{







public function setHelperSet(HelperSet $helperSet = null);








public function getHelperSet();








public function getName();
}
<?php










namespace Symfony\Component\Console\Helper;

use Symfony\Component\Console\Command\Command;






class HelperSet implements \IteratorAggregate
{
private $helpers = array();
private $command;






public function __construct(array $helpers = array())
{
foreach ($helpers as $alias => $helper) {
$this->set($helper, is_int($alias) ? null : $alias);
}
}







public function set(HelperInterface $helper, $alias = null)
{
$this->helpers[$helper->getName()] = $helper;
if (null !== $alias) {
$this->helpers[$alias] = $helper;
}

$helper->setHelperSet($this);
}








public function has($name)
{
return isset($this->helpers[$name]);
}










public function get($name)
{
if (!$this->has($name)) {
throw new \InvalidArgumentException(sprintf('The helper "%s" is not defined.', $name));
}

return $this->helpers[$name];
}






public function setCommand(Command $command = null)
{
$this->command = $command;
}






public function getCommand()
{
return $this->command;
}

public function getIterator()
{
return new \ArrayIterator($this->helpers);
}
}
<?php










namespace Symfony\Component\Console\Helper;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputAwareInterface;






abstract class InputAwareHelper extends Helper implements InputAwareInterface
{
protected $input;




public function setInput(InputInterface $input)
{
$this->input = $input;
}
}
<?php










namespace Symfony\Component\Console\Helper;

use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Process\Exception\ProcessFailedException;
use Symfony\Component\Process\Process;
use Symfony\Component\Process\ProcessBuilder;






class ProcessHelper extends Helper
{












public function run(OutputInterface $output, $cmd, $error = null, $callback = null, $verbosity = OutputInterface::VERBOSITY_VERY_VERBOSE)
{
$formatter = $this->getHelperSet()->get('debug_formatter');

if (is_array($cmd)) {
$process = ProcessBuilder::create($cmd)->getProcess();
} elseif ($cmd instanceof Process) {
$process = $cmd;
} else {
$process = new Process($cmd);
}

if ($verbosity <= $output->getVerbosity()) {
$output->write($formatter->start(spl_object_hash($process), $this->escapeString($process->getCommandLine())));
}

if ($output->isDebug()) {
$callback = $this->wrapCallback($output, $process, $callback);
}

$process->run($callback);

if ($verbosity <= $output->getVerbosity()) {
$message = $process->isSuccessful() ? 'Command ran successfully' : sprintf('%s Command did not run successfully', $process->getExitCode());
$output->write($formatter->stop(spl_object_hash($process), $message, $process->isSuccessful()));
}

if (!$process->isSuccessful() && null !== $error) {
$output->writeln(sprintf('<error>%s</error>', $this->escapeString($error)));
}

return $process;
}



















public function mustRun(OutputInterface $output, $cmd, $error = null, $callback = null)
{
$process = $this->run($output, $cmd, $error, $callback);

if (!$process->isSuccessful()) {
throw new ProcessFailedException($process);
}

return $process;
}










public function wrapCallback(OutputInterface $output, Process $process, $callback = null)
{
$formatter = $this->getHelperSet()->get('debug_formatter');

$that = $this;

return function ($type, $buffer) use ($output, $process, $callback, $formatter, $that) {
$output->write($formatter->progress(spl_object_hash($process), $that->escapeString($buffer), Process::ERR === $type));

if (null !== $callback) {
call_user_func($callback, $type, $buffer);
}
};
}






public function escapeString($str)
{
return str_replace('<', '\\<', $str);
}




public function getName()
{
return 'process';
}
}
<?php










namespace Symfony\Component\Console\Helper;

use Symfony\Component\Console\Output\OutputInterface;







class ProgressBar
{

 private $barWidth = 28;
private $barChar;
private $emptyBarChar = '-';
private $progressChar = '>';
private $format = null;
private $redrawFreq = 1;




private $output;
private $step = 0;
private $max;
private $startTime;
private $stepWidth;
private $percent = 0.0;
private $lastMessagesLength = 0;
private $formatLineCount;
private $messages;
private $overwrite = true;

private static $formatters;
private static $formats;







public function __construct(OutputInterface $output, $max = 0)
{
$this->output = $output;
$this->setMaxSteps($max);

if (!$this->output->isDecorated()) {

 $this->overwrite = false;

if ($this->max > 10) {

 $this->setRedrawFrequency($max / 10);
}
}

$this->setFormat($this->determineBestFormat());

$this->startTime = time();
}









public static function setPlaceholderFormatterDefinition($name, $callable)
{
if (!self::$formatters) {
self::$formatters = self::initPlaceholderFormatters();
}

self::$formatters[$name] = $callable;
}








public static function getPlaceholderFormatterDefinition($name)
{
if (!self::$formatters) {
self::$formatters = self::initPlaceholderFormatters();
}

return isset(self::$formatters[$name]) ? self::$formatters[$name] : null;
}









public static function setFormatDefinition($name, $format)
{
if (!self::$formats) {
self::$formats = self::initFormats();
}

self::$formats[$name] = $format;
}








public static function getFormatDefinition($name)
{
if (!self::$formats) {
self::$formats = self::initFormats();
}

return isset(self::$formats[$name]) ? self::$formats[$name] : null;
}

public function setMessage($message, $name = 'message')
{
$this->messages[$name] = $message;
}

public function getMessage($name = 'message')
{
return $this->messages[$name];
}






public function getStartTime()
{
return $this->startTime;
}






public function getMaxSteps()
{
return $this->max;
}








public function getStep()
{
return $this->getProgress();
}






public function getProgress()
{
return $this->step;
}








public function getStepWidth()
{
return $this->stepWidth;
}






public function getProgressPercent()
{
return $this->percent;
}






public function setBarWidth($size)
{
$this->barWidth = (int) $size;
}






public function getBarWidth()
{
return $this->barWidth;
}






public function setBarCharacter($char)
{
$this->barChar = $char;
}






public function getBarCharacter()
{
if (null === $this->barChar) {
return $this->max ? '=' : $this->emptyBarChar;
}

return $this->barChar;
}






public function setEmptyBarCharacter($char)
{
$this->emptyBarChar = $char;
}






public function getEmptyBarCharacter()
{
return $this->emptyBarChar;
}






public function setProgressCharacter($char)
{
$this->progressChar = $char;
}






public function getProgressCharacter()
{
return $this->progressChar;
}






public function setFormat($format)
{

 if (!$this->max && null !== self::getFormatDefinition($format.'_nomax')) {
$this->format = self::getFormatDefinition($format.'_nomax');
} elseif (null !== self::getFormatDefinition($format)) {
$this->format = self::getFormatDefinition($format);
} else {
$this->format = $format;
}

$this->formatLineCount = substr_count($this->format, "\n");
}






public function setRedrawFrequency($freq)
{
$this->redrawFreq = (int) $freq;
}






public function start($max = null)
{
$this->startTime = time();
$this->step = 0;
$this->percent = 0.0;

if (null !== $max) {
$this->setMaxSteps($max);
}

$this->display();
}








public function advance($step = 1)
{
$this->setProgress($this->step + $step);
}










public function setCurrent($step)
{
$this->setProgress($step);
}






public function setOverwrite($overwrite)
{
$this->overwrite = (bool) $overwrite;
}








public function setProgress($step)
{
$step = (int) $step;
if ($step < $this->step) {
throw new \LogicException('You can\'t regress the progress bar.');
}

if ($this->max && $step > $this->max) {
$this->max = $step;
}

$prevPeriod = intval($this->step / $this->redrawFreq);
$currPeriod = intval($step / $this->redrawFreq);
$this->step = $step;
$this->percent = $this->max ? (float) $this->step / $this->max : 0;
if ($prevPeriod !== $currPeriod || $this->max === $step) {
$this->display();
}
}




public function finish()
{
if (!$this->max) {
$this->max = $this->step;
}

if ($this->step === $this->max && !$this->overwrite) {

 return;
}

$this->setProgress($this->max);
}




public function display()
{
if (OutputInterface::VERBOSITY_QUIET === $this->output->getVerbosity()) {
return;
}


 $self = $this;
$output = $this->output;
$messages = $this->messages;
$this->overwrite(preg_replace_callback("{%([a-z\-_]+)(?:\:([^%]+))?%}i", function ($matches) use ($self, $output, $messages) {
if ($formatter = $self::getPlaceholderFormatterDefinition($matches[1])) {
$text = call_user_func($formatter, $self, $output);
} elseif (isset($messages[$matches[1]])) {
$text = $messages[$matches[1]];
} else {
return $matches[0];
}

if (isset($matches[2])) {
$text = sprintf('%'.$matches[2], $text);
}

return $text;
}, $this->format));
}








public function clear()
{
if (!$this->overwrite) {
return;
}

$this->overwrite(str_repeat("\n", $this->formatLineCount));
}






private function setMaxSteps($max)
{
$this->max = max(0, (int) $max);
$this->stepWidth = $this->max ? Helper::strlen($this->max) : 4;
}






private function overwrite($message)
{
$lines = explode("\n", $message);


 if (null !== $this->lastMessagesLength) {
foreach ($lines as $i => $line) {
if ($this->lastMessagesLength > Helper::strlenWithoutDecoration($this->output->getFormatter(), $line)) {
$lines[$i] = str_pad($line, $this->lastMessagesLength, "\x20", STR_PAD_RIGHT);
}
}
}

if ($this->overwrite) {

 $this->output->write("\x0D");
} elseif ($this->step > 0) {

 $this->output->writeln('');
}

if ($this->formatLineCount) {
$this->output->write(sprintf("\033[%dA", $this->formatLineCount));
}
$this->output->write(implode("\n", $lines));

$this->lastMessagesLength = 0;
foreach ($lines as $line) {
$len = Helper::strlenWithoutDecoration($this->output->getFormatter(), $line);
if ($len > $this->lastMessagesLength) {
$this->lastMessagesLength = $len;
}
}
}

private function determineBestFormat()
{
switch ($this->output->getVerbosity()) {

 case OutputInterface::VERBOSITY_VERBOSE:
return $this->max ? 'verbose' : 'verbose_nomax';
case OutputInterface::VERBOSITY_VERY_VERBOSE:
return $this->max ? 'very_verbose' : 'very_verbose_nomax';
case OutputInterface::VERBOSITY_DEBUG:
return $this->max ? 'debug' : 'debug_nomax';
default:
return $this->max ? 'normal' : 'normal_nomax';
}
}

private static function initPlaceholderFormatters()
{
return array(
'bar' => function (ProgressBar $bar, OutputInterface $output) {
$completeBars = floor($bar->getMaxSteps() > 0 ? $bar->getProgressPercent() * $bar->getBarWidth() : $bar->getProgress() % $bar->getBarWidth());
$display = str_repeat($bar->getBarCharacter(), $completeBars);
if ($completeBars < $bar->getBarWidth()) {
$emptyBars = $bar->getBarWidth() - $completeBars - Helper::strlenWithoutDecoration($output->getFormatter(), $bar->getProgressCharacter());
$display .= $bar->getProgressCharacter().str_repeat($bar->getEmptyBarCharacter(), $emptyBars);
}

return $display;
},
'elapsed' => function (ProgressBar $bar) {
return Helper::formatTime(time() - $bar->getStartTime());
},
'remaining' => function (ProgressBar $bar) {
if (!$bar->getMaxSteps()) {
throw new \LogicException('Unable to display the remaining time if the maximum number of steps is not set.');
}

if (!$bar->getProgress()) {
$remaining = 0;
} else {
$remaining = round((time() - $bar->getStartTime()) / $bar->getProgress() * ($bar->getMaxSteps() - $bar->getProgress()));
}

return Helper::formatTime($remaining);
},
'estimated' => function (ProgressBar $bar) {
if (!$bar->getMaxSteps()) {
throw new \LogicException('Unable to display the estimated time if the maximum number of steps is not set.');
}

if (!$bar->getProgress()) {
$estimated = 0;
} else {
$estimated = round((time() - $bar->getStartTime()) / $bar->getProgress() * $bar->getMaxSteps());
}

return Helper::formatTime($estimated);
},
'memory' => function (ProgressBar $bar) {
return Helper::formatMemory(memory_get_usage(true));
},
'current' => function (ProgressBar $bar) {
return str_pad($bar->getProgress(), $bar->getStepWidth(), ' ', STR_PAD_LEFT);
},
'max' => function (ProgressBar $bar) {
return $bar->getMaxSteps();
},
'percent' => function (ProgressBar $bar) {
return floor($bar->getProgressPercent() * 100);
},
);
}

private static function initFormats()
{
return array(
'normal' => ' %current%/%max% [%bar%] %percent:3s%%',
'normal_nomax' => ' %current% [%bar%]',

'verbose' => ' %current%/%max% [%bar%] %percent:3s%% %elapsed:6s%',
'verbose_nomax' => ' %current% [%bar%] %elapsed:6s%',

'very_verbose' => ' %current%/%max% [%bar%] %percent:3s%% %elapsed:6s%/%estimated:-6s%',
'very_verbose_nomax' => ' %current% [%bar%] %elapsed:6s%',

'debug' => ' %current%/%max% [%bar%] %percent:3s%% %elapsed:6s%/%estimated:-6s% %memory:6s%',
'debug_nomax' => ' %current% [%bar%] %elapsed:6s% %memory:6s%',
);
}
}
<?php










namespace Symfony\Component\Console\Helper;

use Symfony\Component\Console\Output\NullOutput;
use Symfony\Component\Console\Output\OutputInterface;









class ProgressHelper extends Helper
{
const FORMAT_QUIET = ' %percent%%';
const FORMAT_NORMAL = ' %current%/%max% [%bar%] %percent%%';
const FORMAT_VERBOSE = ' %current%/%max% [%bar%] %percent%% Elapsed: %elapsed%';
const FORMAT_QUIET_NOMAX = ' %current%';
const FORMAT_NORMAL_NOMAX = ' %current% [%bar%]';
const FORMAT_VERBOSE_NOMAX = ' %current% [%bar%] Elapsed: %elapsed%';


 private $barWidth = 28;
private $barChar = '=';
private $emptyBarChar = '-';
private $progressChar = '>';
private $format = null;
private $redrawFreq = 1;

private $lastMessagesLength;
private $barCharOriginal;




private $output;






private $current;






private $max;






private $startTime;






private $defaultFormatVars = array(
'current',
'max',
'bar',
'percent',
'elapsed',
);






private $formatVars;






private $widths = array(
'current' => 4,
'max' => 4,
'percent' => 3,
'elapsed' => 6,
);






private $timeFormats = array(
array(0, '???'),
array(2, '1 sec'),
array(59, 'secs', 1),
array(60, '1 min'),
array(3600, 'mins', 60),
array(5400, '1 hr'),
array(86400, 'hrs', 3600),
array(129600, '1 day'),
array(604800, 'days', 86400),
);






public function setBarWidth($size)
{
$this->barWidth = (int) $size;
}






public function setBarCharacter($char)
{
$this->barChar = $char;
}






public function setEmptyBarCharacter($char)
{
$this->emptyBarChar = $char;
}






public function setProgressCharacter($char)
{
$this->progressChar = $char;
}






public function setFormat($format)
{
$this->format = $format;
}






public function setRedrawFrequency($freq)
{
$this->redrawFreq = (int) $freq;
}







public function start(OutputInterface $output, $max = null)
{
$this->startTime = time();
$this->current = 0;
$this->max = (int) $max;


 $this->output = $output->isDecorated() ? $output : new NullOutput();
$this->lastMessagesLength = 0;
$this->barCharOriginal = '';

if (null === $this->format) {
switch ($output->getVerbosity()) {
case OutputInterface::VERBOSITY_QUIET:
$this->format = self::FORMAT_QUIET_NOMAX;
if ($this->max > 0) {
$this->format = self::FORMAT_QUIET;
}
break;
case OutputInterface::VERBOSITY_VERBOSE:
case OutputInterface::VERBOSITY_VERY_VERBOSE:
case OutputInterface::VERBOSITY_DEBUG:
$this->format = self::FORMAT_VERBOSE_NOMAX;
if ($this->max > 0) {
$this->format = self::FORMAT_VERBOSE;
}
break;
default:
$this->format = self::FORMAT_NORMAL_NOMAX;
if ($this->max > 0) {
$this->format = self::FORMAT_NORMAL;
}
break;
}
}

$this->initialize();
}









public function advance($step = 1, $redraw = false)
{
$this->setCurrent($this->current + $step, $redraw);
}









public function setCurrent($current, $redraw = false)
{
if (null === $this->startTime) {
throw new \LogicException('You must start the progress bar before calling setCurrent().');
}

$current = (int) $current;

if ($current < $this->current) {
throw new \LogicException('You can\'t regress the progress bar');
}

if (0 === $this->current) {
$redraw = true;
}

$prevPeriod = (int) ($this->current / $this->redrawFreq);

$this->current = $current;

$currPeriod = (int) ($this->current / $this->redrawFreq);
if ($redraw || $prevPeriod !== $currPeriod || $this->max === $this->current) {
$this->display();
}
}








public function display($finish = false)
{
if (null === $this->startTime) {
throw new \LogicException('You must start the progress bar before calling display().');
}

$message = $this->format;
foreach ($this->generate($finish) as $name => $value) {
$message = str_replace("%{$name}%", $value, $message);
}
$this->overwrite($this->output, $message);
}








public function clear()
{
$this->overwrite($this->output, '');
}




public function finish()
{
if (null === $this->startTime) {
throw new \LogicException('You must start the progress bar before calling finish().');
}

if (null !== $this->startTime) {
if (!$this->max) {
$this->barChar = $this->barCharOriginal;
$this->display(true);
}
$this->startTime = null;
$this->output->writeln('');
$this->output = null;
}
}




private function initialize()
{
$this->formatVars = array();
foreach ($this->defaultFormatVars as $var) {
if (false !== strpos($this->format, "%{$var}%")) {
$this->formatVars[$var] = true;
}
}

if ($this->max > 0) {
$this->widths['max'] = $this->strlen($this->max);
$this->widths['current'] = $this->widths['max'];
} else {
$this->barCharOriginal = $this->barChar;
$this->barChar = $this->emptyBarChar;
}
}








private function generate($finish = false)
{
$vars = array();
$percent = 0;
if ($this->max > 0) {
$percent = (float) $this->current / $this->max;
}

if (isset($this->formatVars['bar'])) {
$completeBars = 0;

if ($this->max > 0) {
$completeBars = floor($percent * $this->barWidth);
} else {
if (!$finish) {
$completeBars = floor($this->current % $this->barWidth);
} else {
$completeBars = $this->barWidth;
}
}

$emptyBars = $this->barWidth - $completeBars - $this->strlen($this->progressChar);
$bar = str_repeat($this->barChar, $completeBars);
if ($completeBars < $this->barWidth) {
$bar .= $this->progressChar;
$bar .= str_repeat($this->emptyBarChar, $emptyBars);
}

$vars['bar'] = $bar;
}

if (isset($this->formatVars['elapsed'])) {
$elapsed = time() - $this->startTime;
$vars['elapsed'] = str_pad($this->humaneTime($elapsed), $this->widths['elapsed'], ' ', STR_PAD_LEFT);
}

if (isset($this->formatVars['current'])) {
$vars['current'] = str_pad($this->current, $this->widths['current'], ' ', STR_PAD_LEFT);
}

if (isset($this->formatVars['max'])) {
$vars['max'] = $this->max;
}

if (isset($this->formatVars['percent'])) {
$vars['percent'] = str_pad(floor($percent * 100), $this->widths['percent'], ' ', STR_PAD_LEFT);
}

return $vars;
}








private function humaneTime($secs)
{
$text = '';
foreach ($this->timeFormats as $format) {
if ($secs < $format[0]) {
if (count($format) == 2) {
$text = $format[1];
break;
} else {
$text = ceil($secs / $format[2]).' '.$format[1];
break;
}
}
}

return $text;
}







private function overwrite(OutputInterface $output, $message)
{
$length = $this->strlen($message);


 if (null !== $this->lastMessagesLength && $this->lastMessagesLength > $length) {
$message = str_pad($message, $this->lastMessagesLength, "\x20", STR_PAD_RIGHT);
}


 $output->write("\x0D");
$output->write($message);

$this->lastMessagesLength = $this->strlen($message);
}




public function getName()
{
return 'progress';
}
}
<?php










namespace Symfony\Component\Console\Helper;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Formatter\OutputFormatterStyle;
use Symfony\Component\Console\Question\Question;
use Symfony\Component\Console\Question\ChoiceQuestion;






class QuestionHelper extends Helper
{
private $inputStream;
private static $shell;
private static $stty;












public function ask(InputInterface $input, OutputInterface $output, Question $question)
{
if (!$input->isInteractive()) {
return $question->getDefault();
}

if (!$question->getValidator()) {
return $this->doAsk($output, $question);
}

$that = $this;

$interviewer = function () use ($output, $question, $that) {
return $that->doAsk($output, $question);
};

return $this->validateAttempts($interviewer, $output, $question);
}










public function setInputStream($stream)
{
if (!is_resource($stream)) {
throw new \InvalidArgumentException('Input stream must be a valid resource.');
}

$this->inputStream = $stream;
}






public function getInputStream()
{
return $this->inputStream;
}




public function getName()
{
return 'question';
}














public function doAsk(OutputInterface $output, Question $question)
{
$inputStream = $this->inputStream ?: STDIN;

$message = $question->getQuestion();
if ($question instanceof ChoiceQuestion) {
$width = max(array_map('strlen', array_keys($question->getChoices())));

$messages = (array) $question->getQuestion();
foreach ($question->getChoices() as $key => $value) {
$messages[] = sprintf("  [<info>%-${width}s</info>] %s", $key, $value);
}

$output->writeln($messages);

$message = $question->getPrompt();
}

$output->write($message);

$autocomplete = $question->getAutocompleterValues();
if (null === $autocomplete || !$this->hasSttyAvailable()) {
$ret = false;
if ($question->isHidden()) {
try {
$ret = trim($this->getHiddenResponse($output, $inputStream));
} catch (\RuntimeException $e) {
if (!$question->isHiddenFallback()) {
throw $e;
}
}
}

if (false === $ret) {
$ret = fgets($inputStream, 4096);
if (false === $ret) {
throw new \RuntimeException('Aborted');
}
$ret = trim($ret);
}
} else {
$ret = trim($this->autocomplete($output, $question, $inputStream));
}

$ret = strlen($ret) > 0 ? $ret : $question->getDefault();

if ($normalizer = $question->getNormalizer()) {
return $normalizer($ret);
}

return $ret;
}









private function autocomplete(OutputInterface $output, Question $question, $inputStream)
{
$autocomplete = $question->getAutocompleterValues();
$ret = '';

$i = 0;
$ofs = -1;
$matches = $autocomplete;
$numMatches = count($matches);

$sttyMode = shell_exec('stty -g');


 shell_exec('stty -icanon -echo');


 $output->getFormatter()->setStyle('hl', new OutputFormatterStyle('black', 'white'));


 while (!feof($inputStream)) {
$c = fread($inputStream, 1);


 if ("\177" === $c) {
if (0 === $numMatches && 0 !== $i) {
$i--;

 $output->write("\033[1D");
}

if ($i === 0) {
$ofs = -1;
$matches = $autocomplete;
$numMatches = count($matches);
} else {
$numMatches = 0;
}


 $ret = substr($ret, 0, $i);
} elseif ("\033" === $c) {

 $c .= fread($inputStream, 2);


 if (isset($c[2]) && ('A' === $c[2] || 'B' === $c[2])) {
if ('A' === $c[2] && -1 === $ofs) {
$ofs = 0;
}

if (0 === $numMatches) {
continue;
}

$ofs += ('A' === $c[2]) ? -1 : 1;
$ofs = ($numMatches + $ofs) % $numMatches;
}
} elseif (ord($c) < 32) {
if ("\t" === $c || "\n" === $c) {
if ($numMatches > 0 && -1 !== $ofs) {
$ret = $matches[$ofs];

 $output->write(substr($ret, $i));
$i = strlen($ret);
}

if ("\n" === $c) {
$output->write($c);
break;
}

$numMatches = 0;
}

continue;
} else {
$output->write($c);
$ret .= $c;
$i++;

$numMatches = 0;
$ofs = 0;

foreach ($autocomplete as $value) {

 if (0 === strpos($value, $ret) && $i !== strlen($value)) {
$matches[$numMatches++] = $value;
}
}
}


 $output->write("\033[K");

if ($numMatches > 0 && -1 !== $ofs) {

 $output->write("\0337");

 $output->write('<hl>'.substr($matches[$ofs], $i).'</hl>');

 $output->write("\0338");
}
}


 shell_exec(sprintf('stty %s', $sttyMode));

return $ret;
}










private function getHiddenResponse(OutputInterface $output, $inputStream)
{
if ('\\' === DIRECTORY_SEPARATOR) {
$exe = __DIR__.'/../Resources/bin/hiddeninput.exe';


 if ('phar:' === substr(__FILE__, 0, 5)) {
$tmpExe = sys_get_temp_dir().'/hiddeninput.exe';
copy($exe, $tmpExe);
$exe = $tmpExe;
}

$value = rtrim(shell_exec($exe));
$output->writeln('');

if (isset($tmpExe)) {
unlink($tmpExe);
}

return $value;
}

if ($this->hasSttyAvailable()) {
$sttyMode = shell_exec('stty -g');

shell_exec('stty -echo');
$value = fgets($inputStream, 4096);
shell_exec(sprintf('stty %s', $sttyMode));

if (false === $value) {
throw new \RuntimeException('Aborted');
}

$value = trim($value);
$output->writeln('');

return $value;
}

if (false !== $shell = $this->getShell()) {
$readCmd = $shell === 'csh' ? 'set mypassword = $<' : 'read -r mypassword';
$command = sprintf("/usr/bin/env %s -c 'stty -echo; %s; stty echo; echo \$mypassword'", $shell, $readCmd);
$value = rtrim(shell_exec($command));
$output->writeln('');

return $value;
}

throw new \RuntimeException('Unable to hide the response.');
}












private function validateAttempts($interviewer, OutputInterface $output, Question $question)
{
$error = null;
$attempts = $question->getMaxAttempts();
while (null === $attempts || $attempts--) {
if (null !== $error) {
if (null !== $this->getHelperSet() && $this->getHelperSet()->has('formatter')) {
$message = $this->getHelperSet()->get('formatter')->formatBlock($error->getMessage(), 'error');
} else {
$message = '<error>'.$error->getMessage().'</error>';
}

$output->writeln($message);
}

try {
return call_user_func($question->getValidator(), $interviewer());
} catch (\Exception $error) {
}
}

throw $error;
}






private function getShell()
{
if (null !== self::$shell) {
return self::$shell;
}

self::$shell = false;

if (file_exists('/usr/bin/env')) {

 $test = "/usr/bin/env %s -c 'echo OK' 2> /dev/null";
foreach (array('bash', 'zsh', 'ksh', 'csh') as $sh) {
if ('OK' === rtrim(shell_exec(sprintf($test, $sh)))) {
self::$shell = $sh;
break;
}
}
}

return self::$shell;
}






private function hasSttyAvailable()
{
if (null !== self::$stty) {
return self::$stty;
}

exec('stty 2>&1', $output, $exitcode);

return self::$stty = $exitcode === 0;
}
}
<?php










namespace Symfony\Component\Console\Helper;

use Symfony\Component\Console\Output\OutputInterface;







class Table
{





private $headers = array();






private $rows = array();






private $columnWidths = array();






private $numberOfColumns;




private $output;




private $style;

private static $styles;

public function __construct(OutputInterface $output)
{
$this->output = $output;

if (!self::$styles) {
self::$styles = self::initStyles();
}

$this->setStyle('default');
}







public static function setStyleDefinition($name, TableStyle $style)
{
if (!self::$styles) {
self::$styles = self::initStyles();
}

self::$styles[$name] = $style;
}








public static function getStyleDefinition($name)
{
if (!self::$styles) {
self::$styles = self::initStyles();
}

if (!self::$styles[$name]) {
throw new \InvalidArgumentException(sprintf('Style "%s" is not defined.', $name));
}

return self::$styles[$name];
}








public function setStyle($name)
{
if ($name instanceof TableStyle) {
$this->style = $name;
} elseif (isset(self::$styles[$name])) {
$this->style = self::$styles[$name];
} else {
throw new \InvalidArgumentException(sprintf('Style "%s" is not defined.', $name));
}

return $this;
}






public function getStyle()
{
return $this->style;
}

public function setHeaders(array $headers)
{
$this->headers = array_values($headers);

return $this;
}

public function setRows(array $rows)
{
$this->rows = array();

return $this->addRows($rows);
}

public function addRows(array $rows)
{
foreach ($rows as $row) {
$this->addRow($row);
}

return $this;
}

public function addRow($row)
{
if ($row instanceof TableSeparator) {
$this->rows[] = $row;

return;
}

if (!is_array($row)) {
throw new \InvalidArgumentException('A row must be an array or a TableSeparator instance.');
}

$this->rows[] = array_values($row);

end($this->rows);
$rowKey = key($this->rows);
reset($this->rows);

foreach ($row as $key => $cellValue) {
if (!strstr($cellValue, "\n")) {
continue;
}

$lines = explode("\n", $cellValue);
$this->rows[$rowKey][$key] = $lines[0];
unset($lines[0]);

foreach ($lines as $lineKey => $line) {
$nextRowKey = $rowKey + $lineKey + 1;

if (isset($this->rows[$nextRowKey])) {
$this->rows[$nextRowKey][$key] = $line;
} else {
$this->rows[$nextRowKey] = array($key => $line);
}
}
}

return $this;
}

public function setRow($column, array $row)
{
$this->rows[$column] = $row;

return $this;
}













public function render()
{
$this->renderRowSeparator();
$this->renderRow($this->headers, $this->style->getCellHeaderFormat());
if (!empty($this->headers)) {
$this->renderRowSeparator();
}
foreach ($this->rows as $row) {
if ($row instanceof TableSeparator) {
$this->renderRowSeparator();
} else {
$this->renderRow($row, $this->style->getCellRowFormat());
}
}
if (!empty($this->rows)) {
$this->renderRowSeparator();
}

$this->cleanup();
}






private function renderRowSeparator()
{
if (0 === $count = $this->getNumberOfColumns()) {
return;
}

if (!$this->style->getHorizontalBorderChar() && !$this->style->getCrossingChar()) {
return;
}

$markup = $this->style->getCrossingChar();
for ($column = 0; $column < $count; $column++) {
$markup .= str_repeat($this->style->getHorizontalBorderChar(), $this->getColumnWidth($column)).$this->style->getCrossingChar();
}

$this->output->writeln(sprintf($this->style->getBorderFormat(), $markup));
}




private function renderColumnSeparator()
{
$this->output->write(sprintf($this->style->getBorderFormat(), $this->style->getVerticalBorderChar()));
}









private function renderRow(array $row, $cellFormat)
{
if (empty($row)) {
return;
}

$this->renderColumnSeparator();
for ($column = 0, $count = $this->getNumberOfColumns(); $column < $count; $column++) {
$this->renderCell($row, $column, $cellFormat);
$this->renderColumnSeparator();
}
$this->output->writeln('');
}








private function renderCell(array $row, $column, $cellFormat)
{
$cell = isset($row[$column]) ? $row[$column] : '';
$width = $this->getColumnWidth($column);


 if (function_exists('mb_strwidth') && false !== $encoding = mb_detect_encoding($cell)) {
$width += strlen($cell) - mb_strwidth($cell, $encoding);
}

$width += Helper::strlen($cell) - Helper::strlenWithoutDecoration($this->output->getFormatter(), $cell);

$content = sprintf($this->style->getCellRowContentFormat(), $cell);

$this->output->write(sprintf($cellFormat, str_pad($content, $width, $this->style->getPaddingChar(), $this->style->getPadType())));
}






private function getNumberOfColumns()
{
if (null !== $this->numberOfColumns) {
return $this->numberOfColumns;
}

$columns = array(count($this->headers));
foreach ($this->rows as $row) {
$columns[] = count($row);
}

return $this->numberOfColumns = max($columns);
}








private function getColumnWidth($column)
{
if (isset($this->columnWidths[$column])) {
return $this->columnWidths[$column];
}

$lengths = array($this->getCellWidth($this->headers, $column));
foreach ($this->rows as $row) {
if ($row instanceof TableSeparator) {
continue;
}

$lengths[] = $this->getCellWidth($row, $column);
}

return $this->columnWidths[$column] = max($lengths) + strlen($this->style->getCellRowContentFormat()) - 2;
}









private function getCellWidth(array $row, $column)
{
return isset($row[$column]) ? Helper::strlenWithoutDecoration($this->output->getFormatter(), $row[$column]) : 0;
}




private function cleanup()
{
$this->columnWidths = array();
$this->numberOfColumns = null;
}

private static function initStyles()
{
$borderless = new TableStyle();
$borderless
->setHorizontalBorderChar('=')
->setVerticalBorderChar(' ')
->setCrossingChar(' ')
;

$compact = new TableStyle();
$compact
->setHorizontalBorderChar('')
->setVerticalBorderChar(' ')
->setCrossingChar('')
->setCellRowContentFormat('%s')
;

return array(
'default' => new TableStyle(),
'borderless' => $borderless,
'compact' => $compact,
);
}
}
<?php










namespace Symfony\Component\Console\Helper;

use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Output\NullOutput;









class TableHelper extends Helper
{
const LAYOUT_DEFAULT = 0;
const LAYOUT_BORDERLESS = 1;
const LAYOUT_COMPACT = 2;




private $table;

public function __construct()
{
$this->table = new Table(new NullOutput());
}










public function setLayout($layout)
{
switch ($layout) {
case self::LAYOUT_BORDERLESS:
$this->table->setStyle('borderless');
break;

case self::LAYOUT_COMPACT:
$this->table->setStyle('compact');
break;

case self::LAYOUT_DEFAULT:
$this->table->setStyle('default');
break;

default:
throw new \InvalidArgumentException(sprintf('Invalid table layout "%s".', $layout));
};

return $this;
}

public function setHeaders(array $headers)
{
$this->table->setHeaders($headers);

return $this;
}

public function setRows(array $rows)
{
$this->table->setRows($rows);

return $this;
}

public function addRows(array $rows)
{
$this->table->addRows($rows);

return $this;
}

public function addRow(array $row)
{
$this->table->addRow($row);

return $this;
}

public function setRow($column, array $row)
{
$this->table->setRow($column, $row);

return $this;
}








public function setPaddingChar($paddingChar)
{
$this->table->getStyle()->setPaddingChar($paddingChar);

return $this;
}








public function setHorizontalBorderChar($horizontalBorderChar)
{
$this->table->getStyle()->setHorizontalBorderChar($horizontalBorderChar);

return $this;
}








public function setVerticalBorderChar($verticalBorderChar)
{
$this->table->getStyle()->setVerticalBorderChar($verticalBorderChar);

return $this;
}








public function setCrossingChar($crossingChar)
{
$this->table->getStyle()->setCrossingChar($crossingChar);

return $this;
}








public function setCellHeaderFormat($cellHeaderFormat)
{
$this->table->getStyle()->setCellHeaderFormat($cellHeaderFormat);

return $this;
}








public function setCellRowFormat($cellRowFormat)
{
$this->table->getStyle()->setCellHeaderFormat($cellRowFormat);

return $this;
}








public function setCellRowContentFormat($cellRowContentFormat)
{
$this->table->getStyle()->setCellRowContentFormat($cellRowContentFormat);

return $this;
}








public function setBorderFormat($borderFormat)
{
$this->table->getStyle()->setBorderFormat($borderFormat);

return $this;
}








public function setPadType($padType)
{
$this->table->getStyle()->setPadType($padType);

return $this;
}















public function render(OutputInterface $output)
{
$p = new \ReflectionProperty($this->table, 'output');
$p->setAccessible(true);
$p->setValue($this->table, $output);

$this->table->render();
}




public function getName()
{
return 'table';
}
}
<?php










namespace Symfony\Component\Console\Helper;






class TableSeparator
{
}
<?php










namespace Symfony\Component\Console\Helper;







class TableStyle
{
private $paddingChar = ' ';
private $horizontalBorderChar = '-';
private $verticalBorderChar = '|';
private $crossingChar = '+';
private $cellHeaderFormat = '<info>%s</info>';
private $cellRowFormat = '%s';
private $cellRowContentFormat = ' %s ';
private $borderFormat = '%s';
private $padType = STR_PAD_RIGHT;








public function setPaddingChar($paddingChar)
{
if (!$paddingChar) {
throw new \LogicException('The padding char must not be empty');
}

$this->paddingChar = $paddingChar;

return $this;
}






public function getPaddingChar()
{
return $this->paddingChar;
}








public function setHorizontalBorderChar($horizontalBorderChar)
{
$this->horizontalBorderChar = $horizontalBorderChar;

return $this;
}






public function getHorizontalBorderChar()
{
return $this->horizontalBorderChar;
}








public function setVerticalBorderChar($verticalBorderChar)
{
$this->verticalBorderChar = $verticalBorderChar;

return $this;
}






public function getVerticalBorderChar()
{
return $this->verticalBorderChar;
}








public function setCrossingChar($crossingChar)
{
$this->crossingChar = $crossingChar;

return $this;
}






public function getCrossingChar()
{
return $this->crossingChar;
}








public function setCellHeaderFormat($cellHeaderFormat)
{
$this->cellHeaderFormat = $cellHeaderFormat;

return $this;
}






public function getCellHeaderFormat()
{
return $this->cellHeaderFormat;
}








public function setCellRowFormat($cellRowFormat)
{
$this->cellRowFormat = $cellRowFormat;

return $this;
}






public function getCellRowFormat()
{
return $this->cellRowFormat;
}








public function setCellRowContentFormat($cellRowContentFormat)
{
$this->cellRowContentFormat = $cellRowContentFormat;

return $this;
}






public function getCellRowContentFormat()
{
return $this->cellRowContentFormat;
}








public function setBorderFormat($borderFormat)
{
$this->borderFormat = $borderFormat;

return $this;
}






public function getBorderFormat()
{
return $this->borderFormat;
}








public function setPadType($padType)
{
$this->padType = $padType;

return $this;
}






public function getPadType()
{
return $this->padType;
}
}
<?php










namespace Symfony\Component\Console\Input;




























class ArgvInput extends Input
{
private $tokens;
private $parsed;









public function __construct(array $argv = null, InputDefinition $definition = null)
{
if (null === $argv) {
$argv = $_SERVER['argv'];
}


 array_shift($argv);

$this->tokens = $argv;

parent::__construct($definition);
}

protected function setTokens(array $tokens)
{
$this->tokens = $tokens;
}




protected function parse()
{
$parseOptions = true;
$this->parsed = $this->tokens;
while (null !== $token = array_shift($this->parsed)) {
if ($parseOptions && '' == $token) {
$this->parseArgument($token);
} elseif ($parseOptions && '--' == $token) {
$parseOptions = false;
} elseif ($parseOptions && 0 === strpos($token, '--')) {
$this->parseLongOption($token);
} elseif ($parseOptions && '-' === $token[0] && '-' !== $token) {
$this->parseShortOption($token);
} else {
$this->parseArgument($token);
}
}
}






private function parseShortOption($token)
{
$name = substr($token, 1);

if (strlen($name) > 1) {
if ($this->definition->hasShortcut($name[0]) && $this->definition->getOptionForShortcut($name[0])->acceptValue()) {

 $this->addShortOption($name[0], substr($name, 1));
} else {
$this->parseShortOptionSet($name);
}
} else {
$this->addShortOption($name, null);
}
}








private function parseShortOptionSet($name)
{
$len = strlen($name);
for ($i = 0; $i < $len; $i++) {
if (!$this->definition->hasShortcut($name[$i])) {
throw new \RuntimeException(sprintf('The "-%s" option does not exist.', $name[$i]));
}

$option = $this->definition->getOptionForShortcut($name[$i]);
if ($option->acceptValue()) {
$this->addLongOption($option->getName(), $i === $len - 1 ? null : substr($name, $i + 1));

break;
} else {
$this->addLongOption($option->getName(), null);
}
}
}






private function parseLongOption($token)
{
$name = substr($token, 2);

if (false !== $pos = strpos($name, '=')) {
$this->addLongOption(substr($name, 0, $pos), substr($name, $pos + 1));
} else {
$this->addLongOption($name, null);
}
}








private function parseArgument($token)
{
$c = count($this->arguments);


 if ($this->definition->hasArgument($c)) {
$arg = $this->definition->getArgument($c);
$this->arguments[$arg->getName()] = $arg->isArray() ? array($token) : $token;


 } elseif ($this->definition->hasArgument($c - 1) && $this->definition->getArgument($c - 1)->isArray()) {
$arg = $this->definition->getArgument($c - 1);
$this->arguments[$arg->getName()][] = $token;


 } else {
throw new \RuntimeException('Too many arguments.');
}
}









private function addShortOption($shortcut, $value)
{
if (!$this->definition->hasShortcut($shortcut)) {
throw new \RuntimeException(sprintf('The "-%s" option does not exist.', $shortcut));
}

$this->addLongOption($this->definition->getOptionForShortcut($shortcut)->getName(), $value);
}









private function addLongOption($name, $value)
{
if (!$this->definition->hasOption($name)) {
throw new \RuntimeException(sprintf('The "--%s" option does not exist.', $name));
}

$option = $this->definition->getOption($name);


 if (false === $value) {
$value = null;
}

if (null !== $value && !$option->acceptValue()) {
throw new \RuntimeException(sprintf('The "--%s" option does not accept a value.', $name, $value));
}

if (null === $value && $option->acceptValue() && count($this->parsed)) {

 
 $next = array_shift($this->parsed);
if (isset($next[0]) && '-' !== $next[0]) {
$value = $next;
} elseif (empty($next)) {
$value = '';
} else {
array_unshift($this->parsed, $next);
}
}

if (null === $value) {
if ($option->isValueRequired()) {
throw new \RuntimeException(sprintf('The "--%s" option requires a value.', $name));
}

if (!$option->isArray()) {
$value = $option->isValueOptional() ? $option->getDefault() : true;
}
}

if ($option->isArray()) {
$this->options[$name][] = $value;
} else {
$this->options[$name] = $value;
}
}






public function getFirstArgument()
{
foreach ($this->tokens as $token) {
if ($token && '-' === $token[0]) {
continue;
}

return $token;
}
}











public function hasParameterOption($values)
{
$values = (array) $values;

foreach ($this->tokens as $token) {
foreach ($values as $value) {
if ($token === $value || 0 === strpos($token, $value.'=')) {
return true;
}
}
}

return false;
}












public function getParameterOption($values, $default = false)
{
$values = (array) $values;
$tokens = $this->tokens;

while (0 < count($tokens)) {
$token = array_shift($tokens);

foreach ($values as $value) {
if ($token === $value || 0 === strpos($token, $value.'=')) {
if (false !== $pos = strpos($token, '=')) {
return substr($token, $pos + 1);
}

return array_shift($tokens);
}
}
}

return $default;
}






public function __toString()
{
$self = $this;
$tokens = array_map(function ($token) use ($self) {
if (preg_match('{^(-[^=]+=)(.+)}', $token, $match)) {
return $match[1].$self->escapeToken($match[2]);
}

if ($token && $token[0] !== '-') {
return $self->escapeToken($token);
}

return $token;
}, $this->tokens);

return implode(' ', $tokens);
}
}
<?php










namespace Symfony\Component\Console\Input;












class ArrayInput extends Input
{
private $parameters;









public function __construct(array $parameters, InputDefinition $definition = null)
{
$this->parameters = $parameters;

parent::__construct($definition);
}






public function getFirstArgument()
{
foreach ($this->parameters as $key => $value) {
if ($key && '-' === $key[0]) {
continue;
}

return $value;
}
}











public function hasParameterOption($values)
{
$values = (array) $values;

foreach ($this->parameters as $k => $v) {
if (!is_int($k)) {
$v = $k;
}

if (in_array($v, $values)) {
return true;
}
}

return false;
}












public function getParameterOption($values, $default = false)
{
$values = (array) $values;

foreach ($this->parameters as $k => $v) {
if (is_int($k)) {
if (in_array($v, $values)) {
return true;
}
} elseif (in_array($k, $values)) {
return $v;
}
}

return $default;
}






public function __toString()
{
$params = array();
foreach ($this->parameters as $param => $val) {
if ($param && '-' === $param[0]) {
$params[] = $param.('' != $val ? '='.$this->escapeToken($val) : '');
} else {
$params[] = $this->escapeToken($val);
}
}

return implode(' ', $params);
}




protected function parse()
{
foreach ($this->parameters as $key => $value) {
if (0 === strpos($key, '--')) {
$this->addLongOption(substr($key, 2), $value);
} elseif ('-' === $key[0]) {
$this->addShortOption(substr($key, 1), $value);
} else {
$this->addArgument($key, $value);
}
}
}









private function addShortOption($shortcut, $value)
{
if (!$this->definition->hasShortcut($shortcut)) {
throw new \InvalidArgumentException(sprintf('The "-%s" option does not exist.', $shortcut));
}

$this->addLongOption($this->definition->getOptionForShortcut($shortcut)->getName(), $value);
}










private function addLongOption($name, $value)
{
if (!$this->definition->hasOption($name)) {
throw new \InvalidArgumentException(sprintf('The "--%s" option does not exist.', $name));
}

$option = $this->definition->getOption($name);

if (null === $value) {
if ($option->isValueRequired()) {
throw new \InvalidArgumentException(sprintf('The "--%s" option requires a value.', $name));
}

$value = $option->isValueOptional() ? $option->getDefault() : true;
}

$this->options[$name] = $value;
}









private function addArgument($name, $value)
{
if (!$this->definition->hasArgument($name)) {
throw new \InvalidArgumentException(sprintf('The "%s" argument does not exist.', $name));
}

$this->arguments[$name] = $value;
}
}
<?php










namespace Symfony\Component\Console\Input;












abstract class Input implements InputInterface
{



protected $definition;
protected $options = array();
protected $arguments = array();
protected $interactive = true;






public function __construct(InputDefinition $definition = null)
{
if (null === $definition) {
$this->definition = new InputDefinition();
} else {
$this->bind($definition);
$this->validate();
}
}






public function bind(InputDefinition $definition)
{
$this->arguments = array();
$this->options = array();
$this->definition = $definition;

$this->parse();
}




abstract protected function parse();






public function validate()
{
if (count($this->arguments) < $this->definition->getArgumentRequiredCount()) {
throw new \RuntimeException('Not enough arguments.');
}
}






public function isInteractive()
{
return $this->interactive;
}






public function setInteractive($interactive)
{
$this->interactive = (bool) $interactive;
}






public function getArguments()
{
return array_merge($this->definition->getArgumentDefaults(), $this->arguments);
}










public function getArgument($name)
{
if (!$this->definition->hasArgument($name)) {
throw new \InvalidArgumentException(sprintf('The "%s" argument does not exist.', $name));
}

return isset($this->arguments[$name]) ? $this->arguments[$name] : $this->definition->getArgument($name)->getDefault();
}









public function setArgument($name, $value)
{
if (!$this->definition->hasArgument($name)) {
throw new \InvalidArgumentException(sprintf('The "%s" argument does not exist.', $name));
}

$this->arguments[$name] = $value;
}








public function hasArgument($name)
{
return $this->definition->hasArgument($name);
}






public function getOptions()
{
return array_merge($this->definition->getOptionDefaults(), $this->options);
}










public function getOption($name)
{
if (!$this->definition->hasOption($name)) {
throw new \InvalidArgumentException(sprintf('The "%s" option does not exist.', $name));
}

return isset($this->options[$name]) ? $this->options[$name] : $this->definition->getOption($name)->getDefault();
}









public function setOption($name, $value)
{
if (!$this->definition->hasOption($name)) {
throw new \InvalidArgumentException(sprintf('The "%s" option does not exist.', $name));
}

$this->options[$name] = $value;
}








public function hasOption($name)
{
return $this->definition->hasOption($name);
}








public function escapeToken($token)
{
return preg_match('{^[\w-]+$}', $token) ? $token : escapeshellarg($token);
}
}
<?php










namespace Symfony\Component\Console\Input;








class InputArgument
{
const REQUIRED = 1;
const OPTIONAL = 2;
const IS_ARRAY = 4;

private $name;
private $mode;
private $default;
private $description;













public function __construct($name, $mode = null, $description = '', $default = null)
{
if (null === $mode) {
$mode = self::OPTIONAL;
} elseif (!is_int($mode) || $mode > 7 || $mode < 1) {
throw new \InvalidArgumentException(sprintf('Argument mode "%s" is not valid.', $mode));
}

$this->name = $name;
$this->mode = $mode;
$this->description = $description;

$this->setDefault($default);
}






public function getName()
{
return $this->name;
}






public function isRequired()
{
return self::REQUIRED === (self::REQUIRED & $this->mode);
}






public function isArray()
{
return self::IS_ARRAY === (self::IS_ARRAY & $this->mode);
}








public function setDefault($default = null)
{
if (self::REQUIRED === $this->mode && null !== $default) {
throw new \LogicException('Cannot set a default value except for InputArgument::OPTIONAL mode.');
}

if ($this->isArray()) {
if (null === $default) {
$default = array();
} elseif (!is_array($default)) {
throw new \LogicException('A default value for an array argument must be an array.');
}
}

$this->default = $default;
}






public function getDefault()
{
return $this->default;
}






public function getDescription()
{
return $this->description;
}
}
<?php










namespace Symfony\Component\Console\Input;







interface InputAwareInterface
{





public function setInput(InputInterface $input);
}
<?php










namespace Symfony\Component\Console\Input;

use Symfony\Component\Console\Descriptor\TextDescriptor;
use Symfony\Component\Console\Descriptor\XmlDescriptor;
use Symfony\Component\Console\Output\BufferedOutput;















class InputDefinition
{
private $arguments;
private $requiredCount;
private $hasAnArrayArgument = false;
private $hasOptional;
private $options;
private $shortcuts;








public function __construct(array $definition = array())
{
$this->setDefinition($definition);
}








public function setDefinition(array $definition)
{
$arguments = array();
$options = array();
foreach ($definition as $item) {
if ($item instanceof InputOption) {
$options[] = $item;
} else {
$arguments[] = $item;
}
}

$this->setArguments($arguments);
$this->setOptions($options);
}








public function setArguments($arguments = array())
{
$this->arguments = array();
$this->requiredCount = 0;
$this->hasOptional = false;
$this->hasAnArrayArgument = false;
$this->addArguments($arguments);
}








public function addArguments($arguments = array())
{
if (null !== $arguments) {
foreach ($arguments as $argument) {
$this->addArgument($argument);
}
}
}










public function addArgument(InputArgument $argument)
{
if (isset($this->arguments[$argument->getName()])) {
throw new \LogicException(sprintf('An argument with name "%s" already exists.', $argument->getName()));
}

if ($this->hasAnArrayArgument) {
throw new \LogicException('Cannot add an argument after an array argument.');
}

if ($argument->isRequired() && $this->hasOptional) {
throw new \LogicException('Cannot add a required argument after an optional one.');
}

if ($argument->isArray()) {
$this->hasAnArrayArgument = true;
}

if ($argument->isRequired()) {
++$this->requiredCount;
} else {
$this->hasOptional = true;
}

$this->arguments[$argument->getName()] = $argument;
}












public function getArgument($name)
{
if (!$this->hasArgument($name)) {
throw new \InvalidArgumentException(sprintf('The "%s" argument does not exist.', $name));
}

$arguments = is_int($name) ? array_values($this->arguments) : $this->arguments;

return $arguments[$name];
}










public function hasArgument($name)
{
$arguments = is_int($name) ? array_values($this->arguments) : $this->arguments;

return isset($arguments[$name]);
}








public function getArguments()
{
return $this->arguments;
}






public function getArgumentCount()
{
return $this->hasAnArrayArgument ? PHP_INT_MAX : count($this->arguments);
}






public function getArgumentRequiredCount()
{
return $this->requiredCount;
}






public function getArgumentDefaults()
{
$values = array();
foreach ($this->arguments as $argument) {
$values[$argument->getName()] = $argument->getDefault();
}

return $values;
}








public function setOptions($options = array())
{
$this->options = array();
$this->shortcuts = array();
$this->addOptions($options);
}








public function addOptions($options = array())
{
foreach ($options as $option) {
$this->addOption($option);
}
}










public function addOption(InputOption $option)
{
if (isset($this->options[$option->getName()]) && !$option->equals($this->options[$option->getName()])) {
throw new \LogicException(sprintf('An option named "%s" already exists.', $option->getName()));
}

if ($option->getShortcut()) {
foreach (explode('|', $option->getShortcut()) as $shortcut) {
if (isset($this->shortcuts[$shortcut]) && !$option->equals($this->options[$this->shortcuts[$shortcut]])) {
throw new \LogicException(sprintf('An option with shortcut "%s" already exists.', $shortcut));
}
}
}

$this->options[$option->getName()] = $option;
if ($option->getShortcut()) {
foreach (explode('|', $option->getShortcut()) as $shortcut) {
$this->shortcuts[$shortcut] = $option->getName();
}
}
}












public function getOption($name)
{
if (!$this->hasOption($name)) {
throw new \InvalidArgumentException(sprintf('The "--%s" option does not exist.', $name));
}

return $this->options[$name];
}










public function hasOption($name)
{
return isset($this->options[$name]);
}








public function getOptions()
{
return $this->options;
}








public function hasShortcut($name)
{
return isset($this->shortcuts[$name]);
}








public function getOptionForShortcut($shortcut)
{
return $this->getOption($this->shortcutToName($shortcut));
}






public function getOptionDefaults()
{
$values = array();
foreach ($this->options as $option) {
$values[$option->getName()] = $option->getDefault();
}

return $values;
}










private function shortcutToName($shortcut)
{
if (!isset($this->shortcuts[$shortcut])) {
throw new \InvalidArgumentException(sprintf('The "-%s" option does not exist.', $shortcut));
}

return $this->shortcuts[$shortcut];
}






public function getSynopsis()
{
$elements = array();
foreach ($this->getOptions() as $option) {
$shortcut = $option->getShortcut() ? sprintf('-%s|', $option->getShortcut()) : '';
$elements[] = sprintf('['.($option->isValueRequired() ? '%s--%s="..."' : ($option->isValueOptional() ? '%s--%s[="..."]' : '%s--%s')).']', $shortcut, $option->getName());
}

foreach ($this->getArguments() as $argument) {
$elements[] = sprintf($argument->isRequired() ? '%s' : '[%s]', $argument->getName().($argument->isArray() ? '1' : ''));

if ($argument->isArray()) {
$elements[] = sprintf('... [%sN]', $argument->getName());
}
}

return implode(' ', $elements);
}








public function asText()
{
$descriptor = new TextDescriptor();
$output = new BufferedOutput(BufferedOutput::VERBOSITY_NORMAL, true);
$descriptor->describe($output, $this, array('raw_output' => true));

return $output->fetch();
}










public function asXml($asDom = false)
{
$descriptor = new XmlDescriptor();

if ($asDom) {
return $descriptor->getInputDefinitionDocument($this);
}

$output = new BufferedOutput();
$descriptor->describe($output, $this);

return $output->fetch();
}
}
<?php










namespace Symfony\Component\Console\Input;






interface InputInterface
{





public function getFirstArgument();











public function hasParameterOption($values);












public function getParameterOption($values, $default = false);






public function bind(InputDefinition $definition);








public function validate();






public function getArguments();








public function getArgument($name);









public function setArgument($name, $value);








public function hasArgument($name);






public function getOptions();








public function getOption($name);









public function setOption($name, $value);








public function hasOption($name);






public function isInteractive();






public function setInteractive($interactive);
}
<?php










namespace Symfony\Component\Console\Input;








class InputOption
{
const VALUE_NONE = 1;
const VALUE_REQUIRED = 2;
const VALUE_OPTIONAL = 4;
const VALUE_IS_ARRAY = 8;

private $name;
private $shortcut;
private $mode;
private $default;
private $description;














public function __construct($name, $shortcut = null, $mode = null, $description = '', $default = null)
{
if (0 === strpos($name, '--')) {
$name = substr($name, 2);
}

if (empty($name)) {
throw new \InvalidArgumentException('An option name cannot be empty.');
}

if (empty($shortcut)) {
$shortcut = null;
}

if (null !== $shortcut) {
if (is_array($shortcut)) {
$shortcut = implode('|', $shortcut);
}
$shortcuts = preg_split('{(\|)-?}', ltrim($shortcut, '-'));
$shortcuts = array_filter($shortcuts);
$shortcut = implode('|', $shortcuts);

if (empty($shortcut)) {
throw new \InvalidArgumentException('An option shortcut cannot be empty.');
}
}

if (null === $mode) {
$mode = self::VALUE_NONE;
} elseif (!is_int($mode) || $mode > 15 || $mode < 1) {
throw new \InvalidArgumentException(sprintf('Option mode "%s" is not valid.', $mode));
}

$this->name = $name;
$this->shortcut = $shortcut;
$this->mode = $mode;
$this->description = $description;

if ($this->isArray() && !$this->acceptValue()) {
throw new \InvalidArgumentException('Impossible to have an option mode VALUE_IS_ARRAY if the option does not accept a value.');
}

$this->setDefault($default);
}






public function getShortcut()
{
return $this->shortcut;
}






public function getName()
{
return $this->name;
}






public function acceptValue()
{
return $this->isValueRequired() || $this->isValueOptional();
}






public function isValueRequired()
{
return self::VALUE_REQUIRED === (self::VALUE_REQUIRED & $this->mode);
}






public function isValueOptional()
{
return self::VALUE_OPTIONAL === (self::VALUE_OPTIONAL & $this->mode);
}






public function isArray()
{
return self::VALUE_IS_ARRAY === (self::VALUE_IS_ARRAY & $this->mode);
}








public function setDefault($default = null)
{
if (self::VALUE_NONE === (self::VALUE_NONE & $this->mode) && null !== $default) {
throw new \LogicException('Cannot set a default value when using InputOption::VALUE_NONE mode.');
}

if ($this->isArray()) {
if (null === $default) {
$default = array();
} elseif (!is_array($default)) {
throw new \LogicException('A default value for an array option must be an array.');
}
}

$this->default = $this->acceptValue() ? $default : false;
}






public function getDefault()
{
return $this->default;
}






public function getDescription()
{
return $this->description;
}








public function equals(InputOption $option)
{
return $option->getName() === $this->getName()
&& $option->getShortcut() === $this->getShortcut()
&& $option->getDefault() === $this->getDefault()
&& $option->isArray() === $this->isArray()
&& $option->isValueRequired() === $this->isValueRequired()
&& $option->isValueOptional() === $this->isValueOptional()
;
}
}
<?php










namespace Symfony\Component\Console\Input;












class StringInput extends ArgvInput
{
const REGEX_STRING = '([^\s]+?)(?:\s|(?<!\\\\)"|(?<!\\\\)\'|$)';
const REGEX_QUOTED_STRING = '(?:"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|\'([^\'\\\\]*(?:\\\\.[^\'\\\\]*)*)\')';











public function __construct($input, InputDefinition $definition = null)
{
parent::__construct(array(), null);

$this->setTokens($this->tokenize($input));

if (null !== $definition) {
$this->bind($definition);
}
}










private function tokenize($input)
{
$tokens = array();
$length = strlen($input);
$cursor = 0;
while ($cursor < $length) {
if (preg_match('/\s+/A', $input, $match, null, $cursor)) {
} elseif (preg_match('/([^="\'\s]+?)(=?)('.self::REGEX_QUOTED_STRING.'+)/A', $input, $match, null, $cursor)) {
$tokens[] = $match[1].$match[2].stripcslashes(str_replace(array('"\'', '\'"', '\'\'', '""'), '', substr($match[3], 1, strlen($match[3]) - 2)));
} elseif (preg_match('/'.self::REGEX_QUOTED_STRING.'/A', $input, $match, null, $cursor)) {
$tokens[] = stripcslashes(substr($match[0], 1, strlen($match[0]) - 2));
} elseif (preg_match('/'.self::REGEX_STRING.'/A', $input, $match, null, $cursor)) {
$tokens[] = stripcslashes($match[1]);
} else {

 throw new \InvalidArgumentException(sprintf('Unable to parse input near "... %s ..."', substr($input, $cursor, 10)));
}

$cursor += strlen($match[0]);
}

return $tokens;
}
}
Copyright (c) 2004-2015 Fabien Potencier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
<?php










namespace Symfony\Component\Console\Logger;

use Psr\Log\AbstractLogger;
use Psr\Log\InvalidArgumentException;
use Psr\Log\LogLevel;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Output\ConsoleOutputInterface;







class ConsoleLogger extends AbstractLogger
{
const INFO = 'info';
const ERROR = 'error';




private $output;



private $verbosityLevelMap = array(
LogLevel::EMERGENCY => OutputInterface::VERBOSITY_NORMAL,
LogLevel::ALERT => OutputInterface::VERBOSITY_NORMAL,
LogLevel::CRITICAL => OutputInterface::VERBOSITY_NORMAL,
LogLevel::ERROR => OutputInterface::VERBOSITY_NORMAL,
LogLevel::WARNING => OutputInterface::VERBOSITY_NORMAL,
LogLevel::NOTICE => OutputInterface::VERBOSITY_VERBOSE,
LogLevel::INFO => OutputInterface::VERBOSITY_VERY_VERBOSE,
LogLevel::DEBUG => OutputInterface::VERBOSITY_DEBUG,
);



private $formatLevelMap = array(
LogLevel::EMERGENCY => self::ERROR,
LogLevel::ALERT => self::ERROR,
LogLevel::CRITICAL => self::ERROR,
LogLevel::ERROR => self::ERROR,
LogLevel::WARNING => self::INFO,
LogLevel::NOTICE => self::INFO,
LogLevel::INFO => self::INFO,
LogLevel::DEBUG => self::INFO,
);






public function __construct(OutputInterface $output, array $verbosityLevelMap = array(), array $formatLevelMap = array())
{
$this->output = $output;
$this->verbosityLevelMap = $verbosityLevelMap + $this->verbosityLevelMap;
$this->formatLevelMap = $formatLevelMap + $this->formatLevelMap;
}




public function log($level, $message, array $context = array())
{
if (!isset($this->verbosityLevelMap[$level])) {
throw new InvalidArgumentException(sprintf('The log level "%s" does not exist.', $level));
}


 if ($this->formatLevelMap[$level] === self::ERROR && $this->output instanceof ConsoleOutputInterface) {
$output = $this->output->getErrorOutput();
} else {
$output = $this->output;
}

if ($output->getVerbosity() >= $this->verbosityLevelMap[$level]) {
$output->writeln(sprintf('<%1$s>[%2$s] %3$s</%1$s>', $this->formatLevelMap[$level], $level, $this->interpolate($message, $context)));
}
}











private function interpolate($message, array $context)
{

 $replace = array();
foreach ($context as $key => $val) {
if (!is_array($val) && (!is_object($val) || method_exists($val, '__toString'))) {
$replace[sprintf('{%s}', $key)] = $val;
}
}


 return strtr($message, $replace);
}
}
<?php










namespace Symfony\Component\Console\Output;




class BufferedOutput extends Output
{



private $buffer = '';






public function fetch()
{
$content = $this->buffer;
$this->buffer = '';

return $content;
}




protected function doWrite($message, $newline)
{
$this->buffer .= $message;

if ($newline) {
$this->buffer .= "\n";
}
}
}
<?php










namespace Symfony\Component\Console\Output;

use Symfony\Component\Console\Formatter\OutputFormatterInterface;
















class ConsoleOutput extends StreamOutput implements ConsoleOutputInterface
{
private $stderr;










public function __construct($verbosity = self::VERBOSITY_NORMAL, $decorated = null, OutputFormatterInterface $formatter = null)
{
$outputStream = 'php://stdout';
if (!$this->hasStdoutSupport()) {
$outputStream = 'php://output';
}

parent::__construct(fopen($outputStream, 'w'), $verbosity, $decorated, $formatter);

$this->stderr = new StreamOutput(fopen('php://stderr', 'w'), $verbosity, $decorated, $this->getFormatter());
}




public function setDecorated($decorated)
{
parent::setDecorated($decorated);
$this->stderr->setDecorated($decorated);
}




public function setFormatter(OutputFormatterInterface $formatter)
{
parent::setFormatter($formatter);
$this->stderr->setFormatter($formatter);
}




public function setVerbosity($level)
{
parent::setVerbosity($level);
$this->stderr->setVerbosity($level);
}




public function getErrorOutput()
{
return $this->stderr;
}




public function setErrorOutput(OutputInterface $error)
{
$this->stderr = $error;
}











protected function hasStdoutSupport()
{
return ('OS400' != php_uname('s'));
}
}
<?php










namespace Symfony\Component\Console\Output;







interface ConsoleOutputInterface extends OutputInterface
{





public function getErrorOutput();






public function setErrorOutput(OutputInterface $error);
}
<?php










namespace Symfony\Component\Console\Output;

use Symfony\Component\Console\Formatter\OutputFormatter;
use Symfony\Component\Console\Formatter\OutputFormatterInterface;











class NullOutput implements OutputInterface
{



public function setFormatter(OutputFormatterInterface $formatter)
{

 }




public function getFormatter()
{

 return new OutputFormatter();
}




public function setDecorated($decorated)
{

 }




public function isDecorated()
{
return false;
}




public function setVerbosity($level)
{

 }




public function getVerbosity()
{
return self::VERBOSITY_QUIET;
}

public function isQuiet()
{
return true;
}

public function isVerbose()
{
return false;
}

public function isVeryVerbose()
{
return false;
}

public function isDebug()
{
return false;
}




public function writeln($messages, $type = self::OUTPUT_NORMAL)
{

 }




public function write($messages, $newline = false, $type = self::OUTPUT_NORMAL)
{

 }
}
<?php










namespace Symfony\Component\Console\Output;

use Symfony\Component\Console\Formatter\OutputFormatterInterface;
use Symfony\Component\Console\Formatter\OutputFormatter;
















abstract class Output implements OutputInterface
{
private $verbosity;
private $formatter;










public function __construct($verbosity = self::VERBOSITY_NORMAL, $decorated = false, OutputFormatterInterface $formatter = null)
{
$this->verbosity = null === $verbosity ? self::VERBOSITY_NORMAL : $verbosity;
$this->formatter = $formatter ?: new OutputFormatter();
$this->formatter->setDecorated($decorated);
}




public function setFormatter(OutputFormatterInterface $formatter)
{
$this->formatter = $formatter;
}




public function getFormatter()
{
return $this->formatter;
}




public function setDecorated($decorated)
{
$this->formatter->setDecorated($decorated);
}




public function isDecorated()
{
return $this->formatter->isDecorated();
}




public function setVerbosity($level)
{
$this->verbosity = (int) $level;
}




public function getVerbosity()
{
return $this->verbosity;
}

public function isQuiet()
{
return self::VERBOSITY_QUIET === $this->verbosity;
}

public function isVerbose()
{
return self::VERBOSITY_VERBOSE <= $this->verbosity;
}

public function isVeryVerbose()
{
return self::VERBOSITY_VERY_VERBOSE <= $this->verbosity;
}

public function isDebug()
{
return self::VERBOSITY_DEBUG <= $this->verbosity;
}




public function writeln($messages, $type = self::OUTPUT_NORMAL)
{
$this->write($messages, true, $type);
}




public function write($messages, $newline = false, $type = self::OUTPUT_NORMAL)
{
if (self::VERBOSITY_QUIET === $this->verbosity) {
return;
}

$messages = (array) $messages;

foreach ($messages as $message) {
switch ($type) {
case OutputInterface::OUTPUT_NORMAL:
$message = $this->formatter->format($message);
break;
case OutputInterface::OUTPUT_RAW:
break;
case OutputInterface::OUTPUT_PLAIN:
$message = strip_tags($this->formatter->format($message));
break;
default:
throw new \InvalidArgumentException(sprintf('Unknown output type given (%s)', $type));
}

$this->doWrite($message, $newline);
}
}







abstract protected function doWrite($message, $newline);
}
<?php










namespace Symfony\Component\Console\Output;

use Symfony\Component\Console\Formatter\OutputFormatterInterface;








interface OutputInterface
{
const VERBOSITY_QUIET = 0;
const VERBOSITY_NORMAL = 1;
const VERBOSITY_VERBOSE = 2;
const VERBOSITY_VERY_VERBOSE = 3;
const VERBOSITY_DEBUG = 4;

const OUTPUT_NORMAL = 0;
const OUTPUT_RAW = 1;
const OUTPUT_PLAIN = 2;












public function write($messages, $newline = false, $type = self::OUTPUT_NORMAL);











public function writeln($messages, $type = self::OUTPUT_NORMAL);








public function setVerbosity($level);








public function getVerbosity();








public function setDecorated($decorated);








public function isDecorated();








public function setFormatter(OutputFormatterInterface $formatter);








public function getFormatter();
}
<?php










namespace Symfony\Component\Console\Output;

use Symfony\Component\Console\Formatter\OutputFormatterInterface;
















class StreamOutput extends Output
{
private $stream;













public function __construct($stream, $verbosity = self::VERBOSITY_NORMAL, $decorated = null, OutputFormatterInterface $formatter = null)
{
if (!is_resource($stream) || 'stream' !== get_resource_type($stream)) {
throw new \InvalidArgumentException('The StreamOutput class needs a stream as its first argument.');
}

$this->stream = $stream;

if (null === $decorated) {
$decorated = $this->hasColorSupport();
}

parent::__construct($verbosity, $decorated, $formatter);
}






public function getStream()
{
return $this->stream;
}




protected function doWrite($message, $newline)
{
if (false === @fwrite($this->stream, $message.($newline ? PHP_EOL : ''))) {

 throw new \RuntimeException('Unable to write output.');
}

fflush($this->stream);
}











protected function hasColorSupport()
{
if (DIRECTORY_SEPARATOR == '\\') {
return false !== getenv('ANSICON') || 'ON' === getenv('ConEmuANSI');
}

return function_exists('posix_isatty') && @posix_isatty($this->stream);
}
}
<?php










namespace Symfony\Component\Console\Question;






class ChoiceQuestion extends Question
{
private $choices;
private $multiselect = false;
private $prompt = ' > ';
private $errorMessage = 'Value "%s" is invalid';








public function __construct($question, array $choices, $default = null)
{
parent::__construct($question, $default);

$this->choices = $choices;
$this->setValidator($this->getDefaultValidator());
$this->setAutocompleterValues(array_keys($choices));
}






public function getChoices()
{
return $this->choices;
}










public function setMultiselect($multiselect)
{
$this->multiselect = $multiselect;
$this->setValidator($this->getDefaultValidator());

return $this;
}






public function getPrompt()
{
return $this->prompt;
}








public function setPrompt($prompt)
{
$this->prompt = $prompt;

return $this;
}










public function setErrorMessage($errorMessage)
{
$this->errorMessage = $errorMessage;
$this->setValidator($this->getDefaultValidator());

return $this;
}






private function getDefaultValidator()
{
$choices = $this->choices;
$errorMessage = $this->errorMessage;
$multiselect = $this->multiselect;

return function ($selected) use ($choices, $errorMessage, $multiselect) {

 $selectedChoices = str_replace(' ', '', $selected);

if ($multiselect) {

 if (!preg_match('/^[a-zA-Z0-9_-]+(?:,[a-zA-Z0-9_-]+)*$/', $selectedChoices, $matches)) {
throw new \InvalidArgumentException(sprintf($errorMessage, $selected));
}
$selectedChoices = explode(',', $selectedChoices);
} else {
$selectedChoices = array($selected);
}

$multiselectChoices = array();
foreach ($selectedChoices as $value) {
if (empty($choices[$value])) {
throw new \InvalidArgumentException(sprintf($errorMessage, $value));
}
array_push($multiselectChoices, $choices[$value]);
}

if ($multiselect) {
return $multiselectChoices;
}

return $choices[$selected];
};
}
}
<?php










namespace Symfony\Component\Console\Question;






class ConfirmationQuestion extends Question
{






public function __construct($question, $default = true)
{
parent::__construct($question, (bool) $default);

$this->setNormalizer($this->getDefaultNormalizer());
}






private function getDefaultNormalizer()
{
$default = $this->getDefault();

return function ($answer) use ($default) {
if (is_bool($answer)) {
return $answer;
}

if (false === $default) {
return $answer && 'y' === strtolower($answer[0]);
}

return !$answer || 'y' === strtolower($answer[0]);
};
}
}
<?php










namespace Symfony\Component\Console\Question;






class Question
{
private $question;
private $attempts;
private $hidden = false;
private $hiddenFallback = true;
private $autocompleterValues;
private $validator;
private $default;
private $normalizer;







public function __construct($question, $default = null)
{
$this->question = $question;
$this->default = $default;
}






public function getQuestion()
{
return $this->question;
}






public function getDefault()
{
return $this->default;
}






public function isHidden()
{
return $this->hidden;
}










public function setHidden($hidden)
{
if ($this->autocompleterValues) {
throw new \LogicException('A hidden question cannot use the autocompleter.');
}

$this->hidden = (bool) $hidden;

return $this;
}






public function isHiddenFallback()
{
return $this->hiddenFallback;
}








public function setHiddenFallback($fallback)
{
$this->hiddenFallback = (bool) $fallback;

return $this;
}






public function getAutocompleterValues()
{
return $this->autocompleterValues;
}











public function setAutocompleterValues($values)
{
if (null !== $values && !is_array($values)) {
if (!$values instanceof \Traversable || $values instanceof \Countable) {
throw new \InvalidArgumentException('Autocompleter values can be either an array, `null` or an object implementing both `Countable` and `Traversable` interfaces.');
}
}

if ($this->hidden) {
throw new \LogicException('A hidden question cannot use the autocompleter.');
}

$this->autocompleterValues = $values;

return $this;
}








public function setValidator($validator)
{
$this->validator = $validator;

return $this;
}






public function getValidator()
{
return $this->validator;
}












public function setMaxAttempts($attempts)
{
if (null !== $attempts && $attempts < 1) {
throw new \InvalidArgumentException('Maximum number of attempts must be a positive value.');
}

$this->attempts = $attempts;

return $this;
}








public function getMaxAttempts()
{
return $this->attempts;
}










public function setNormalizer($normalizer)
{
$this->normalizer = $normalizer;

return $this;
}








public function getNormalizer()
{
return $this->normalizer;
}
}
<?php










namespace Symfony\Component\Console;

use Symfony\Component\Console\Input\StringInput;
use Symfony\Component\Console\Output\ConsoleOutput;
use Symfony\Component\Process\ProcessBuilder;
use Symfony\Component\Process\PhpExecutableFinder;










class Shell
{
private $application;
private $history;
private $output;
private $hasReadline;
private $processIsolation = false;









public function __construct(Application $application)
{
$this->hasReadline = function_exists('readline');
$this->application = $application;
$this->history = getenv('HOME').'/.history_'.$application->getName();
$this->output = new ConsoleOutput();
}




public function run()
{
$this->application->setAutoExit(false);
$this->application->setCatchExceptions(true);

if ($this->hasReadline) {
readline_read_history($this->history);
readline_completion_function(array($this, 'autocompleter'));
}

$this->output->writeln($this->getHeader());
$php = null;
if ($this->processIsolation) {
$finder = new PhpExecutableFinder();
$php = $finder->find();
$this->output->writeln(<<<EOF
<info>Running with process isolation, you should consider this:</info>
  * each command is executed as separate process,
  * commands don't support interactivity, all params must be passed explicitly,
  * commands output is not colorized.

EOF
);
}

while (true) {
$command = $this->readline();

if (false === $command) {
$this->output->writeln("\n");

break;
}

if ($this->hasReadline) {
readline_add_history($command);
readline_write_history($this->history);
}

if ($this->processIsolation) {
$pb = new ProcessBuilder();

$process = $pb
->add($php)
->add($_SERVER['argv'][0])
->add($command)
->inheritEnvironmentVariables(true)
->getProcess()
;

$output = $this->output;
$process->run(function ($type, $data) use ($output) {
$output->writeln($data);
});

$ret = $process->getExitCode();
} else {
$ret = $this->application->run(new StringInput($command), $this->output);
}

if (0 !== $ret) {
$this->output->writeln(sprintf('<error>The command terminated with an error status (%s)</error>', $ret));
}
}
}






protected function getHeader()
{
return <<<EOF

Welcome to the <info>{$this->application->getName()}</info> shell (<comment>{$this->application->getVersion()}</comment>).

At the prompt, type <comment>help</comment> for some help,
or <comment>list</comment> to get a list of available commands.

To exit the shell, type <comment>^D</comment>.

EOF;
}






protected function getPrompt()
{

 return $this->output->getFormatter()->format($this->application->getName().' > ');
}

protected function getOutput()
{
return $this->output;
}

protected function getApplication()
{
return $this->application;
}








private function autocompleter($text)
{
$info = readline_info();
$text = substr($info['line_buffer'], 0, $info['end']);

if ($info['point'] !== $info['end']) {
return true;
}


 if (false === strpos($text, ' ') || !$text) {
return array_keys($this->application->all());
}


 try {
$command = $this->application->find(substr($text, 0, strpos($text, ' ')));
} catch (\Exception $e) {
return true;
}

$list = array('--help');
foreach ($command->getDefinition()->getOptions() as $option) {
$list[] = '--'.$option->getName();
}

return $list;
}






private function readline()
{
if ($this->hasReadline) {
$line = readline($this->getPrompt());
} else {
$this->output->write($this->getPrompt());
$line = fgets(STDIN, 1024);
$line = (!$line && strlen($line) == 0) ? false : rtrim($line);
}

return $line;
}

public function getProcessIsolation()
{
return $this->processIsolation;
}

public function setProcessIsolation($processIsolation)
{
$this->processIsolation = (bool) $processIsolation;

if ($this->processIsolation && !class_exists('Symfony\\Component\\Process\\Process')) {
throw new \RuntimeException('Unable to isolate processes as the Symfony Process Component is not installed.');
}
}
}
<?php










namespace Symfony\Component\Console\Tester;

use Symfony\Component\Console\Application;
use Symfony\Component\Console\Input\ArrayInput;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Output\StreamOutput;











class ApplicationTester
{
private $application;
private $input;
private $output;
private $statusCode;






public function __construct(Application $application)
{
$this->application = $application;
}















public function run(array $input, $options = array())
{
$this->input = new ArrayInput($input);
if (isset($options['interactive'])) {
$this->input->setInteractive($options['interactive']);
}

$this->output = new StreamOutput(fopen('php://memory', 'w', false));
if (isset($options['decorated'])) {
$this->output->setDecorated($options['decorated']);
}
if (isset($options['verbosity'])) {
$this->output->setVerbosity($options['verbosity']);
}

return $this->statusCode = $this->application->run($this->input, $this->output);
}








public function getDisplay($normalize = false)
{
rewind($this->output->getStream());

$display = stream_get_contents($this->output->getStream());

if ($normalize) {
$display = str_replace(PHP_EOL, "\n", $display);
}

return $display;
}






public function getInput()
{
return $this->input;
}






public function getOutput()
{
return $this->output;
}






public function getStatusCode()
{
return $this->statusCode;
}
}
<?php










namespace Symfony\Component\Console\Tester;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\ArrayInput;
use Symfony\Component\Console\Output\StreamOutput;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;






class CommandTester
{
private $command;
private $input;
private $output;
private $statusCode;






public function __construct(Command $command)
{
$this->command = $command;
}















public function execute(array $input, array $options = array())
{

 
 if (!isset($input['command'])
&& (null !== $application = $this->command->getApplication())
&& $application->getDefinition()->hasArgument('command')
) {
$input['command'] = $this->command->getName();
}

$this->input = new ArrayInput($input);
if (isset($options['interactive'])) {
$this->input->setInteractive($options['interactive']);
}

$this->output = new StreamOutput(fopen('php://memory', 'w', false));
if (isset($options['decorated'])) {
$this->output->setDecorated($options['decorated']);
}
if (isset($options['verbosity'])) {
$this->output->setVerbosity($options['verbosity']);
}

return $this->statusCode = $this->command->run($this->input, $this->output);
}








public function getDisplay($normalize = false)
{
rewind($this->output->getStream());

$display = stream_get_contents($this->output->getStream());

if ($normalize) {
$display = str_replace(PHP_EOL, "\n", $display);
}

return $display;
}






public function getInput()
{
return $this->input;
}






public function getOutput()
{
return $this->output;
}






public function getStatusCode()
{
return $this->statusCode;
}
}
<?php










namespace Symfony\Component\Finder\Adapter;






abstract class AbstractAdapter implements AdapterInterface
{
protected $followLinks = false;
protected $mode = 0;
protected $minDepth = 0;
protected $maxDepth = PHP_INT_MAX;
protected $exclude = array();
protected $names = array();
protected $notNames = array();
protected $contains = array();
protected $notContains = array();
protected $sizes = array();
protected $dates = array();
protected $filters = array();
protected $sort = false;
protected $paths = array();
protected $notPaths = array();
protected $ignoreUnreadableDirs = false;

private static $areSupported = array();




public function isSupported()
{
$name = $this->getName();

if (!array_key_exists($name, self::$areSupported)) {
self::$areSupported[$name] = $this->canBeUsed();
}

return self::$areSupported[$name];
}




public function setFollowLinks($followLinks)
{
$this->followLinks = $followLinks;

return $this;
}




public function setMode($mode)
{
$this->mode = $mode;

return $this;
}




public function setDepths(array $depths)
{
$this->minDepth = 0;
$this->maxDepth = PHP_INT_MAX;

foreach ($depths as $comparator) {
switch ($comparator->getOperator()) {
case '>':
$this->minDepth = $comparator->getTarget() + 1;
break;
case '>=':
$this->minDepth = $comparator->getTarget();
break;
case '<':
$this->maxDepth = $comparator->getTarget() - 1;
break;
case '<=':
$this->maxDepth = $comparator->getTarget();
break;
default:
$this->minDepth = $this->maxDepth = $comparator->getTarget();
}
}

return $this;
}




public function setExclude(array $exclude)
{
$this->exclude = $exclude;

return $this;
}




public function setNames(array $names)
{
$this->names = $names;

return $this;
}




public function setNotNames(array $notNames)
{
$this->notNames = $notNames;

return $this;
}




public function setContains(array $contains)
{
$this->contains = $contains;

return $this;
}




public function setNotContains(array $notContains)
{
$this->notContains = $notContains;

return $this;
}




public function setSizes(array $sizes)
{
$this->sizes = $sizes;

return $this;
}




public function setDates(array $dates)
{
$this->dates = $dates;

return $this;
}




public function setFilters(array $filters)
{
$this->filters = $filters;

return $this;
}




public function setSort($sort)
{
$this->sort = $sort;

return $this;
}




public function setPath(array $paths)
{
$this->paths = $paths;

return $this;
}




public function setNotPath(array $notPaths)
{
$this->notPaths = $notPaths;

return $this;
}




public function ignoreUnreadableDirs($ignore = true)
{
$this->ignoreUnreadableDirs = (bool) $ignore;

return $this;
}












abstract protected function canBeUsed();
}
<?php










namespace Symfony\Component\Finder\Adapter;

use Symfony\Component\Finder\Exception\AccessDeniedException;
use Symfony\Component\Finder\Iterator;
use Symfony\Component\Finder\Shell\Shell;
use Symfony\Component\Finder\Expression\Expression;
use Symfony\Component\Finder\Shell\Command;
use Symfony\Component\Finder\Comparator\NumberComparator;
use Symfony\Component\Finder\Comparator\DateComparator;






abstract class AbstractFindAdapter extends AbstractAdapter
{



protected $shell;




public function __construct()
{
$this->shell = new Shell();
}




public function searchInDirectory($dir)
{

 $dir = realpath($dir);


 if (Iterator\FileTypeFilterIterator::ONLY_DIRECTORIES === $this->mode && ($this->contains || $this->notContains)) {
return new Iterator\FilePathsIterator(array(), $dir);
}

$command = Command::create();
$find = $this->buildFindCommand($command, $dir);

if ($this->followLinks) {
$find->add('-follow');
}

$find->add('-mindepth')->add($this->minDepth + 1);

if (PHP_INT_MAX !== $this->maxDepth) {
$find->add('-maxdepth')->add($this->maxDepth + 1);
}

if (Iterator\FileTypeFilterIterator::ONLY_DIRECTORIES === $this->mode) {
$find->add('-type d');
} elseif (Iterator\FileTypeFilterIterator::ONLY_FILES === $this->mode) {
$find->add('-type f');
}

$this->buildNamesFiltering($find, $this->names);
$this->buildNamesFiltering($find, $this->notNames, true);
$this->buildPathsFiltering($find, $dir, $this->paths);
$this->buildPathsFiltering($find, $dir, $this->notPaths, true);
$this->buildSizesFiltering($find, $this->sizes);
$this->buildDatesFiltering($find, $this->dates);

$useGrep = $this->shell->testCommand('grep') && $this->shell->testCommand('xargs');
$useSort = is_int($this->sort) && $this->shell->testCommand('sort') && $this->shell->testCommand('cut');

if ($useGrep && ($this->contains || $this->notContains)) {
$grep = $command->ins('grep');
$this->buildContentFiltering($grep, $this->contains);
$this->buildContentFiltering($grep, $this->notContains, true);
}

if ($useSort) {
$this->buildSorting($command, $this->sort);
}

$command->setErrorHandler(
$this->ignoreUnreadableDirs

 ? function ($stderr) { return; }
: function ($stderr) { throw new AccessDeniedException($stderr); }
);

$paths = $this->shell->testCommand('uniq') ? $command->add('| uniq')->execute() : array_unique($command->execute());
$iterator = new Iterator\FilePathsIterator($paths, $dir);

if ($this->exclude) {
$iterator = new Iterator\ExcludeDirectoryFilterIterator($iterator, $this->exclude);
}

if (!$useGrep && ($this->contains || $this->notContains)) {
$iterator = new Iterator\FilecontentFilterIterator($iterator, $this->contains, $this->notContains);
}

if ($this->filters) {
$iterator = new Iterator\CustomFilterIterator($iterator, $this->filters);
}

if (!$useSort && $this->sort) {
$iteratorAggregate = new Iterator\SortableIterator($iterator, $this->sort);
$iterator = $iteratorAggregate->getIterator();
}

return $iterator;
}




protected function canBeUsed()
{
return $this->shell->testCommand('find');
}







protected function buildFindCommand(Command $command, $dir)
{
return $command
->ins('find')
->add('find ')
->arg($dir)
->add('-noleaf'); 
 }






private function buildNamesFiltering(Command $command, array $names, $not = false)
{
if (0 === count($names)) {
return;
}

$command->add($not ? '-not' : null)->cmd('(');

foreach ($names as $i => $name) {
$expr = Expression::create($name);


 if ($expr->isGlob() && $expr->getGlob()->isExpandable()) {
$expr = Expression::create($expr->getGlob()->toRegex(false));
}


 
 
 if ($expr->isRegex()) {
$regex = $expr->getRegex();
$regex->prepend($regex->hasStartFlag() ? '/' : '/[^/]*')
->setStartFlag(false)
->setStartJoker(true)
->replaceJokers('[^/]');
if (!$regex->hasEndFlag() || $regex->hasEndJoker()) {
$regex->setEndJoker(false)->append('[^/]*');
}
}

$command
->add($i > 0 ? '-or' : null)
->add($expr->isRegex()
? ($expr->isCaseSensitive() ? '-regex' : '-iregex')
: ($expr->isCaseSensitive() ? '-name' : '-iname')
)
->arg($expr->renderPattern());
}

$command->cmd(')');
}







private function buildPathsFiltering(Command $command, $dir, array $paths, $not = false)
{
if (0 === count($paths)) {
return;
}

$command->add($not ? '-not' : null)->cmd('(');

foreach ($paths as $i => $path) {
$expr = Expression::create($path);


 if ($expr->isGlob() && $expr->getGlob()->isExpandable()) {
$expr = Expression::create($expr->getGlob()->toRegex(false));
}


 if ($expr->isRegex()) {
$regex = $expr->getRegex();
$regex->prepend($regex->hasStartFlag() ? preg_quote($dir).DIRECTORY_SEPARATOR : '.*')->setEndJoker(!$regex->hasEndFlag());
} else {
$expr->prepend('*')->append('*');
}

$command
->add($i > 0 ? '-or' : null)
->add($expr->isRegex()
? ($expr->isCaseSensitive() ? '-regex' : '-iregex')
: ($expr->isCaseSensitive() ? '-path' : '-ipath')
)
->arg($expr->renderPattern());
}

$command->cmd(')');
}





private function buildSizesFiltering(Command $command, array $sizes)
{
foreach ($sizes as $i => $size) {
$command->add($i > 0 ? '-and' : null);

switch ($size->getOperator()) {
case '<=':
$command->add('-size -'.($size->getTarget() + 1).'c');
break;
case '>=':
$command->add('-size +'.($size->getTarget() - 1).'c');
break;
case '>':
$command->add('-size +'.$size->getTarget().'c');
break;
case '!=':
$command->add('-size -'.$size->getTarget().'c');
$command->add('-size +'.$size->getTarget().'c');
break;
case '<':
default:
$command->add('-size -'.$size->getTarget().'c');
}
}
}





private function buildDatesFiltering(Command $command, array $dates)
{
foreach ($dates as $i => $date) {
$command->add($i > 0 ? '-and' : null);

$mins = (int) round((time() - $date->getTarget()) / 60);

if (0 > $mins) {

 $command->add(' -mmin -0');

 return;
}

switch ($date->getOperator()) {
case '<=':
$command->add('-mmin +'.($mins - 1));
break;
case '>=':
$command->add('-mmin -'.($mins + 1));
break;
case '>':
$command->add('-mmin -'.$mins);
break;
case '!=':
$command->add('-mmin +'.$mins.' -or -mmin -'.$mins);
break;
case '<':
default:
$command->add('-mmin +'.$mins);
}
}
}







private function buildSorting(Command $command, $sort)
{
$this->buildFormatSorting($command, $sort);
}





abstract protected function buildFormatSorting(Command $command, $sort);






abstract protected function buildContentFiltering(Command $command, array $contains, $not = false);
}
<?php










namespace Symfony\Component\Finder\Adapter;




interface AdapterInterface
{





public function setFollowLinks($followLinks);






public function setMode($mode);






public function setExclude(array $exclude);






public function setDepths(array $depths);






public function setNames(array $names);






public function setNotNames(array $notNames);






public function setContains(array $contains);






public function setNotContains(array $notContains);






public function setSizes(array $sizes);






public function setDates(array $dates);






public function setFilters(array $filters);






public function setSort($sort);






public function setPath(array $paths);






public function setNotPath(array $notPaths);






public function ignoreUnreadableDirs($ignore = true);






public function searchInDirectory($dir);






public function isSupported();






public function getName();
}
<?php










namespace Symfony\Component\Finder\Adapter;

use Symfony\Component\Finder\Shell\Shell;
use Symfony\Component\Finder\Shell\Command;
use Symfony\Component\Finder\Iterator\SortableIterator;
use Symfony\Component\Finder\Expression\Expression;






class BsdFindAdapter extends AbstractFindAdapter
{



public function getName()
{
return 'bsd_find';
}




protected function canBeUsed()
{
return in_array($this->shell->getType(), array(Shell::TYPE_BSD, Shell::TYPE_DARWIN)) && parent::canBeUsed();
}




protected function buildFormatSorting(Command $command, $sort)
{
switch ($sort) {
case SortableIterator::SORT_BY_NAME:
$command->ins('sort')->add('| sort');

return;
case SortableIterator::SORT_BY_TYPE:
$format = '%HT';
break;
case SortableIterator::SORT_BY_ACCESSED_TIME:
$format = '%a';
break;
case SortableIterator::SORT_BY_CHANGED_TIME:
$format = '%c';
break;
case SortableIterator::SORT_BY_MODIFIED_TIME:
$format = '%m';
break;
default:
throw new \InvalidArgumentException(sprintf('Unknown sort options: %s.', $sort));
}

$command
->add('-print0 | xargs -0 stat -f')
->arg($format.'%t%N')
->add('| sort | cut -f 2');
}




protected function buildFindCommand(Command $command, $dir)
{
parent::buildFindCommand($command, $dir)->addAtIndex('-E', 1);

return $command;
}




protected function buildContentFiltering(Command $command, array $contains, $not = false)
{
foreach ($contains as $contain) {
$expr = Expression::create($contain);


 $command
->add('| grep -v \'^$\'')
->add('| xargs -I{} grep -I')
->add($expr->isCaseSensitive() ? null : '-i')
->add($not ? '-L' : '-l')
->add('-Ee')->arg($expr->renderPattern())
->add('{}')
;
}
}
}
<?php










namespace Symfony\Component\Finder\Adapter;

use Symfony\Component\Finder\Shell\Shell;
use Symfony\Component\Finder\Shell\Command;
use Symfony\Component\Finder\Iterator\SortableIterator;
use Symfony\Component\Finder\Expression\Expression;






class GnuFindAdapter extends AbstractFindAdapter
{



public function getName()
{
return 'gnu_find';
}




protected function buildFormatSorting(Command $command, $sort)
{
switch ($sort) {
case SortableIterator::SORT_BY_NAME:
$command->ins('sort')->add('| sort');

return;
case SortableIterator::SORT_BY_TYPE:
$format = '%y';
break;
case SortableIterator::SORT_BY_ACCESSED_TIME:
$format = '%A@';
break;
case SortableIterator::SORT_BY_CHANGED_TIME:
$format = '%C@';
break;
case SortableIterator::SORT_BY_MODIFIED_TIME:
$format = '%T@';
break;
default:
throw new \InvalidArgumentException(sprintf('Unknown sort options: %s.', $sort));
}

$command
->get('find')
->add('-printf')
->arg($format.' %h/%f\\n')
->add('| sort | cut')
->arg('-d ')
->arg('-f2-')
;
}




protected function canBeUsed()
{
return $this->shell->getType() === Shell::TYPE_UNIX && parent::canBeUsed();
}




protected function buildFindCommand(Command $command, $dir)
{
return parent::buildFindCommand($command, $dir)->add('-regextype posix-extended');
}




protected function buildContentFiltering(Command $command, array $contains, $not = false)
{
foreach ($contains as $contain) {
$expr = Expression::create($contain);


 $command
->add('| xargs -I{} -r grep -I')
->add($expr->isCaseSensitive() ? null : '-i')
->add($not ? '-L' : '-l')
->add('-Ee')->arg($expr->renderPattern())
->add('{}')
;
}
}
}
<?php










namespace Symfony\Component\Finder\Adapter;

use Symfony\Component\Finder\Iterator;






class PhpAdapter extends AbstractAdapter
{



public function searchInDirectory($dir)
{
$flags = \RecursiveDirectoryIterator::SKIP_DOTS;

if ($this->followLinks) {
$flags |= \RecursiveDirectoryIterator::FOLLOW_SYMLINKS;
}

$iterator = new \RecursiveIteratorIterator(
new Iterator\RecursiveDirectoryIterator($dir, $flags, $this->ignoreUnreadableDirs),
\RecursiveIteratorIterator::SELF_FIRST
);

if ($this->minDepth > 0 || $this->maxDepth < PHP_INT_MAX) {
$iterator = new Iterator\DepthRangeFilterIterator($iterator, $this->minDepth, $this->maxDepth);
}

if ($this->mode) {
$iterator = new Iterator\FileTypeFilterIterator($iterator, $this->mode);
}

if ($this->exclude) {
$iterator = new Iterator\ExcludeDirectoryFilterIterator($iterator, $this->exclude);
}

if ($this->names || $this->notNames) {
$iterator = new Iterator\FilenameFilterIterator($iterator, $this->names, $this->notNames);
}

if ($this->contains || $this->notContains) {
$iterator = new Iterator\FilecontentFilterIterator($iterator, $this->contains, $this->notContains);
}

if ($this->sizes) {
$iterator = new Iterator\SizeRangeFilterIterator($iterator, $this->sizes);
}

if ($this->dates) {
$iterator = new Iterator\DateRangeFilterIterator($iterator, $this->dates);
}

if ($this->filters) {
$iterator = new Iterator\CustomFilterIterator($iterator, $this->filters);
}

if ($this->sort) {
$iteratorAggregate = new Iterator\SortableIterator($iterator, $this->sort);
$iterator = $iteratorAggregate->getIterator();
}

if ($this->paths || $this->notPaths) {
$iterator = new Iterator\PathFilterIterator($iterator, $this->paths, $this->notPaths);
}

return $iterator;
}




public function getName()
{
return 'php';
}




protected function canBeUsed()
{
return true;
}
}
<?php










namespace Symfony\Component\Finder\Comparator;






class Comparator
{
private $target;
private $operator = '==';






public function getTarget()
{
return $this->target;
}






public function setTarget($target)
{
$this->target = $target;
}






public function getOperator()
{
return $this->operator;
}








public function setOperator($operator)
{
if (!$operator) {
$operator = '==';
}

if (!in_array($operator, array('>', '<', '>=', '<=', '==', '!='))) {
throw new \InvalidArgumentException(sprintf('Invalid operator "%s".', $operator));
}

$this->operator = $operator;
}








public function test($test)
{
switch ($this->operator) {
case '>':
return $test > $this->target;
case '>=':
return $test >= $this->target;
case '<':
return $test < $this->target;
case '<=':
return $test <= $this->target;
case '!=':
return $test != $this->target;
}

return $test == $this->target;
}
}
<?php










namespace Symfony\Component\Finder\Comparator;






class DateComparator extends Comparator
{







public function __construct($test)
{
if (!preg_match('#^\s*(==|!=|[<>]=?|after|since|before|until)?\s*(.+?)\s*$#i', $test, $matches)) {
throw new \InvalidArgumentException(sprintf('Don\'t understand "%s" as a date test.', $test));
}

try {
$date = new \DateTime($matches[2]);
$target = $date->format('U');
} catch (\Exception $e) {
throw new \InvalidArgumentException(sprintf('"%s" is not a valid date.', $matches[2]));
}

$operator = isset($matches[1]) ? $matches[1] : '==';
if ('since' === $operator || 'after' === $operator) {
$operator = '>';
}

if ('until' === $operator || 'before' === $operator) {
$operator = '<';
}

$this->setOperator($operator);
$this->setTarget($target);
}
}
<?php










namespace Symfony\Component\Finder\Comparator;






















class NumberComparator extends Comparator
{







public function __construct($test)
{
if (!preg_match('#^\s*(==|!=|[<>]=?)?\s*([0-9\.]+)\s*([kmg]i?)?\s*$#i', $test, $matches)) {
throw new \InvalidArgumentException(sprintf('Don\'t understand "%s" as a number test.', $test));
}

$target = $matches[2];
if (!is_numeric($target)) {
throw new \InvalidArgumentException(sprintf('Invalid number "%s".', $target));
}
if (isset($matches[3])) {

 switch (strtolower($matches[3])) {
case 'k':
$target *= 1000;
break;
case 'ki':
$target *= 1024;
break;
case 'm':
$target *= 1000000;
break;
case 'mi':
$target *= 1024 * 1024;
break;
case 'g':
$target *= 1000000000;
break;
case 'gi':
$target *= 1024 * 1024 * 1024;
break;
}
}

$this->setTarget($target);
$this->setOperator(isset($matches[1]) ? $matches[1] : '==');
}
}
<?php










namespace Symfony\Component\Finder\Exception;




class AccessDeniedException extends \UnexpectedValueException
{
}
<?php










namespace Symfony\Component\Finder\Exception;

use Symfony\Component\Finder\Adapter\AdapterInterface;






class AdapterFailureException extends \RuntimeException implements ExceptionInterface
{



private $adapter;






public function __construct(AdapterInterface $adapter, $message = null, \Exception $previous = null)
{
$this->adapter = $adapter;
parent::__construct($message ?: 'Search failed with "'.$adapter->getName().'" adapter.', $previous);
}




public function getAdapter()
{
return $this->adapter;
}
}
<?php










namespace Symfony\Component\Finder\Exception;




interface ExceptionInterface
{



public function getAdapter();
}
<?php










namespace Symfony\Component\Finder\Exception;




class OperationNotPermitedException extends AdapterFailureException
{
}
<?php










namespace Symfony\Component\Finder\Exception;

use Symfony\Component\Finder\Adapter\AdapterInterface;
use Symfony\Component\Finder\Shell\Command;




class ShellCommandFailureException extends AdapterFailureException
{



private $command;






public function __construct(AdapterInterface $adapter, Command $command, \Exception $previous = null)
{
$this->command = $command;
parent::__construct($adapter, 'Shell command failed: "'.$command->join().'".', $previous);
}




public function getCommand()
{
return $this->command;
}
}
<?php










namespace Symfony\Component\Finder\Expression;




class Expression implements ValueInterface
{
const TYPE_REGEX = 1;
const TYPE_GLOB = 2;




private $value;






public static function create($expr)
{
return new self($expr);
}




public function __construct($expr)
{
try {
$this->value = Regex::create($expr);
} catch (\InvalidArgumentException $e) {
$this->value = new Glob($expr);
}
}




public function __toString()
{
return $this->render();
}




public function render()
{
return $this->value->render();
}




public function renderPattern()
{
return $this->value->renderPattern();
}




public function isCaseSensitive()
{
return $this->value->isCaseSensitive();
}




public function getType()
{
return $this->value->getType();
}




public function prepend($expr)
{
$this->value->prepend($expr);

return $this;
}




public function append($expr)
{
$this->value->append($expr);

return $this;
}




public function isRegex()
{
return self::TYPE_REGEX === $this->value->getType();
}




public function isGlob()
{
return self::TYPE_GLOB === $this->value->getType();
}






public function getGlob()
{
if (self::TYPE_GLOB !== $this->value->getType()) {
throw new \LogicException('Regex can\'t be transformed to glob.');
}

return $this->value;
}




public function getRegex()
{
return self::TYPE_REGEX === $this->value->getType() ? $this->value : $this->value->toRegex();
}
}
<?php










namespace Symfony\Component\Finder\Expression;




class Glob implements ValueInterface
{



private $pattern;




public function __construct($pattern)
{
$this->pattern = $pattern;
}




public function render()
{
return $this->pattern;
}




public function renderPattern()
{
return $this->pattern;
}




public function getType()
{
return Expression::TYPE_GLOB;
}




public function isCaseSensitive()
{
return true;
}




public function prepend($expr)
{
$this->pattern = $expr.$this->pattern;

return $this;
}




public function append($expr)
{
$this->pattern .= $expr;

return $this;
}






public function isExpandable()
{
return false !== strpos($this->pattern, '{')
&& false !== strpos($this->pattern, '}');
}







public function toRegex($strictLeadingDot = true, $strictWildcardSlash = true)
{
$firstByte = true;
$escaping = false;
$inCurlies = 0;
$regex = '';
$sizeGlob = strlen($this->pattern);
for ($i = 0; $i < $sizeGlob; $i++) {
$car = $this->pattern[$i];
if ($firstByte) {
if ($strictLeadingDot && '.' !== $car) {
$regex .= '(?=[^\.])';
}

$firstByte = false;
}

if ('/' === $car) {
$firstByte = true;
}

if ('.' === $car || '(' === $car || ')' === $car || '|' === $car || '+' === $car || '^' === $car || '$' === $car) {
$regex .= "\\$car";
} elseif ('*' === $car) {
$regex .= $escaping ? '\\*' : ($strictWildcardSlash ? '[^/]*' : '.*');
} elseif ('?' === $car) {
$regex .= $escaping ? '\\?' : ($strictWildcardSlash ? '[^/]' : '.');
} elseif ('{' === $car) {
$regex .= $escaping ? '\\{' : '(';
if (!$escaping) {
++$inCurlies;
}
} elseif ('}' === $car && $inCurlies) {
$regex .= $escaping ? '}' : ')';
if (!$escaping) {
--$inCurlies;
}
} elseif (',' === $car && $inCurlies) {
$regex .= $escaping ? ',' : '|';
} elseif ('\\' === $car) {
if ($escaping) {
$regex .= '\\\\';
$escaping = false;
} else {
$escaping = true;
}

continue;
} else {
$regex .= $car;
}
$escaping = false;
}

return new Regex('^'.$regex.'$');
}
}
<?php










namespace Symfony\Component\Finder\Expression;




class Regex implements ValueInterface
{
const START_FLAG = '^';
const END_FLAG = '$';
const BOUNDARY = '~';
const JOKER = '.*';
const ESCAPING = '\\';




private $pattern;




private $options;




private $startFlag;




private $endFlag;




private $startJoker;




private $endJoker;








public static function create($expr)
{
if (preg_match('/^(.{3,}?)([imsxuADU]*)$/', $expr, $m)) {
$start = substr($m[1], 0, 1);
$end = substr($m[1], -1);

if (
($start === $end && !preg_match('/[*?[:alnum:] \\\\]/', $start))
|| ($start === '{' && $end === '}')
|| ($start === '(' && $end === ')')
) {
return new self(substr($m[1], 1, -1), $m[2], $end);
}
}

throw new \InvalidArgumentException('Given expression is not a regex.');
}






public function __construct($pattern, $options = '', $delimiter = null)
{
if (null !== $delimiter) {

 $pattern = str_replace('\\'.$delimiter, $delimiter, $pattern);
}

$this->parsePattern($pattern);
$this->options = $options;
}




public function __toString()
{
return $this->render();
}




public function render()
{
return self::BOUNDARY
.$this->renderPattern()
.self::BOUNDARY
.$this->options;
}




public function renderPattern()
{
return ($this->startFlag ? self::START_FLAG : '')
.($this->startJoker ? self::JOKER : '')
.str_replace(self::BOUNDARY, '\\'.self::BOUNDARY, $this->pattern)
.($this->endJoker ? self::JOKER : '')
.($this->endFlag ? self::END_FLAG : '');
}




public function isCaseSensitive()
{
return !$this->hasOption('i');
}




public function getType()
{
return Expression::TYPE_REGEX;
}




public function prepend($expr)
{
$this->pattern = $expr.$this->pattern;

return $this;
}




public function append($expr)
{
$this->pattern .= $expr;

return $this;
}






public function hasOption($option)
{
return false !== strpos($this->options, $option);
}






public function addOption($option)
{
if (!$this->hasOption($option)) {
$this->options .= $option;
}

return $this;
}






public function removeOption($option)
{
$this->options = str_replace($option, '', $this->options);

return $this;
}






public function setStartFlag($startFlag)
{
$this->startFlag = $startFlag;

return $this;
}




public function hasStartFlag()
{
return $this->startFlag;
}






public function setEndFlag($endFlag)
{
$this->endFlag = (bool) $endFlag;

return $this;
}




public function hasEndFlag()
{
return $this->endFlag;
}






public function setStartJoker($startJoker)
{
$this->startJoker = $startJoker;

return $this;
}




public function hasStartJoker()
{
return $this->startJoker;
}






public function setEndJoker($endJoker)
{
$this->endJoker = (bool) $endJoker;

return $this;
}




public function hasEndJoker()
{
return $this->endJoker;
}






public function replaceJokers($replacement)
{
$replace = function ($subject) use ($replacement) {
$subject = $subject[0];
$replace = 0 === substr_count($subject, '\\') % 2;

return $replace ? str_replace('.', $replacement, $subject) : $subject;
};

$this->pattern = preg_replace_callback('~[\\\\]*\\.~', $replace, $this->pattern);

return $this;
}




private function parsePattern($pattern)
{
if ($this->startFlag = self::START_FLAG === substr($pattern, 0, 1)) {
$pattern = substr($pattern, 1);
}

if ($this->startJoker = self::JOKER === substr($pattern, 0, 2)) {
$pattern = substr($pattern, 2);
}

if ($this->endFlag = (self::END_FLAG === substr($pattern, -1) && self::ESCAPING !== substr($pattern, -2, -1))) {
$pattern = substr($pattern, 0, -1);
}

if ($this->endJoker = (self::JOKER === substr($pattern, -2) && self::ESCAPING !== substr($pattern, -3, -2))) {
$pattern = substr($pattern, 0, -2);
}

$this->pattern = $pattern;
}
}
<?php










namespace Symfony\Component\Finder\Expression;




interface ValueInterface
{





public function render();






public function renderPattern();






public function isCaseSensitive();






public function getType();






public function prepend($expr);






public function append($expr);
}
<?php










namespace Symfony\Component\Finder;

use Symfony\Component\Finder\Adapter\AdapterInterface;
use Symfony\Component\Finder\Adapter\GnuFindAdapter;
use Symfony\Component\Finder\Adapter\BsdFindAdapter;
use Symfony\Component\Finder\Adapter\PhpAdapter;
use Symfony\Component\Finder\Comparator\DateComparator;
use Symfony\Component\Finder\Comparator\NumberComparator;
use Symfony\Component\Finder\Exception\ExceptionInterface;
use Symfony\Component\Finder\Iterator\CustomFilterIterator;
use Symfony\Component\Finder\Iterator\DateRangeFilterIterator;
use Symfony\Component\Finder\Iterator\DepthRangeFilterIterator;
use Symfony\Component\Finder\Iterator\ExcludeDirectoryFilterIterator;
use Symfony\Component\Finder\Iterator\FilecontentFilterIterator;
use Symfony\Component\Finder\Iterator\FilenameFilterIterator;
use Symfony\Component\Finder\Iterator\SizeRangeFilterIterator;
use Symfony\Component\Finder\Iterator\SortableIterator;
















class Finder implements \IteratorAggregate, \Countable
{
const IGNORE_VCS_FILES = 1;
const IGNORE_DOT_FILES = 2;

private $mode = 0;
private $names = array();
private $notNames = array();
private $exclude = array();
private $filters = array();
private $depths = array();
private $sizes = array();
private $followLinks = false;
private $sort = false;
private $ignore = 0;
private $dirs = array();
private $dates = array();
private $iterators = array();
private $contains = array();
private $notContains = array();
private $adapters = array();
private $paths = array();
private $notPaths = array();
private $ignoreUnreadableDirs = false;

private static $vcsPatterns = array('.svn', '_svn', 'CVS', '_darcs', '.arch-params', '.monotone', '.bzr', '.git', '.hg');




public function __construct()
{
$this->ignore = static::IGNORE_VCS_FILES | static::IGNORE_DOT_FILES;

$this
->addAdapter(new GnuFindAdapter())
->addAdapter(new BsdFindAdapter())
->addAdapter(new PhpAdapter(), -50)
->setAdapter('php')
;
}








public static function create()
{
return new static();
}









public function addAdapter(AdapterInterface $adapter, $priority = 0)
{
$this->adapters[$adapter->getName()] = array(
'adapter' => $adapter,
'priority' => $priority,
'selected' => false,
);

return $this->sortAdapters();
}






public function useBestAdapter()
{
$this->resetAdapterSelection();

return $this->sortAdapters();
}










public function setAdapter($name)
{
if (!isset($this->adapters[$name])) {
throw new \InvalidArgumentException(sprintf('Adapter "%s" does not exist.', $name));
}

$this->resetAdapterSelection();
$this->adapters[$name]['selected'] = true;

return $this->sortAdapters();
}






public function removeAdapters()
{
$this->adapters = array();

return $this;
}






public function getAdapters()
{
return array_values(array_map(function (array $adapter) {
return $adapter['adapter'];
}, $this->adapters));
}








public function directories()
{
$this->mode = Iterator\FileTypeFilterIterator::ONLY_DIRECTORIES;

return $this;
}








public function files()
{
$this->mode = Iterator\FileTypeFilterIterator::ONLY_FILES;

return $this;
}


















public function depth($level)
{
$this->depths[] = new Comparator\NumberComparator($level);

return $this;
}





















public function date($date)
{
$this->dates[] = new Comparator\DateComparator($date);

return $this;
}


















public function name($pattern)
{
$this->names[] = $pattern;

return $this;
}












public function notName($pattern)
{
$this->notNames[] = $pattern;

return $this;
}















public function contains($pattern)
{
$this->contains[] = $pattern;

return $this;
}















public function notContains($pattern)
{
$this->notContains[] = $pattern;

return $this;
}

















public function path($pattern)
{
$this->paths[] = $pattern;

return $this;
}

















public function notPath($pattern)
{
$this->notPaths[] = $pattern;

return $this;
}

















public function size($size)
{
$this->sizes[] = new Comparator\NumberComparator($size);

return $this;
}












public function exclude($dirs)
{
$this->exclude = array_merge($this->exclude, (array) $dirs);

return $this;
}












public function ignoreDotFiles($ignoreDotFiles)
{
if ($ignoreDotFiles) {
$this->ignore |= static::IGNORE_DOT_FILES;
} else {
$this->ignore &= ~static::IGNORE_DOT_FILES;
}

return $this;
}












public function ignoreVCS($ignoreVCS)
{
if ($ignoreVCS) {
$this->ignore |= static::IGNORE_VCS_FILES;
} else {
$this->ignore &= ~static::IGNORE_VCS_FILES;
}

return $this;
}








public static function addVCSPattern($pattern)
{
foreach ((array) $pattern as $p) {
self::$vcsPatterns[] = $p;
}

self::$vcsPatterns = array_unique(self::$vcsPatterns);
}
















public function sort(\Closure $closure)
{
$this->sort = $closure;

return $this;
}












public function sortByName()
{
$this->sort = Iterator\SortableIterator::SORT_BY_NAME;

return $this;
}












public function sortByType()
{
$this->sort = Iterator\SortableIterator::SORT_BY_TYPE;

return $this;
}














public function sortByAccessedTime()
{
$this->sort = Iterator\SortableIterator::SORT_BY_ACCESSED_TIME;

return $this;
}
















public function sortByChangedTime()
{
$this->sort = Iterator\SortableIterator::SORT_BY_CHANGED_TIME;

return $this;
}














public function sortByModifiedTime()
{
$this->sort = Iterator\SortableIterator::SORT_BY_MODIFIED_TIME;

return $this;
}















public function filter(\Closure $closure)
{
$this->filters[] = $closure;

return $this;
}








public function followLinks()
{
$this->followLinks = true;

return $this;
}










public function ignoreUnreadableDirs($ignore = true)
{
$this->ignoreUnreadableDirs = (bool) $ignore;

return $this;
}












public function in($dirs)
{
$resolvedDirs = array();

foreach ((array) $dirs as $dir) {
if (is_dir($dir)) {
$resolvedDirs[] = $dir;
} elseif ($glob = glob($dir, GLOB_BRACE | GLOB_ONLYDIR)) {
$resolvedDirs = array_merge($resolvedDirs, $glob);
} else {
throw new \InvalidArgumentException(sprintf('The "%s" directory does not exist.', $dir));
}
}

$this->dirs = array_merge($this->dirs, $resolvedDirs);

return $this;
}










public function getIterator()
{
if (0 === count($this->dirs) && 0 === count($this->iterators)) {
throw new \LogicException('You must call one of in() or append() methods before iterating over a Finder.');
}

if (1 === count($this->dirs) && 0 === count($this->iterators)) {
return $this->searchInDirectory($this->dirs[0]);
}

$iterator = new \AppendIterator();
foreach ($this->dirs as $dir) {
$iterator->append($this->searchInDirectory($dir));
}

foreach ($this->iterators as $it) {
$iterator->append($it);
}

return $iterator;
}












public function append($iterator)
{
if ($iterator instanceof \IteratorAggregate) {
$this->iterators[] = $iterator->getIterator();
} elseif ($iterator instanceof \Iterator) {
$this->iterators[] = $iterator;
} elseif ($iterator instanceof \Traversable || is_array($iterator)) {
$it = new \ArrayIterator();
foreach ($iterator as $file) {
$it->append($file instanceof \SplFileInfo ? $file : new \SplFileInfo($file));
}
$this->iterators[] = $it;
} else {
throw new \InvalidArgumentException('Finder::append() method wrong argument type.');
}

return $this;
}






public function count()
{
return iterator_count($this->getIterator());
}




private function sortAdapters()
{
uasort($this->adapters, function (array $a, array $b) {
if ($a['selected'] || $b['selected']) {
return $a['selected'] ? -1 : 1;
}

return $a['priority'] > $b['priority'] ? -1 : 1;
});

return $this;
}








private function searchInDirectory($dir)
{
if (static::IGNORE_VCS_FILES === (static::IGNORE_VCS_FILES & $this->ignore)) {
$this->exclude = array_merge($this->exclude, self::$vcsPatterns);
}

if (static::IGNORE_DOT_FILES === (static::IGNORE_DOT_FILES & $this->ignore)) {
$this->notPaths[] = '#(^|/)\..+(/|$)#';
}

foreach ($this->adapters as $adapter) {
if ($adapter['adapter']->isSupported()) {
try {
return $this
->buildAdapter($adapter['adapter'])
->searchInDirectory($dir);
} catch (ExceptionInterface $e) {
}
}
}

throw new \RuntimeException('No supported adapter found.');
}






private function buildAdapter(AdapterInterface $adapter)
{
return $adapter
->setFollowLinks($this->followLinks)
->setDepths($this->depths)
->setMode($this->mode)
->setExclude($this->exclude)
->setNames($this->names)
->setNotNames($this->notNames)
->setContains($this->contains)
->setNotContains($this->notContains)
->setSizes($this->sizes)
->setDates($this->dates)
->setFilters($this->filters)
->setSort($this->sort)
->setPath($this->paths)
->setNotPath($this->notPaths)
->ignoreUnreadableDirs($this->ignoreUnreadableDirs);
}




private function resetAdapterSelection()
{
$this->adapters = array_map(function (array $properties) {
$properties['selected'] = false;

return $properties;
}, $this->adapters);
}
}
<?php










namespace Symfony\Component\Finder;























class Glob
{









public static function toRegex($glob, $strictLeadingDot = true, $strictWildcardSlash = true)
{
$firstByte = true;
$escaping = false;
$inCurlies = 0;
$regex = '';
$sizeGlob = strlen($glob);
for ($i = 0; $i < $sizeGlob; $i++) {
$car = $glob[$i];
if ($firstByte) {
if ($strictLeadingDot && '.' !== $car) {
$regex .= '(?=[^\.])';
}

$firstByte = false;
}

if ('/' === $car) {
$firstByte = true;
}

if ('.' === $car || '(' === $car || ')' === $car || '|' === $car || '+' === $car || '^' === $car || '$' === $car) {
$regex .= "\\$car";
} elseif ('*' === $car) {
$regex .= $escaping ? '\\*' : ($strictWildcardSlash ? '[^/]*' : '.*');
} elseif ('?' === $car) {
$regex .= $escaping ? '\\?' : ($strictWildcardSlash ? '[^/]' : '.');
} elseif ('{' === $car) {
$regex .= $escaping ? '\\{' : '(';
if (!$escaping) {
++$inCurlies;
}
} elseif ('}' === $car && $inCurlies) {
$regex .= $escaping ? '}' : ')';
if (!$escaping) {
--$inCurlies;
}
} elseif (',' === $car && $inCurlies) {
$regex .= $escaping ? ',' : '|';
} elseif ('\\' === $car) {
if ($escaping) {
$regex .= '\\\\';
$escaping = false;
} else {
$escaping = true;
}

continue;
} else {
$regex .= $car;
}
$escaping = false;
}

return '#^'.$regex.'$#';
}
}
<?php










namespace Symfony\Component\Finder\Iterator;









class CustomFilterIterator extends FilterIterator
{
private $filters = array();









public function __construct(\Iterator $iterator, array $filters)
{
foreach ($filters as $filter) {
if (!is_callable($filter)) {
throw new \InvalidArgumentException('Invalid PHP callback.');
}
}
$this->filters = $filters;

parent::__construct($iterator);
}






public function accept()
{
$fileinfo = $this->current();

foreach ($this->filters as $filter) {
if (false === call_user_func($filter, $fileinfo)) {
return false;
}
}

return true;
}
}
<?php










namespace Symfony\Component\Finder\Iterator;

use Symfony\Component\Finder\Comparator\DateComparator;






class DateRangeFilterIterator extends FilterIterator
{
private $comparators = array();







public function __construct(\Iterator $iterator, array $comparators)
{
$this->comparators = $comparators;

parent::__construct($iterator);
}






public function accept()
{
$fileinfo = $this->current();

if (!file_exists($fileinfo->getRealPath())) {
return false;
}

$filedate = $fileinfo->getMTime();
foreach ($this->comparators as $compare) {
if (!$compare->test($filedate)) {
return false;
}
}

return true;
}
}
<?php










namespace Symfony\Component\Finder\Iterator;






class DepthRangeFilterIterator extends FilterIterator
{
private $minDepth = 0;








public function __construct(\RecursiveIteratorIterator $iterator, $minDepth = 0, $maxDepth = PHP_INT_MAX)
{
$this->minDepth = $minDepth;
$iterator->setMaxDepth(PHP_INT_MAX === $maxDepth ? -1 : $maxDepth);

parent::__construct($iterator);
}






public function accept()
{
return $this->getInnerIterator()->getDepth() >= $this->minDepth;
}
}
<?php










namespace Symfony\Component\Finder\Iterator;






class ExcludeDirectoryFilterIterator extends FilterIterator
{
private $patterns = array();







public function __construct(\Iterator $iterator, array $directories)
{
foreach ($directories as $directory) {
$this->patterns[] = '#(^|/)'.preg_quote($directory, '#').'(/|$)#';
}

parent::__construct($iterator);
}






public function accept()
{
$path = $this->isDir() ? $this->current()->getRelativePathname() : $this->current()->getRelativePath();
$path = strtr($path, '\\', '/');
foreach ($this->patterns as $pattern) {
if (preg_match($pattern, $path)) {
return false;
}
}

return true;
}
}
<?php










namespace Symfony\Component\Finder\Iterator;

use Symfony\Component\Finder\SplFileInfo;






class FilePathsIterator extends \ArrayIterator
{



private $baseDir;




private $baseDirLength;




private $subPath;




private $subPathname;




private $current;





public function __construct(array $paths, $baseDir)
{
$this->baseDir = $baseDir;
$this->baseDirLength = strlen($baseDir);

parent::__construct($paths);
}







public function __call($name, array $arguments)
{
return call_user_func_array(array($this->current(), $name), $arguments);
}






public function current()
{
return $this->current;
}




public function key()
{
return $this->current->getPathname();
}

public function next()
{
parent::next();
$this->buildProperties();
}

public function rewind()
{
parent::rewind();
$this->buildProperties();
}




public function getSubPath()
{
return $this->subPath;
}




public function getSubPathname()
{
return $this->subPathname;
}

private function buildProperties()
{
$absolutePath = parent::current();

if ($this->baseDir === substr($absolutePath, 0, $this->baseDirLength)) {
$this->subPathname = ltrim(substr($absolutePath, $this->baseDirLength), '/\\');
$dir = dirname($this->subPathname);
$this->subPath = '.' === $dir ? '' : $dir;
} else {
$this->subPath = $this->subPathname = '';
}

$this->current = new SplFileInfo(parent::current(), $this->subPath, $this->subPathname);
}
}
<?php










namespace Symfony\Component\Finder\Iterator;






class FileTypeFilterIterator extends FilterIterator
{
const ONLY_FILES = 1;
const ONLY_DIRECTORIES = 2;

private $mode;







public function __construct(\Iterator $iterator, $mode)
{
$this->mode = $mode;

parent::__construct($iterator);
}






public function accept()
{
$fileinfo = $this->current();
if (self::ONLY_DIRECTORIES === (self::ONLY_DIRECTORIES & $this->mode) && $fileinfo->isFile()) {
return false;
} elseif (self::ONLY_FILES === (self::ONLY_FILES & $this->mode) && $fileinfo->isDir()) {
return false;
}

return true;
}
}
<?php










namespace Symfony\Component\Finder\Iterator;







class FilecontentFilterIterator extends MultiplePcreFilterIterator
{





public function accept()
{
if (!$this->matchRegexps && !$this->noMatchRegexps) {
return true;
}

$fileinfo = $this->current();

if ($fileinfo->isDir() || !$fileinfo->isReadable()) {
return false;
}

$content = $fileinfo->getContents();
if (!$content) {
return false;
}


 foreach ($this->noMatchRegexps as $regex) {
if (preg_match($regex, $content)) {
return false;
}
}


 $match = true;
if ($this->matchRegexps) {
$match = false;
foreach ($this->matchRegexps as $regex) {
if (preg_match($regex, $content)) {
return true;
}
}
}

return $match;
}








protected function toRegex($str)
{
return $this->isRegex($str) ? $str : '/'.preg_quote($str, '/').'/';
}
}
<?php










namespace Symfony\Component\Finder\Iterator;

use Symfony\Component\Finder\Expression\Expression;






class FilenameFilterIterator extends MultiplePcreFilterIterator
{





public function accept()
{
$filename = $this->current()->getFilename();


 foreach ($this->noMatchRegexps as $regex) {
if (preg_match($regex, $filename)) {
return false;
}
}


 $match = true;
if ($this->matchRegexps) {
$match = false;
foreach ($this->matchRegexps as $regex) {
if (preg_match($regex, $filename)) {
return true;
}
}
}

return $match;
}











protected function toRegex($str)
{
return Expression::create($str)->getRegex()->render();
}
}
<?php










namespace Symfony\Component\Finder\Iterator;








abstract class FilterIterator extends \FilterIterator
{






public function rewind()
{
$iterator = $this;
while ($iterator instanceof \OuterIterator) {
$innerIterator = $iterator->getInnerIterator();

if ($innerIterator instanceof RecursiveDirectoryIterator) {
if ($innerIterator->isRewindable()) {
$innerIterator->next();
$innerIterator->rewind();
}
} elseif ($iterator->getInnerIterator() instanceof \FilesystemIterator) {
$iterator->getInnerIterator()->next();
$iterator->getInnerIterator()->rewind();
}
$iterator = $iterator->getInnerIterator();
}

parent::rewind();
}
}
<?php










namespace Symfony\Component\Finder\Iterator;

use Symfony\Component\Finder\Expression\Expression;






abstract class MultiplePcreFilterIterator extends FilterIterator
{
protected $matchRegexps = array();
protected $noMatchRegexps = array();








public function __construct(\Iterator $iterator, array $matchPatterns, array $noMatchPatterns)
{
foreach ($matchPatterns as $pattern) {
$this->matchRegexps[] = $this->toRegex($pattern);
}

foreach ($noMatchPatterns as $pattern) {
$this->noMatchRegexps[] = $this->toRegex($pattern);
}

parent::__construct($iterator);
}








protected function isRegex($str)
{
return Expression::create($str)->isRegex();
}








abstract protected function toRegex($str);
}
<?php










namespace Symfony\Component\Finder\Iterator;







class PathFilterIterator extends MultiplePcreFilterIterator
{





public function accept()
{
$filename = $this->current()->getRelativePathname();

if ('\\' === DIRECTORY_SEPARATOR) {
$filename = strtr($filename, '\\', '/');
}


 foreach ($this->noMatchRegexps as $regex) {
if (preg_match($regex, $filename)) {
return false;
}
}


 $match = true;
if ($this->matchRegexps) {
$match = false;
foreach ($this->matchRegexps as $regex) {
if (preg_match($regex, $filename)) {
return true;
}
}
}

return $match;
}















protected function toRegex($str)
{
return $this->isRegex($str) ? $str : '/'.preg_quote($str, '/').'/';
}
}
<?php










namespace Symfony\Component\Finder\Iterator;

use Symfony\Component\Finder\Exception\AccessDeniedException;
use Symfony\Component\Finder\SplFileInfo;






class RecursiveDirectoryIterator extends \RecursiveDirectoryIterator
{



private $ignoreUnreadableDirs;




private $rewindable;










public function __construct($path, $flags, $ignoreUnreadableDirs = false)
{
if ($flags & (self::CURRENT_AS_PATHNAME | self::CURRENT_AS_SELF)) {
throw new \RuntimeException('This iterator only support returning current as fileinfo.');
}

parent::__construct($path, $flags);
$this->ignoreUnreadableDirs = $ignoreUnreadableDirs;
}






public function current()
{
return new SplFileInfo(parent::current()->getPathname(), $this->getSubPath(), $this->getSubPathname());
}






public function getChildren()
{
try {
$children = parent::getChildren();

if ($children instanceof self) {

 $children->ignoreUnreadableDirs = $this->ignoreUnreadableDirs;
}

return $children;
} catch (\UnexpectedValueException $e) {
if ($this->ignoreUnreadableDirs) {

 return new \RecursiveArrayIterator(array());
} else {
throw new AccessDeniedException($e->getMessage(), $e->getCode(), $e);
}
}
}




public function rewind()
{
if (false === $this->isRewindable()) {
return;
}


 parent::next();

parent::rewind();
}






public function isRewindable()
{
if (null !== $this->rewindable) {
return $this->rewindable;
}

if (false !== $stream = @opendir($this->getPath())) {
$infos = stream_get_meta_data($stream);
closedir($stream);

if ($infos['seekable']) {
return $this->rewindable = true;
}
}

return $this->rewindable = false;
}
}
<?php










namespace Symfony\Component\Finder\Iterator;

use Symfony\Component\Finder\Comparator\NumberComparator;






class SizeRangeFilterIterator extends FilterIterator
{
private $comparators = array();







public function __construct(\Iterator $iterator, array $comparators)
{
$this->comparators = $comparators;

parent::__construct($iterator);
}






public function accept()
{
$fileinfo = $this->current();
if (!$fileinfo->isFile()) {
return true;
}

$filesize = $fileinfo->getSize();
foreach ($this->comparators as $compare) {
if (!$compare->test($filesize)) {
return false;
}
}

return true;
}
}
<?php










namespace Symfony\Component\Finder\Iterator;






class SortableIterator implements \IteratorAggregate
{
const SORT_BY_NAME = 1;
const SORT_BY_TYPE = 2;
const SORT_BY_ACCESSED_TIME = 3;
const SORT_BY_CHANGED_TIME = 4;
const SORT_BY_MODIFIED_TIME = 5;

private $iterator;
private $sort;









public function __construct(\Traversable $iterator, $sort)
{
$this->iterator = $iterator;

if (self::SORT_BY_NAME === $sort) {
$this->sort = function ($a, $b) {
return strcmp($a->getRealpath(), $b->getRealpath());
};
} elseif (self::SORT_BY_TYPE === $sort) {
$this->sort = function ($a, $b) {
if ($a->isDir() && $b->isFile()) {
return -1;
} elseif ($a->isFile() && $b->isDir()) {
return 1;
}

return strcmp($a->getRealpath(), $b->getRealpath());
};
} elseif (self::SORT_BY_ACCESSED_TIME === $sort) {
$this->sort = function ($a, $b) {
return ($a->getATime() - $b->getATime());
};
} elseif (self::SORT_BY_CHANGED_TIME === $sort) {
$this->sort = function ($a, $b) {
return ($a->getCTime() - $b->getCTime());
};
} elseif (self::SORT_BY_MODIFIED_TIME === $sort) {
$this->sort = function ($a, $b) {
return ($a->getMTime() - $b->getMTime());
};
} elseif (is_callable($sort)) {
$this->sort = $sort;
} else {
throw new \InvalidArgumentException('The SortableIterator takes a PHP callable or a valid built-in sort algorithm as an argument.');
}
}

public function getIterator()
{
$array = iterator_to_array($this->iterator, true);
uasort($array, $this->sort);

return new \ArrayIterator($array);
}
}
Copyright (c) 2004-2015 Fabien Potencier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
<?php










namespace Symfony\Component\Finder\Shell;




class Command
{



private $parent;




private $bits = array();




private $labels = array();




private $errorHandler;






public function __construct(Command $parent = null)
{
$this->parent = $parent;
}






public function __toString()
{
return $this->join();
}








public static function create(Command $parent = null)
{
return new self($parent);
}








public static function escape($input)
{
return escapeshellcmd($input);
}








public static function quote($input)
{
return escapeshellarg($input);
}








public function add($bit)
{
$this->bits[] = $bit;

return $this;
}








public function top($bit)
{
array_unshift($this->bits, $bit);

foreach ($this->labels as $label => $index) {
$this->labels[$label] += 1;
}

return $this;
}








public function arg($arg)
{
$this->bits[] = self::quote($arg);

return $this;
}








public function cmd($esc)
{
$this->bits[] = self::escape($esc);

return $this;
}










public function ins($label)
{
if (isset($this->labels[$label])) {
throw new \RuntimeException(sprintf('Label "%s" already exists.', $label));
}

$this->bits[] = self::create($this);
$this->labels[$label] = count($this->bits) - 1;

return $this->bits[$this->labels[$label]];
}










public function get($label)
{
if (!isset($this->labels[$label])) {
throw new \RuntimeException(sprintf('Label "%s" does not exist.', $label));
}

return $this->bits[$this->labels[$label]];
}








public function end()
{
if (null === $this->parent) {
throw new \RuntimeException('Calling end on root command doesn\'t make sense.');
}

return $this->parent;
}






public function length()
{
return count($this->bits);
}






public function setErrorHandler(\Closure $errorHandler)
{
$this->errorHandler = $errorHandler;

return $this;
}




public function getErrorHandler()
{
return $this->errorHandler;
}








public function execute()
{
if (null === $errorHandler = $this->errorHandler) {
exec($this->join(), $output);
} else {
$process = proc_open($this->join(), array(0 => array('pipe', 'r'), 1 => array('pipe', 'w'), 2 => array('pipe', 'w')), $pipes);
$output = preg_split('~(\r\n|\r|\n)~', stream_get_contents($pipes[1]), -1, PREG_SPLIT_NO_EMPTY);

if ($error = stream_get_contents($pipes[2])) {
$errorHandler($error);
}

proc_close($process);
}

return $output ?: array();
}






public function join()
{
return implode(' ', array_filter(
array_map(function ($bit) {
return $bit instanceof Command ? $bit->join() : ($bit ?: null);
}, $this->bits),
function ($bit) { return null !== $bit; }
));
}









public function addAtIndex($bit, $index)
{
array_splice($this->bits, $index, 0, $bit);

return $this;
}
}
<?php










namespace Symfony\Component\Finder\Shell;




class Shell
{
const TYPE_UNIX = 1;
const TYPE_DARWIN = 2;
const TYPE_CYGWIN = 3;
const TYPE_WINDOWS = 4;
const TYPE_BSD = 5;




private $type;






public function getType()
{
if (null === $this->type) {
$this->type = $this->guessType();
}

return $this->type;
}








public function testCommand($command)
{
if (!function_exists('exec')) {
return false;
}


 $testCommand = 'which ';
if (self::TYPE_WINDOWS === $this->type) {
$testCommand = 'where ';
}

$command = escapeshellcmd($command);

exec($testCommand.$command, $output, $code);

return 0 === $code && count($output) > 0;
}






private function guessType()
{
$os = strtolower(PHP_OS);

if (false !== strpos($os, 'cygwin')) {
return self::TYPE_CYGWIN;
}

if (false !== strpos($os, 'darwin')) {
return self::TYPE_DARWIN;
}

if (false !== strpos($os, 'bsd')) {
return self::TYPE_BSD;
}

if (0 === strpos($os, 'win')) {
return self::TYPE_WINDOWS;
}

return self::TYPE_UNIX;
}
}
<?php










namespace Symfony\Component\Finder;






class SplFileInfo extends \SplFileInfo
{
private $relativePath;
private $relativePathname;








public function __construct($file, $relativePath, $relativePathname)
{
parent::__construct($file);
$this->relativePath = $relativePath;
$this->relativePathname = $relativePathname;
}






public function getRelativePath()
{
return $this->relativePath;
}






public function getRelativePathname()
{
return $this->relativePathname;
}








public function getContents()
{
$level = error_reporting(0);
$content = file_get_contents($this->getPathname());
error_reporting($level);
if (false === $content) {
$error = error_get_last();
throw new \RuntimeException($error['message']);
}

return $content;
}
}
<?php










namespace Symfony\Component\Process\Exception;






interface ExceptionInterface
{
}
<?php










namespace Symfony\Component\Process\Exception;






class InvalidArgumentException extends \InvalidArgumentException implements ExceptionInterface
{
}
<?php










namespace Symfony\Component\Process\Exception;






class LogicException extends \LogicException implements ExceptionInterface
{
}
<?php










namespace Symfony\Component\Process\Exception;

use Symfony\Component\Process\Process;






class ProcessFailedException extends RuntimeException
{
private $process;

public function __construct(Process $process)
{
if ($process->isSuccessful()) {
throw new InvalidArgumentException('Expected a failed process, but the given process was successful.');
}

$error = sprintf('The command "%s" failed.'."\nExit Code: %s(%s)",
$process->getCommandLine(),
$process->getExitCode(),
$process->getExitCodeText()
);

if (!$process->isOutputDisabled()) {
$error .= sprintf("\n\nOutput:\n================\n%s\n\nError Output:\n================\n%s",
$process->getOutput(),
$process->getErrorOutput()
);
}

parent::__construct($error);

$this->process = $process;
}

public function getProcess()
{
return $this->process;
}
}
<?php










namespace Symfony\Component\Process\Exception;

use Symfony\Component\Process\Process;






class ProcessTimedOutException extends RuntimeException
{
const TYPE_GENERAL = 1;
const TYPE_IDLE = 2;

private $process;
private $timeoutType;

public function __construct(Process $process, $timeoutType)
{
$this->process = $process;
$this->timeoutType = $timeoutType;

parent::__construct(sprintf(
'The process "%s" exceeded the timeout of %s seconds.',
$process->getCommandLine(),
$this->getExceededTimeout()
));
}

public function getProcess()
{
return $this->process;
}

public function isGeneralTimeout()
{
return $this->timeoutType === self::TYPE_GENERAL;
}

public function isIdleTimeout()
{
return $this->timeoutType === self::TYPE_IDLE;
}

public function getExceededTimeout()
{
switch ($this->timeoutType) {
case self::TYPE_GENERAL:
return $this->process->getTimeout();

case self::TYPE_IDLE:
return $this->process->getIdleTimeout();

default:
throw new \LogicException(sprintf('Unknown timeout type "%d".', $this->timeoutType));
}
}
}
<?php










namespace Symfony\Component\Process\Exception;






class RuntimeException extends \RuntimeException implements ExceptionInterface
{
}
<?php










namespace Symfony\Component\Process;







class ExecutableFinder
{
private $suffixes = array('.exe', '.bat', '.cmd', '.com');






public function setSuffixes(array $suffixes)
{
$this->suffixes = $suffixes;
}






public function addSuffix($suffix)
{
$this->suffixes[] = $suffix;
}










public function find($name, $default = null, array $extraDirs = array())
{
if (ini_get('open_basedir')) {
$searchPath = explode(PATH_SEPARATOR, ini_get('open_basedir'));
$dirs = array();
foreach ($searchPath as $path) {
if (is_dir($path)) {
$dirs[] = $path;
} else {
if (basename($path) == $name && is_executable($path)) {
return $path;
}
}
}
} else {
$dirs = array_merge(
explode(PATH_SEPARATOR, getenv('PATH') ?: getenv('Path')),
$extraDirs
);
}

$suffixes = array('');
if ('\\' === DIRECTORY_SEPARATOR) {
$pathExt = getenv('PATHEXT');
$suffixes = $pathExt ? explode(PATH_SEPARATOR, $pathExt) : $this->suffixes;
}
foreach ($suffixes as $suffix) {
foreach ($dirs as $dir) {
if (is_file($file = $dir.DIRECTORY_SEPARATOR.$name.$suffix) && ('\\' === DIRECTORY_SEPARATOR || is_executable($file))) {
return $file;
}
}
}

return $default;
}
}
Copyright (c) 2004-2015 Fabien Potencier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
<?php










namespace Symfony\Component\Process;







class PhpExecutableFinder
{
private $executableFinder;

public function __construct()
{
$this->executableFinder = new ExecutableFinder();
}








public function find($includeArgs = true)
{

 if (defined('HHVM_VERSION')) {
return (false !== ($hhvm = getenv('PHP_BINARY')) ? $hhvm : PHP_BINARY).($includeArgs ? ' '.implode(' ', $this->findArguments()) : '');
}


 if (defined('PHP_BINARY') && PHP_BINARY && in_array(PHP_SAPI, array('cli', 'cli-server')) && is_file(PHP_BINARY)) {
return PHP_BINARY;
}

if ($php = getenv('PHP_PATH')) {
if (!is_executable($php)) {
return false;
}

return $php;
}

if ($php = getenv('PHP_PEAR_PHP_BIN')) {
if (is_executable($php)) {
return $php;
}
}

$dirs = array(PHP_BINDIR);
if ('\\' === DIRECTORY_SEPARATOR) {
$dirs[] = 'C:\xampp\php\\';
}

return $this->executableFinder->find('php', false, $dirs);
}






public function findArguments()
{
$arguments = array();


 if (defined('HHVM_VERSION')) {
$arguments[] = '--php';
}

return $arguments;
}
}
<?php










namespace Symfony\Component\Process;

use Symfony\Component\Process\Exception\RuntimeException;












class PhpProcess extends Process
{











public function __construct($script, $cwd = null, array $env = array(), $timeout = 60, array $options = array())
{
$executableFinder = new PhpExecutableFinder();
if (false === $php = $executableFinder->find()) {
$php = null;
}

parent::__construct($php, $cwd, $env, $script, $timeout, $options);
}






public function setPhpBinary($php)
{
$this->setCommandLine($php);
}




public function start($callback = null)
{
if (null === $this->getCommandLine()) {
throw new RuntimeException('Unable to find the PHP executable.');
}

parent::start($callback);
}
}
<?php










namespace Symfony\Component\Process\Pipes;






abstract class AbstractPipes implements PipesInterface
{

public $pipes = array();


protected $inputBuffer = '';

protected $input;


private $blocked = true;




public function close()
{
foreach ($this->pipes as $pipe) {
fclose($pipe);
}
$this->pipes = array();
}






protected function hasSystemCallBeenInterrupted()
{
$lastError = error_get_last();


 return isset($lastError['message']) && false !== stripos($lastError['message'], 'interrupted system call');
}




protected function unblock()
{
if (!$this->blocked) {
return;
}

foreach ($this->pipes as $pipe) {
stream_set_blocking($pipe, 0);
}
if (null !== $this->input) {
stream_set_blocking($this->input, 0);
}

$this->blocked = false;
}
}
<?php










namespace Symfony\Component\Process\Pipes;








interface PipesInterface
{
const CHUNK_SIZE = 16384;






public function getDescriptors();






public function getFiles();









public function readAndWrite($blocking, $close = false);






public function areOpen();




public function close();
}
<?php










namespace Symfony\Component\Process\Pipes;

use Symfony\Component\Process\Process;








class UnixPipes extends AbstractPipes
{

private $ttyMode;

private $ptyMode;

private $disableOutput;

public function __construct($ttyMode, $ptyMode, $input, $disableOutput)
{
$this->ttyMode = (bool) $ttyMode;
$this->ptyMode = (bool) $ptyMode;
$this->disableOutput = (bool) $disableOutput;

if (is_resource($input)) {
$this->input = $input;
} else {
$this->inputBuffer = (string) $input;
}
}

public function __destruct()
{
$this->close();
}




public function getDescriptors()
{
if ($this->disableOutput) {
$nullstream = fopen('/dev/null', 'c');

return array(
array('pipe', 'r'),
$nullstream,
$nullstream,
);
}

if ($this->ttyMode) {
return array(
array('file', '/dev/tty', 'r'),
array('file', '/dev/tty', 'w'),
array('file', '/dev/tty', 'w'),
);
}

if ($this->ptyMode && Process::isPtySupported()) {
return array(
array('pty'),
array('pty'),
array('pty'),
);
}

return array(
array('pipe', 'r'),
array('pipe', 'w'), 
 array('pipe', 'w'), 
 );
}




public function getFiles()
{
return array();
}




public function readAndWrite($blocking, $close = false)
{

 
 if (1 === count($this->pipes) && array(0) === array_keys($this->pipes)) {
fclose($this->pipes[0]);
unset($this->pipes[0]);
}

if (empty($this->pipes)) {
return array();
}

$this->unblock();

$read = array();

if (null !== $this->input) {

 
 $r = array_merge($this->pipes, array('input' => $this->input));
} else {
$r = $this->pipes;
}

 unset($r[0]);

$w = isset($this->pipes[0]) ? array($this->pipes[0]) : null;
$e = null;


 if (false === $n = @stream_select($r, $w, $e, 0, $blocking ? Process::TIMEOUT_PRECISION * 1E6 : 0)) {

 
 if (!$this->hasSystemCallBeenInterrupted()) {
$this->pipes = array();
}

return $read;
}


 if (0 === $n) {
return $read;
}

foreach ($r as $pipe) {

 
 $type = (false !== $found = array_search($pipe, $this->pipes)) ? $found : 'input';
$data = '';
while ('' !== $dataread = (string) fread($pipe, self::CHUNK_SIZE)) {
$data .= $dataread;
}

if ('' !== $data) {
if ($type === 'input') {
$this->inputBuffer .= $data;
} else {
$read[$type] = $data;
}
}

if (false === $data || (true === $close && feof($pipe) && '' === $data)) {
if ($type === 'input') {

 
 $this->input = null;
} else {
fclose($this->pipes[$type]);
unset($this->pipes[$type]);
}
}
}

if (null !== $w && 0 < count($w)) {
while (strlen($this->inputBuffer)) {
$written = fwrite($w[0], $this->inputBuffer, 2 << 18); 
 if ($written > 0) {
$this->inputBuffer = (string) substr($this->inputBuffer, $written);
} else {
break;
}
}
}


 if ('' === $this->inputBuffer && null === $this->input && isset($this->pipes[0])) {
fclose($this->pipes[0]);
unset($this->pipes[0]);
}

return $read;
}




public function areOpen()
{
return (bool) $this->pipes;
}









public static function create(Process $process, $input)
{
return new static($process->isTty(), $process->isPty(), $input, $process->isOutputDisabled());
}
}
<?php










namespace Symfony\Component\Process\Pipes;

use Symfony\Component\Process\Process;
use Symfony\Component\Process\Exception\RuntimeException;











class WindowsPipes extends AbstractPipes
{

private $files = array();

private $fileHandles = array();

private $readBytes = array(
Process::STDOUT => 0,
Process::STDERR => 0,
);

private $disableOutput;

public function __construct($disableOutput, $input)
{
$this->disableOutput = (bool) $disableOutput;

if (!$this->disableOutput) {

 
 
 
 $this->files = array(
Process::STDOUT => tempnam(sys_get_temp_dir(), 'sf_proc_stdout'),
Process::STDERR => tempnam(sys_get_temp_dir(), 'sf_proc_stderr'),
);
foreach ($this->files as $offset => $file) {
$this->fileHandles[$offset] = fopen($this->files[$offset], 'rb');
if (false === $this->fileHandles[$offset]) {
throw new RuntimeException('A temporary file could not be opened to write the process output to, verify that your TEMP environment variable is writable');
}
}
}

if (is_resource($input)) {
$this->input = $input;
} else {
$this->inputBuffer = $input;
}
}

public function __destruct()
{
$this->close();
$this->removeFiles();
}




public function getDescriptors()
{
if ($this->disableOutput) {
$nullstream = fopen('NUL', 'c');

return array(
array('pipe', 'r'),
$nullstream,
$nullstream,
);
}


 
 
 return array(
array('pipe', 'r'),
array('file', 'NUL', 'w'),
array('file', 'NUL', 'w'),
);
}




public function getFiles()
{
return $this->files;
}




public function readAndWrite($blocking, $close = false)
{
$this->write($blocking, $close);

$read = array();
$fh = $this->fileHandles;
foreach ($fh as $type => $fileHandle) {
if (0 !== fseek($fileHandle, $this->readBytes[$type])) {
continue;
}
$data = '';
$dataread = null;
while (!feof($fileHandle)) {
if (false !== $dataread = fread($fileHandle, self::CHUNK_SIZE)) {
$data .= $dataread;
}
}
if (0 < $length = strlen($data)) {
$this->readBytes[$type] += $length;
$read[$type] = $data;
}

if (false === $dataread || (true === $close && feof($fileHandle) && '' === $data)) {
fclose($this->fileHandles[$type]);
unset($this->fileHandles[$type]);
}
}

return $read;
}




public function areOpen()
{
return (bool) $this->pipes && (bool) $this->fileHandles;
}




public function close()
{
parent::close();
foreach ($this->fileHandles as $handle) {
fclose($handle);
}
$this->fileHandles = array();
}









public static function create(Process $process, $input)
{
return new static($process->isOutputDisabled(), $input);
}




private function removeFiles()
{
foreach ($this->files as $filename) {
if (file_exists($filename)) {
@unlink($filename);
}
}
$this->files = array();
}







private function write($blocking, $close)
{
if (empty($this->pipes)) {
return;
}

$this->unblock();

$r = null !== $this->input ? array('input' => $this->input) : null;
$w = isset($this->pipes[0]) ? array($this->pipes[0]) : null;
$e = null;


 if (false === $n = @stream_select($r, $w, $e, 0, $blocking ? Process::TIMEOUT_PRECISION * 1E6 : 0)) {

 
 if (!$this->hasSystemCallBeenInterrupted()) {
$this->pipes = array();
}

return;
}


 if (0 === $n) {
return;
}

if (null !== $w && 0 < count($r)) {
$data = '';
while ($dataread = fread($r['input'], self::CHUNK_SIZE)) {
$data .= $dataread;
}

$this->inputBuffer .= $data;

if (false === $data || (true === $close && feof($r['input']) && '' === $data)) {

 
 $this->input = null;
}
}

if (null !== $w && 0 < count($w)) {
while (strlen($this->inputBuffer)) {
$written = fwrite($w[0], $this->inputBuffer, 2 << 18);
if ($written > 0) {
$this->inputBuffer = (string) substr($this->inputBuffer, $written);
} else {
break;
}
}
}


 if ('' === $this->inputBuffer && null === $this->input && isset($this->pipes[0])) {
fclose($this->pipes[0]);
unset($this->pipes[0]);
}
}
}
<?php










namespace Symfony\Component\Process;

use Symfony\Component\Process\Exception\InvalidArgumentException;
use Symfony\Component\Process\Exception\LogicException;
use Symfony\Component\Process\Exception\ProcessFailedException;
use Symfony\Component\Process\Exception\ProcessTimedOutException;
use Symfony\Component\Process\Exception\RuntimeException;
use Symfony\Component\Process\Pipes\PipesInterface;
use Symfony\Component\Process\Pipes\UnixPipes;
use Symfony\Component\Process\Pipes\WindowsPipes;










class Process
{
const ERR = 'err';
const OUT = 'out';

const STATUS_READY = 'ready';
const STATUS_STARTED = 'started';
const STATUS_TERMINATED = 'terminated';

const STDIN = 0;
const STDOUT = 1;
const STDERR = 2;


 const TIMEOUT_PRECISION = 0.2;

private $callback;
private $commandline;
private $cwd;
private $env;
private $input;
private $starttime;
private $lastOutputTime;
private $timeout;
private $idleTimeout;
private $options;
private $exitcode;
private $fallbackExitcode;
private $processInformation;
private $outputDisabled = false;
private $stdout;
private $stderr;
private $enhanceWindowsCompatibility = true;
private $enhanceSigchildCompatibility;
private $process;
private $status = self::STATUS_READY;
private $incrementalOutputOffset = 0;
private $incrementalErrorOutputOffset = 0;
private $tty;
private $pty;

private $useFileHandles = false;

private $processPipes;

private $latestSignal;

private static $sigchild;








public static $exitCodes = array(
0 => 'OK',
1 => 'General error',
2 => 'Misuse of shell builtins',

126 => 'Invoked command cannot execute',
127 => 'Command not found',
128 => 'Invalid exit argument',


 129 => 'Hangup',
130 => 'Interrupt',
131 => 'Quit and dump core',
132 => 'Illegal instruction',
133 => 'Trace/breakpoint trap',
134 => 'Process aborted',
135 => 'Bus error: "access to undefined portion of memory object"',
136 => 'Floating point exception: "erroneous arithmetic operation"',
137 => 'Kill (terminate immediately)',
138 => 'User-defined 1',
139 => 'Segmentation violation',
140 => 'User-defined 2',
141 => 'Write to pipe with no one reading',
142 => 'Signal raised by alarm',
143 => 'Termination (request to terminate)',

 145 => 'Child process terminated, stopped (or continued*)',
146 => 'Continue if stopped',
147 => 'Stop executing temporarily',
148 => 'Terminal stop signal',
149 => 'Background process attempting to read from tty ("in")',
150 => 'Background process attempting to write to tty ("out")',
151 => 'Urgent data available on socket',
152 => 'CPU time limit exceeded',
153 => 'File size limit exceeded',
154 => 'Signal raised by timer counting virtual time: "virtual timer expired"',
155 => 'Profiling timer expired',

 157 => 'Pollable event',

 159 => 'Bad syscall',
);















public function __construct($commandline, $cwd = null, array $env = null, $input = null, $timeout = 60, array $options = array())
{
if (!function_exists('proc_open')) {
throw new RuntimeException('The Process class relies on proc_open, which is not available on your PHP installation.');
}

$this->commandline = $commandline;
$this->cwd = $cwd;


 
 
 
 if (null === $this->cwd && (defined('ZEND_THREAD_SAFE') || '\\' === DIRECTORY_SEPARATOR)) {
$this->cwd = getcwd();
}
if (null !== $env) {
$this->setEnv($env);
}

$this->input = $input;
$this->setTimeout($timeout);
$this->useFileHandles = '\\' === DIRECTORY_SEPARATOR;
$this->pty = false;
$this->enhanceWindowsCompatibility = true;
$this->enhanceSigchildCompatibility = '\\' !== DIRECTORY_SEPARATOR && $this->isSigchildEnabled();
$this->options = array_replace(array('suppress_errors' => true, 'binary_pipes' => true), $options);
}

public function __destruct()
{

 $this->stop();
}

public function __clone()
{
$this->resetProcessData();
}






















public function run($callback = null)
{
$this->start($callback);

return $this->wait();
}














public function mustRun($callback = null)
{
if ($this->isSigchildEnabled() && !$this->enhanceSigchildCompatibility) {
throw new RuntimeException('This PHP has been compiled with --enable-sigchild. You must use setEnhanceSigchildCompatibility() to use this method.');
}

if (0 !== $this->run($callback)) {
throw new ProcessFailedException($this);
}

return $this;
}























public function start($callback = null)
{
if ($this->isRunning()) {
throw new RuntimeException('Process is already running');
}
if ($this->outputDisabled && null !== $callback) {
throw new LogicException('Output has been disabled, enable it to allow the use of a callback.');
}

$this->resetProcessData();
$this->starttime = $this->lastOutputTime = microtime(true);
$this->callback = $this->buildCallback($callback);
$descriptors = $this->getDescriptors();

$commandline = $this->commandline;

if ('\\' === DIRECTORY_SEPARATOR && $this->enhanceWindowsCompatibility) {
$commandline = 'cmd /V:ON /E:ON /C "('.$commandline.')';
foreach ($this->processPipes->getFiles() as $offset => $filename) {
$commandline .= ' '.$offset.'>'.ProcessUtils::escapeArgument($filename);
}
$commandline .= '"';

if (!isset($this->options['bypass_shell'])) {
$this->options['bypass_shell'] = true;
}
}

$this->process = proc_open($commandline, $descriptors, $this->processPipes->pipes, $this->cwd, $this->env, $this->options);

if (!is_resource($this->process)) {
throw new RuntimeException('Unable to launch a new process.');
}
$this->status = self::STATUS_STARTED;

if ($this->tty) {
return;
}

$this->updateStatus(false);
$this->checkTimeout();
}
















public function restart($callback = null)
{
if ($this->isRunning()) {
throw new RuntimeException('Process is already running');
}

$process = clone $this;
$process->start($callback);

return $process;
}
















public function wait($callback = null)
{
$this->requireProcessIsStarted(__FUNCTION__);

$this->updateStatus(false);
if (null !== $callback) {
$this->callback = $this->buildCallback($callback);
}

do {
$this->checkTimeout();
$running = '\\' === DIRECTORY_SEPARATOR ? $this->isRunning() : $this->processPipes->areOpen();
$close = '\\' !== DIRECTORY_SEPARATOR || !$running;
$this->readPipes(true, $close);
} while ($running);

while ($this->isRunning()) {
usleep(1000);
}

if ($this->processInformation['signaled'] && $this->processInformation['termsig'] !== $this->latestSignal) {
throw new RuntimeException(sprintf('The process has been signaled with signal "%s".', $this->processInformation['termsig']));
}

return $this->exitcode;
}








public function getPid()
{
if ($this->isSigchildEnabled()) {
throw new RuntimeException('This PHP has been compiled with --enable-sigchild. The process identifier can not be retrieved.');
}

$this->updateStatus(false);

return $this->isRunning() ? $this->processInformation['pid'] : null;
}












public function signal($signal)
{
$this->doSignal($signal, true);

return $this;
}









public function disableOutput()
{
if ($this->isRunning()) {
throw new RuntimeException('Disabling output while the process is running is not possible.');
}
if (null !== $this->idleTimeout) {
throw new LogicException('Output can not be disabled while an idle timeout is set.');
}

$this->outputDisabled = true;

return $this;
}








public function enableOutput()
{
if ($this->isRunning()) {
throw new RuntimeException('Enabling output while the process is running is not possible.');
}

$this->outputDisabled = false;

return $this;
}






public function isOutputDisabled()
{
return $this->outputDisabled;
}











public function getOutput()
{
if ($this->outputDisabled) {
throw new LogicException('Output has been disabled.');
}

$this->requireProcessIsStarted(__FUNCTION__);

$this->readPipes(false, '\\' === DIRECTORY_SEPARATOR ? !$this->processInformation['running'] : true);

return $this->stdout;
}












public function getIncrementalOutput()
{
$this->requireProcessIsStarted(__FUNCTION__);

$data = $this->getOutput();

$latest = substr($data, $this->incrementalOutputOffset);

if (false === $latest) {
return '';
}

$this->incrementalOutputOffset = strlen($data);

return $latest;
}






public function clearOutput()
{
$this->stdout = '';
$this->incrementalOutputOffset = 0;

return $this;
}











public function getErrorOutput()
{
if ($this->outputDisabled) {
throw new LogicException('Output has been disabled.');
}

$this->requireProcessIsStarted(__FUNCTION__);

$this->readPipes(false, '\\' === DIRECTORY_SEPARATOR ? !$this->processInformation['running'] : true);

return $this->stderr;
}













public function getIncrementalErrorOutput()
{
$this->requireProcessIsStarted(__FUNCTION__);

$data = $this->getErrorOutput();

$latest = substr($data, $this->incrementalErrorOutputOffset);

if (false === $latest) {
return '';
}

$this->incrementalErrorOutputOffset = strlen($data);

return $latest;
}






public function clearErrorOutput()
{
$this->stderr = '';
$this->incrementalErrorOutputOffset = 0;

return $this;
}










public function getExitCode()
{
if ($this->isSigchildEnabled() && !$this->enhanceSigchildCompatibility) {
throw new RuntimeException('This PHP has been compiled with --enable-sigchild. You must use setEnhanceSigchildCompatibility() to use this method.');
}

$this->updateStatus(false);

return $this->exitcode;
}














public function getExitCodeText()
{
if (null === $exitcode = $this->getExitCode()) {
return;
}

return isset(self::$exitCodes[$exitcode]) ? self::$exitCodes[$exitcode] : 'Unknown error';
}








public function isSuccessful()
{
return 0 === $this->getExitCode();
}













public function hasBeenSignaled()
{
$this->requireProcessIsTerminated(__FUNCTION__);

if ($this->isSigchildEnabled()) {
throw new RuntimeException('This PHP has been compiled with --enable-sigchild. Term signal can not be retrieved.');
}

$this->updateStatus(false);

return $this->processInformation['signaled'];
}













public function getTermSignal()
{
$this->requireProcessIsTerminated(__FUNCTION__);

if ($this->isSigchildEnabled()) {
throw new RuntimeException('This PHP has been compiled with --enable-sigchild. Term signal can not be retrieved.');
}

$this->updateStatus(false);

return $this->processInformation['termsig'];
}












public function hasBeenStopped()
{
$this->requireProcessIsTerminated(__FUNCTION__);

$this->updateStatus(false);

return $this->processInformation['stopped'];
}












public function getStopSignal()
{
$this->requireProcessIsTerminated(__FUNCTION__);

$this->updateStatus(false);

return $this->processInformation['stopsig'];
}






public function isRunning()
{
if (self::STATUS_STARTED !== $this->status) {
return false;
}

$this->updateStatus(false);

return $this->processInformation['running'];
}






public function isStarted()
{
return $this->status != self::STATUS_READY;
}






public function isTerminated()
{
$this->updateStatus(false);

return $this->status == self::STATUS_TERMINATED;
}








public function getStatus()
{
$this->updateStatus(false);

return $this->status;
}











public function stop($timeout = 10, $signal = null)
{
$timeoutMicro = microtime(true) + $timeout;
if ($this->isRunning()) {
if ('\\' === DIRECTORY_SEPARATOR && !$this->isSigchildEnabled()) {
exec(sprintf('taskkill /F /T /PID %d 2>&1', $this->getPid()), $output, $exitCode);
if ($exitCode > 0) {
throw new RuntimeException('Unable to kill the process');
}
}

 $this->doSignal(15, false);
do {
usleep(1000);
} while ($this->isRunning() && microtime(true) < $timeoutMicro);

if ($this->isRunning() && !$this->isSigchildEnabled()) {
if (null !== $signal || defined('SIGKILL')) {

 
 
 
 $this->doSignal($signal ?: SIGKILL, false);
}
}
}

$this->updateStatus(false);
if ($this->processInformation['running']) {
$this->close();
}

return $this->exitcode;
}






public function addOutput($line)
{
$this->lastOutputTime = microtime(true);
$this->stdout .= $line;
}






public function addErrorOutput($line)
{
$this->lastOutputTime = microtime(true);
$this->stderr .= $line;
}






public function getCommandLine()
{
return $this->commandline;
}








public function setCommandLine($commandline)
{
$this->commandline = $commandline;

return $this;
}






public function getTimeout()
{
return $this->timeout;
}






public function getIdleTimeout()
{
return $this->idleTimeout;
}












public function setTimeout($timeout)
{
$this->timeout = $this->validateTimeout($timeout);

return $this;
}













public function setIdleTimeout($timeout)
{
if (null !== $timeout && $this->outputDisabled) {
throw new LogicException('Idle timeout can not be set while the output is disabled.');
}

$this->idleTimeout = $this->validateTimeout($timeout);

return $this;
}










public function setTty($tty)
{
if ('\\' === DIRECTORY_SEPARATOR && $tty) {
throw new RuntimeException('TTY mode is not supported on Windows platform.');
}
if ($tty && (!file_exists('/dev/tty') || !is_readable('/dev/tty'))) {
throw new RuntimeException('TTY mode requires /dev/tty to be readable.');
}

$this->tty = (bool) $tty;

return $this;
}






public function isTty()
{
return $this->tty;
}








public function setPty($bool)
{
$this->pty = (bool) $bool;

return $this;
}






public function isPty()
{
return $this->pty;
}






public function getWorkingDirectory()
{
if (null === $this->cwd) {

 
 return getcwd() ?: null;
}

return $this->cwd;
}








public function setWorkingDirectory($cwd)
{
$this->cwd = $cwd;

return $this;
}






public function getEnv()
{
return $this->env;
}














public function setEnv(array $env)
{

 $env = array_filter($env, function ($value) {
return !is_array($value);
});

$this->env = array();
foreach ($env as $key => $value) {
$this->env[(binary) $key] = (binary) $value;
}

return $this;
}









public function getStdin()
{
return $this->getInput();
}






public function getInput()
{
return $this->input;
}














public function setStdin($stdin)
{
return $this->setInput($stdin);
}












public function setInput($input)
{
if ($this->isRunning()) {
throw new LogicException('Input can not be set while the process is running.');
}

$this->input = ProcessUtils::validateInput(sprintf('%s::%s', __CLASS__, __FUNCTION__), $input);

return $this;
}






public function getOptions()
{
return $this->options;
}








public function setOptions(array $options)
{
$this->options = $options;

return $this;
}








public function getEnhanceWindowsCompatibility()
{
return $this->enhanceWindowsCompatibility;
}








public function setEnhanceWindowsCompatibility($enhance)
{
$this->enhanceWindowsCompatibility = (bool) $enhance;

return $this;
}






public function getEnhanceSigchildCompatibility()
{
return $this->enhanceSigchildCompatibility;
}












public function setEnhanceSigchildCompatibility($enhance)
{
$this->enhanceSigchildCompatibility = (bool) $enhance;

return $this;
}









public function checkTimeout()
{
if ($this->status !== self::STATUS_STARTED) {
return;
}

if (null !== $this->timeout && $this->timeout < microtime(true) - $this->starttime) {
$this->stop(0);

throw new ProcessTimedOutException($this, ProcessTimedOutException::TYPE_GENERAL);
}

if (null !== $this->idleTimeout && $this->idleTimeout < microtime(true) - $this->lastOutputTime) {
$this->stop(0);

throw new ProcessTimedOutException($this, ProcessTimedOutException::TYPE_IDLE);
}
}






public static function isPtySupported()
{
static $result;

if (null !== $result) {
return $result;
}

if ('\\' === DIRECTORY_SEPARATOR) {
return $result = false;
}

$proc = @proc_open('echo 1', array(array('pty'), array('pty'), array('pty')), $pipes);
if (is_resource($proc)) {
proc_close($proc);

return $result = true;
}

return $result = false;
}






private function getDescriptors()
{
if ('\\' === DIRECTORY_SEPARATOR) {
$this->processPipes = WindowsPipes::create($this, $this->input);
} else {
$this->processPipes = UnixPipes::create($this, $this->input);
}
$descriptors = $this->processPipes->getDescriptors($this->outputDisabled);

if (!$this->useFileHandles && $this->enhanceSigchildCompatibility && $this->isSigchildEnabled()) {

 $descriptors = array_merge($descriptors, array(array('pipe', 'w')));

$this->commandline = '('.$this->commandline.') 3>/dev/null; code=$?; echo $code >&3; exit $code';
}

return $descriptors;
}











protected function buildCallback($callback)
{
$that = $this;
$out = self::OUT;
$callback = function ($type, $data) use ($that, $callback, $out) {
if ($out == $type) {
$that->addOutput($data);
} else {
$that->addErrorOutput($data);
}

if (null !== $callback) {
call_user_func($callback, $type, $data);
}
};

return $callback;
}






protected function updateStatus($blocking)
{
if (self::STATUS_STARTED !== $this->status) {
return;
}

$this->processInformation = proc_get_status($this->process);
$this->captureExitCode();

$this->readPipes($blocking, '\\' === DIRECTORY_SEPARATOR ? !$this->processInformation['running'] : true);

if (!$this->processInformation['running']) {
$this->close();
}
}






protected function isSigchildEnabled()
{
if (null !== self::$sigchild) {
return self::$sigchild;
}

if (!function_exists('phpinfo')) {
return self::$sigchild = false;
}

ob_start();
phpinfo(INFO_GENERAL);

return self::$sigchild = false !== strpos(ob_get_clean(), '--enable-sigchild');
}










private function validateTimeout($timeout)
{
$timeout = (float) $timeout;

if (0.0 === $timeout) {
$timeout = null;
} elseif ($timeout < 0) {
throw new InvalidArgumentException('The timeout value must be a valid positive integer or float number.');
}

return $timeout;
}







private function readPipes($blocking, $close)
{
$result = $this->processPipes->readAndWrite($blocking, $close);

$callback = $this->callback;
foreach ($result as $type => $data) {
if (3 == $type) {
$this->fallbackExitcode = (int) $data;
} else {
$callback($type === self::STDOUT ? self::OUT : self::ERR, $data);
}
}
}




private function captureExitCode()
{
if (isset($this->processInformation['exitcode']) && -1 != $this->processInformation['exitcode']) {
$this->exitcode = $this->processInformation['exitcode'];
}
}






private function close()
{
$this->processPipes->close();
if (is_resource($this->process)) {
$exitcode = proc_close($this->process);
} else {
$exitcode = -1;
}

$this->exitcode = -1 !== $exitcode ? $exitcode : (null !== $this->exitcode ? $this->exitcode : -1);
$this->status = self::STATUS_TERMINATED;

if (-1 === $this->exitcode && null !== $this->fallbackExitcode) {
$this->exitcode = $this->fallbackExitcode;
} elseif (-1 === $this->exitcode && $this->processInformation['signaled'] && 0 < $this->processInformation['termsig']) {

 $this->exitcode = 128 + $this->processInformation['termsig'];
}

return $this->exitcode;
}




private function resetProcessData()
{
$this->starttime = null;
$this->callback = null;
$this->exitcode = null;
$this->fallbackExitcode = null;
$this->processInformation = null;
$this->stdout = null;
$this->stderr = null;
$this->process = null;
$this->latestSignal = null;
$this->status = self::STATUS_READY;
$this->incrementalOutputOffset = 0;
$this->incrementalErrorOutputOffset = 0;
}













private function doSignal($signal, $throwException)
{
if (!$this->isRunning()) {
if ($throwException) {
throw new LogicException('Can not send signal on a non running process.');
}

return false;
}

if ($this->isSigchildEnabled()) {
if ($throwException) {
throw new RuntimeException('This PHP has been compiled with --enable-sigchild. The process can not be signaled.');
}

return false;
}

if (true !== @proc_terminate($this->process, $signal)) {
if ($throwException) {
throw new RuntimeException(sprintf('Error while sending signal `%s`.', $signal));
}

return false;
}

$this->latestSignal = $signal;

return true;
}








private function requireProcessIsStarted($functionName)
{
if (!$this->isStarted()) {
throw new LogicException(sprintf('Process must be started before calling %s.', $functionName));
}
}








private function requireProcessIsTerminated($functionName)
{
if (!$this->isTerminated()) {
throw new LogicException(sprintf('Process must be terminated before calling %s.', $functionName));
}
}
}
<?php










namespace Symfony\Component\Process;

use Symfony\Component\Process\Exception\InvalidArgumentException;
use Symfony\Component\Process\Exception\LogicException;






class ProcessBuilder
{
private $arguments;
private $cwd;
private $env = array();
private $input;
private $timeout = 60;
private $options = array();
private $inheritEnv = true;
private $prefix = array();
private $outputDisabled = false;






public function __construct(array $arguments = array())
{
$this->arguments = $arguments;
}








public static function create(array $arguments = array())
{
return new static($arguments);
}








public function add($argument)
{
$this->arguments[] = $argument;

return $this;
}










public function setPrefix($prefix)
{
$this->prefix = is_array($prefix) ? $prefix : array($prefix);

return $this;
}











public function setArguments(array $arguments)
{
$this->arguments = $arguments;

return $this;
}








public function setWorkingDirectory($cwd)
{
$this->cwd = $cwd;

return $this;
}








public function inheritEnvironmentVariables($inheritEnv = true)
{
$this->inheritEnv = $inheritEnv;

return $this;
}












public function setEnv($name, $value)
{
$this->env[$name] = $value;

return $this;
}












public function addEnvironmentVariables(array $variables)
{
$this->env = array_replace($this->env, $variables);

return $this;
}










public function setInput($input)
{
$this->input = ProcessUtils::validateInput(sprintf('%s::%s', __CLASS__, __FUNCTION__), $input);

return $this;
}












public function setTimeout($timeout)
{
if (null === $timeout) {
$this->timeout = null;

return $this;
}

$timeout = (float) $timeout;

if ($timeout < 0) {
throw new InvalidArgumentException('The timeout value must be a valid positive integer or float number.');
}

$this->timeout = $timeout;

return $this;
}









public function setOption($name, $value)
{
$this->options[$name] = $value;

return $this;
}






public function disableOutput()
{
$this->outputDisabled = true;

return $this;
}






public function enableOutput()
{
$this->outputDisabled = false;

return $this;
}








public function getProcess()
{
if (0 === count($this->prefix) && 0 === count($this->arguments)) {
throw new LogicException('You must add() command arguments before calling getProcess().');
}

$options = $this->options;

$arguments = array_merge($this->prefix, $this->arguments);
$script = implode(' ', array_map(array(__NAMESPACE__.'\\ProcessUtils', 'escapeArgument'), $arguments));

if ($this->inheritEnv) {

 $env = array_replace($_ENV, $_SERVER, $this->env);
} else {
$env = $this->env;
}

$process = new Process($script, $this->cwd, $env, $this->input, $this->timeout, $options);

if ($this->outputDisabled) {
$process->disableOutput();
}

return $process;
}
}
<?php










namespace Symfony\Component\Process;

use Symfony\Component\Process\Exception\InvalidArgumentException;








class ProcessUtils
{



private function __construct()
{
}








public static function escapeArgument($argument)
{

 
 
 
 if ('\\' === DIRECTORY_SEPARATOR) {
if ('' === $argument) {
return escapeshellarg($argument);
}

$escapedArgument = '';
$quote = false;
foreach (preg_split('/(")/i', $argument, -1, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE) as $part) {
if ('"' === $part) {
$escapedArgument .= '\\"';
} elseif (self::isSurroundedBy($part, '%')) {

 $escapedArgument .= '^%"'.substr($part, 1, -1).'"^%';
} else {

 if ('\\' === substr($part, -1)) {
$part .= '\\';
}
$quote = true;
$escapedArgument .= $part;
}
}
if ($quote) {
$escapedArgument = '"'.$escapedArgument.'"';
}

return $escapedArgument;
}

return escapeshellarg($argument);
}











public static function validateInput($caller, $input)
{
if (null !== $input) {
if (is_resource($input)) {
return $input;
}
if (is_scalar($input)) {
return (string) $input;
}

 if (is_object($input) && method_exists($input, '__toString')) {
return (string) $input;
}

throw new InvalidArgumentException(sprintf('%s only accepts strings or stream resources.', $caller));
}

return $input;
}

private static function isSurroundedBy($arg, $char)
{
return 2 < strlen($arg) && $char === $arg[0] && $char === $arg[strlen($arg) - 1];
}
}
Copyright (c) 2011 Jordi Boggiano

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
<?php










namespace Seld\JsonLint;
use stdClass;














class JsonParser
{
const DETECT_KEY_CONFLICTS = 1;
const ALLOW_DUPLICATE_KEYS = 2;
const PARSE_TO_ASSOC = 4;

private $lexer;

private $flags;
private $stack;
private $vstack; 
 private $lstack; 

private $symbols = array(
'error' => 2,
'JSONString' => 3,
'STRING' => 4,
'JSONNumber' => 5,
'NUMBER' => 6,
'JSONNullLiteral' => 7,
'NULL' => 8,
'JSONBooleanLiteral' => 9,
'TRUE' => 10,
'FALSE' => 11,
'JSONText' => 12,
'JSONValue' => 13,
'EOF' => 14,
'JSONObject' => 15,
'JSONArray' => 16,
'{' => 17,
'}' => 18,
'JSONMemberList' => 19,
'JSONMember' => 20,
':' => 21,
',' => 22,
'[' => 23,
']' => 24,
'JSONElementList' => 25,
'$accept' => 0,
'$end' => 1,
);

private $terminals_ = array(
2 => "error",
4 => "STRING",
6 => "NUMBER",
8 => "NULL",
10 => "TRUE",
11 => "FALSE",
14 => "EOF",
17 => "{",
18 => "}",
21 => ":",
22 => ",",
23 => "[",
24 => "]",
);

private $productions_ = array(
0,
array(3, 1),
array(5, 1),
array(7, 1),
array(9, 1),
array(9, 1),
array(12, 2),
array(13, 1),
array(13, 1),
array(13, 1),
array(13, 1),
array(13, 1),
array(13, 1),
array(15, 2),
array(15, 3),
array(20, 3),
array(19, 1),
array(19, 3),
array(16, 2),
array(16, 3),
array(25, 1),
array(25, 3)
);

private $table = array(array(3 => 5, 4 => array(1,12), 5 => 6, 6 => array(1,13), 7 => 3, 8 => array(1,9), 9 => 4, 10 => array(1,10), 11 => array(1,11), 12 => 1, 13 => 2, 15 => 7, 16 => 8, 17 => array(1,14), 23 => array(1,15)), array( 1 => array(3)), array( 14 => array(1,16)), array( 14 => array(2,7), 18 => array(2,7), 22 => array(2,7), 24 => array(2,7)), array( 14 => array(2,8), 18 => array(2,8), 22 => array(2,8), 24 => array(2,8)), array( 14 => array(2,9), 18 => array(2,9), 22 => array(2,9), 24 => array(2,9)), array( 14 => array(2,10), 18 => array(2,10), 22 => array(2,10), 24 => array(2,10)), array( 14 => array(2,11), 18 => array(2,11), 22 => array(2,11), 24 => array(2,11)), array( 14 => array(2,12), 18 => array(2,12), 22 => array(2,12), 24 => array(2,12)), array( 14 => array(2,3), 18 => array(2,3), 22 => array(2,3), 24 => array(2,3)), array( 14 => array(2,4), 18 => array(2,4), 22 => array(2,4), 24 => array(2,4)), array( 14 => array(2,5), 18 => array(2,5), 22 => array(2,5), 24 => array(2,5)), array( 14 => array(2,1), 18 => array(2,1), 21 => array(2,1), 22 => array(2,1), 24 => array(2,1)), array( 14 => array(2,2), 18 => array(2,2), 22 => array(2,2), 24 => array(2,2)), array( 3 => 20, 4 => array(1,12), 18 => array(1,17), 19 => 18, 20 => 19 ), array( 3 => 5, 4 => array(1,12), 5 => 6, 6 => array(1,13), 7 => 3, 8 => array(1,9), 9 => 4, 10 => array(1,10), 11 => array(1,11), 13 => 23, 15 => 7, 16 => 8, 17 => array(1,14), 23 => array(1,15), 24 => array(1,21), 25 => 22 ), array( 1 => array(2,6)), array( 14 => array(2,13), 18 => array(2,13), 22 => array(2,13), 24 => array(2,13)), array( 18 => array(1,24), 22 => array(1,25)), array( 18 => array(2,16), 22 => array(2,16)), array( 21 => array(1,26)), array( 14 => array(2,18), 18 => array(2,18), 22 => array(2,18), 24 => array(2,18)), array( 22 => array(1,28), 24 => array(1,27)), array( 22 => array(2,20), 24 => array(2,20)), array( 14 => array(2,14), 18 => array(2,14), 22 => array(2,14), 24 => array(2,14)), array( 3 => 20, 4 => array(1,12), 20 => 29 ), array( 3 => 5, 4 => array(1,12), 5 => 6, 6 => array(1,13), 7 => 3, 8 => array(1,9), 9 => 4, 10 => array(1,10), 11 => array(1,11), 13 => 30, 15 => 7, 16 => 8, 17 => array(1,14), 23 => array(1,15)), array( 14 => array(2,19), 18 => array(2,19), 22 => array(2,19), 24 => array(2,19)), array( 3 => 5, 4 => array(1,12), 5 => 6, 6 => array(1,13), 7 => 3, 8 => array(1,9), 9 => 4, 10 => array(1,10), 11 => array(1,11), 13 => 31, 15 => 7, 16 => 8, 17 => array(1,14), 23 => array(1,15)), array( 18 => array(2,17), 22 => array(2,17)), array( 18 => array(2,15), 22 => array(2,15)), array( 22 => array(2,21), 24 => array(2,21)),
);

private $defaultActions = array(
16 => array(2, 6)
);





public function lint($input)
{
try {
$this->parse($input);
} catch (ParsingException $e) {
return $e;
}
}






public function parse($input, $flags = 0)
{
$this->failOnBOM($input);

$this->flags = $flags;

$this->stack = array(0);
$this->vstack = array(null);
$this->lstack = array();

$yytext = '';
$yylineno = 0;
$yyleng = 0;
$recovering = 0;
$TERROR = 2;
$EOF = 1;

$this->lexer = new Lexer();
$this->lexer->setInput($input);

$yyloc = $this->lexer->yylloc;
$this->lstack[] = $yyloc;

$symbol = null;
$preErrorSymbol = null;
$state = null;
$action = null;
$a = null;
$r = null;
$yyval = new stdClass;
$p = null;
$len = null;
$newState = null;
$expected = null;
$errStr = null;

while (true) {

 $state = $this->stack[count($this->stack)-1];


 if (isset($this->defaultActions[$state])) {
$action = $this->defaultActions[$state];
} else {
if ($symbol == null) {
$symbol = $this->lex();
}

 $action = isset($this->table[$state][$symbol]) ? $this->table[$state][$symbol] : false;
}


 if (!$action || !$action[0]) {
if (!$recovering) {

 $expected = array();
foreach ($this->table[$state] as $p => $ignore) {
if (isset($this->terminals_[$p]) && $p > 2) {
$expected[] = "'" . $this->terminals_[$p] . "'";
}
}

$message = null;
if (in_array("'STRING'", $expected) && in_array(substr($this->lexer->match, 0, 1), array('"', "'"))) {
$message = "Invalid string";
if ("'" === substr($this->lexer->match, 0, 1)) {
$message .= ", it appears you used single quotes instead of double quotes";
} elseif (preg_match('{".+?(\\\\[^"bfnrt/\\\\u])}', $this->lexer->getUpcomingInput(), $match)) {
$message .= ", it appears you have an unescaped backslash at: ".$match[1];
} elseif (preg_match('{"(?:[^"]+|\\\\")*$}m', $this->lexer->getUpcomingInput())) {
$message .= ", it appears you forgot to terminated the string, or attempted to write a multiline string which is invalid";
}
}

$errStr = 'Parse error on line ' . ($yylineno+1) . ":\n";
$errStr .= $this->lexer->showPosition() . "\n";
if ($message) {
$errStr .= $message;
} else {
$errStr .= (count($expected) > 1) ? "Expected one of: " : "Expected: ";
$errStr .= implode(', ', $expected);
}

if (',' === substr(trim($this->lexer->getPastInput()), -1)) {
$errStr .= " - It appears you have an extra trailing comma";
}

$this->parseError($errStr, array(
'text' => $this->lexer->match,
'token' => !empty($this->terminals_[$symbol]) ? $this->terminals_[$symbol] : $symbol,
'line' => $this->lexer->yylineno,
'loc' => $yyloc,
'expected' => $expected,
));
}


 if ($recovering == 3) {
if ($symbol == $EOF) {
throw new ParsingException($errStr ?: 'Parsing halted.');
}


 $yyleng = $this->lexer->yyleng;
$yytext = $this->lexer->yytext;
$yylineno = $this->lexer->yylineno;
$yyloc = $this->lexer->yylloc;
$symbol = $this->lex();
}


 while (true) {

 if (array_key_exists($TERROR, $this->table[$state])) {
break;
}
if ($state == 0) {
throw new ParsingException($errStr ?: 'Parsing halted.');
}
$this->popStack(1);
$state = $this->stack[count($this->stack)-1];
}

$preErrorSymbol = $symbol; 
 $symbol = $TERROR; 
 $state = $this->stack[count($this->stack)-1];
$action = isset($this->table[$state][$TERROR]) ? $this->table[$state][$TERROR] : false;
$recovering = 3; 
 }


 if (is_array($action[0]) && count($action) > 1) {
throw new ParsingException('Parse Error: multiple actions possible at state: ' . $state . ', token: ' . $symbol);
}

switch ($action[0]) {
case 1: 
 $this->stack[] = $symbol;
$this->vstack[] = $this->lexer->yytext;
$this->lstack[] = $this->lexer->yylloc;
$this->stack[] = $action[1]; 
 $symbol = null;
if (!$preErrorSymbol) { 
 $yyleng = $this->lexer->yyleng;
$yytext = $this->lexer->yytext;
$yylineno = $this->lexer->yylineno;
$yyloc = $this->lexer->yylloc;
if ($recovering > 0) {
$recovering--;
}
} else { 
 $symbol = $preErrorSymbol;
$preErrorSymbol = null;
}
break;

case 2: 
 $len = $this->productions_[$action[1]][1];


 $yyval->token = $this->vstack[count($this->vstack) - $len]; 
 
 $yyval->store = array( 
 'first_line' => $this->lstack[count($this->lstack) - ($len ?: 1)]['first_line'],
'last_line' => $this->lstack[count($this->lstack) - 1]['last_line'],
'first_column' => $this->lstack[count($this->lstack) - ($len ?: 1)]['first_column'],
'last_column' => $this->lstack[count($this->lstack) - 1]['last_column'],
);
$r = $this->performAction($yyval, $yytext, $yyleng, $yylineno, $action[1], $this->vstack, $this->lstack);

if (!$r instanceof Undefined) {
return $r;
}

if ($len) {
$this->popStack($len);
}

$this->stack[] = $this->productions_[$action[1]][0]; 
 $this->vstack[] = $yyval->token;
$this->lstack[] = $yyval->store;
$newState = $this->table[$this->stack[count($this->stack)-2]][$this->stack[count($this->stack)-1]];
$this->stack[] = $newState;
break;

case 3: 

return true;
}
}

return true;
}

protected function parseError($str, $hash)
{
throw new ParsingException($str, $hash);
}


 
 
 private function performAction(stdClass $yyval, $yytext, $yyleng, $yylineno, $yystate, &$tokens)
{

 $len = count($tokens) - 1;
switch ($yystate) {
case 1:
$yytext = preg_replace_callback('{(?:\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4})}', array($this, 'stringInterpolation'), $yytext);
$yyval->token = $yytext;
break;
case 2:
if (strpos($yytext, 'e') !== false || strpos($yytext, 'E') !== false) {
$yyval->token = floatval($yytext);
} else {
$yyval->token = strpos($yytext, '.') === false ? intval($yytext) : floatval($yytext);
}
break;
case 3:
$yyval->token = null;
break;
case 4:
$yyval->token = true;
break;
case 5:
$yyval->token = false;
break;
case 6:
return $yyval->token = $tokens[$len-1];
case 13:
if ($this->flags & self::PARSE_TO_ASSOC) {
$yyval->token = array();
} else {
$yyval->token = new stdClass;
}
break;
case 14:
$yyval->token = $tokens[$len-1];
break;
case 15:
$yyval->token = array($tokens[$len-2], $tokens[$len]);
break;
case 16:
$property = $tokens[$len][0] === '' ? '_empty_' : $tokens[$len][0];
if ($this->flags & self::PARSE_TO_ASSOC) {
$yyval->token = array();
$yyval->token[$property] = $tokens[$len][1];
} else {
$yyval->token = new stdClass;
$yyval->token->$property = $tokens[$len][1];
}
break;
case 17:
if ($this->flags & self::PARSE_TO_ASSOC) {
$yyval->token =& $tokens[$len-2];
$key = $tokens[$len][0];
if (($this->flags & self::DETECT_KEY_CONFLICTS) && isset($tokens[$len-2][$key])) {
$errStr = 'Parse error on line ' . ($yylineno+1) . ":\n";
$errStr .= $this->lexer->showPosition() . "\n";
$errStr .= "Duplicate key: ".$tokens[$len][0];
throw new ParsingException($errStr);
} elseif (($this->flags & self::ALLOW_DUPLICATE_KEYS) && isset($tokens[$len-2][$key])) {
$duplicateCount = 1;
do {
$duplicateKey = $key . '.' . $duplicateCount++;
} while (isset($tokens[$len-2][$duplicateKey]));
$key = $duplicateKey;
}
$tokens[$len-2][$key] = $tokens[$len][1];
} else {
$yyval->token = $tokens[$len-2];
$key = $tokens[$len][0] === '' ? '_empty_' : $tokens[$len][0];
if (($this->flags & self::DETECT_KEY_CONFLICTS) && isset($tokens[$len-2]->{$key})) {
$errStr = 'Parse error on line ' . ($yylineno+1) . ":\n";
$errStr .= $this->lexer->showPosition() . "\n";
$errStr .= "Duplicate key: ".$tokens[$len][0];
throw new ParsingException($errStr);
} elseif (($this->flags & self::ALLOW_DUPLICATE_KEYS) && isset($tokens[$len-2]->{$key})) {
$duplicateCount = 1;
do {
$duplicateKey = $key . '.' . $duplicateCount++;
} while (isset($tokens[$len-2]->$duplicateKey));
$key = $duplicateKey;
}
$tokens[$len-2]->$key = $tokens[$len][1];
}
break;
case 18:
$yyval->token = array();
break;
case 19:
$yyval->token = $tokens[$len-1];
break;
case 20:
$yyval->token = array($tokens[$len]);
break;
case 21:
$tokens[$len-2][] = $tokens[$len];
$yyval->token = $tokens[$len-2];
break;
}

return new Undefined();
}

private function stringInterpolation($match)
{
switch ($match[0]) {
case '\\\\':
return '\\';
case '\"':
return '"';
case '\b':
return chr(8);
case '\f':
return chr(12);
case '\n':
return "\n";
case '\r':
return "\r";
case '\t':
return "\t";
case '\/':
return "/";
default:
return html_entity_decode('&#x'.ltrim(substr($match[0], 2), '0').';', 0, 'UTF-8');
}
}

private function popStack($n)
{
$this->stack = array_slice($this->stack, 0, - (2 * $n));
$this->vstack = array_slice($this->vstack, 0, - $n);
$this->lstack = array_slice($this->lstack, 0, - $n);
}

private function lex()
{
$token = $this->lexer->lex() ?: 1; 
 
 if (!is_numeric($token)) {
$token = isset($this->symbols[$token]) ? $this->symbols[$token] : $token;
}

return $token;
}

private function failOnBOM($input)
{

 $bom = "\xEF\xBB\xBF";

if (substr($input, 0, 3) === $bom) {
$this->parseError("BOM detected, make sure your input does not include a Unicode Byte-Order-Mark", array());
}
}
}
<?php










namespace Seld\JsonLint;






class Lexer
{
private $EOF = 1;
private $rules = array(
0 => '/^\s+/',
1 => '/^-?([0-9]|[1-9][0-9]+)(\.[0-9]+)?([eE][+-]?[0-9]+)?\b/',
2 => '{^"(?:\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^\0-\x09\x0a-\x1f\\\\"]+)*"}',
3 => '/^\{/',
4 => '/^\}/',
5 => '/^\[/',
6 => '/^\]/',
7 => '/^,/',
8 => '/^:/',
9 => '/^true\b/',
10 => '/^false\b/',
11 => '/^null\b/',
12 => '/^$/',
13 => '/^./',
);

private $conditions = array(
"INITIAL" => array(
"rules" => array(0,1,2,3,4,5,6,7,8,9,10,11,12,13),
"inclusive" => true,
),
);

private $conditionStack;
private $input;
private $more;
private $done;
private $matched;

public $match;
public $yylineno;
public $yyleng;
public $yytext;
public $yylloc;

public function lex()
{
$r = $this->next();
if (!$r instanceof Undefined) {
return $r;
}

return $this->lex();
}

public function setInput($input)
{
$this->input = $input;
$this->more = false;
$this->done = false;
$this->yylineno = $this->yyleng = 0;
$this->yytext = $this->matched = $this->match = '';
$this->conditionStack = array('INITIAL');
$this->yylloc = array('first_line' => 1, 'first_column' => 0, 'last_line' => 1, 'last_column' => 0);

return $this;
}

public function showPosition()
{
$pre = str_replace("\n", '', $this->getPastInput());
$c = str_repeat('-', max(0, strlen($pre) - 1)); 

return $pre . str_replace("\n", '', $this->getUpcomingInput()) . "\n" . $c . "^";
}

public function getPastInput()
{
$past = substr($this->matched, 0, strlen($this->matched) - strlen($this->match));

return (strlen($past) > 20 ? '...' : '') . substr($past, -20);
}

public function getUpcomingInput()
{
$next = $this->match;
if (strlen($next) < 20) {
$next .= substr($this->input, 0, 20 - strlen($next));
}

return substr($next, 0, 20) . (strlen($next) > 20 ? '...' : '');
}

protected function parseError($str, $hash)
{
throw new \Exception($str);
}

private function next()
{
if ($this->done) {
return $this->EOF;
}
if (!$this->input) {
$this->done = true;
}

$token = null;
$match = null;
$col = null;
$lines = null;

if (!$this->more) {
$this->yytext = '';
$this->match = '';
}

$rules = $this->getCurrentRules();
$rulesLen = count($rules);

for ($i=0; $i < $rulesLen; $i++) {
if (preg_match($this->rules[$rules[$i]], $this->input, $match)) {
preg_match_all('/\n.*/', $match[0], $lines);
$lines = $lines[0];
if ($lines) {
$this->yylineno += count($lines);
}

$this->yylloc = array(
'first_line' => $this->yylloc['last_line'],
'last_line' => $this->yylineno+1,
'first_column' => $this->yylloc['last_column'],
'last_column' => $lines ? strlen($lines[count($lines) - 1]) - 1 : $this->yylloc['last_column'] + strlen($match[0]),
);
$this->yytext .= $match[0];
$this->match .= $match[0];
$this->yyleng = strlen($this->yytext);
$this->more = false;
$this->input = substr($this->input, strlen($match[0]));
$this->matched .= $match[0];
$token = $this->performAction($rules[$i], $this->conditionStack[count($this->conditionStack)-1]);
if ($token) {
return $token;
}

return new Undefined();
}
}

if ($this->input === "") {
return $this->EOF;
}

$this->parseError(
'Lexical error on line ' . ($this->yylineno+1) . ". Unrecognized text.\n" . $this->showPosition(),
array(
'text' => "",
'token' => null,
'line' => $this->yylineno,
)
);
}

private function getCurrentRules()
{
return $this->conditions[$this->conditionStack[count($this->conditionStack)-1]]['rules'];
}

private function performAction($avoiding_name_collisions, $YY_START)
{
switch ($avoiding_name_collisions) {
case 0:
break;
case 1:
return 6;
break;
case 2:
$this->yytext = substr($this->yytext, 1, $this->yyleng-2);

return 4;
case 3:
return 17;
case 4:
return 18;
case 5:
return 23;
case 6:
return 24;
case 7:
return 22;
case 8:
return 21;
case 9:
return 10;
case 10:
return 11;
case 11:
return 8;
case 12:
return 14;
case 13:
return 'INVALID';
}
}
}
<?php










namespace Seld\JsonLint;

class ParsingException extends \Exception
{
protected $details;

public function __construct($message, $details = array())
{
$this->details = $details;
parent::__construct($message);
}

public function getDetails()
{
return $this->details;
}
}
<?php










namespace Seld\JsonLint;

class Undefined
{
}
Copyright (c) 2015 Jordi Boggiano

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
<?php

require __DIR__.'/../vendor/autoload.php';

echo 'Say hello (visible): ';

$answer = Seld\CliPrompt\CliPrompt::prompt();

echo 'You answered: '.$answer . PHP_EOL;

echo 'Say hello (hidden): ';

$answer = Seld\CliPrompt\CliPrompt::hiddenPrompt();

echo 'You answered: '.$answer . PHP_EOL;
<?php










namespace Seld\CliPrompt;

class CliPrompt
{





public static function prompt()
{
$stdin = fopen('php://stdin', 'r');
$answer = self::trimAnswer(fgets($stdin, 4096));
fclose($stdin);

return $answer;
}










public static function hiddenPrompt($allowFallback = false)
{

 if (defined('PHP_WINDOWS_VERSION_BUILD')) {

 $exe = __DIR__.'\\..\\res\\hiddeninput.exe';


 if ('phar:' === substr(__FILE__, 0, 5)) {
$tmpExe = sys_get_temp_dir().'/hiddeninput.exe';


 
 $source = fopen($exe, 'r');
$target = fopen($tmpExe, 'w+');
stream_copy_to_stream($source, $target);
fclose($source);
fclose($target);
unset($source, $target);

$exe = $tmpExe;
}

$answer = self::trimAnswer(shell_exec($exe));


 if (isset($tmpExe)) {
unlink($tmpExe);
}


 echo PHP_EOL;

return $answer;
}

if (file_exists('/usr/bin/env')) {

 $test = "/usr/bin/env %s -c 'echo OK' 2> /dev/null";
foreach (array('bash', 'zsh', 'ksh', 'csh') as $sh) {
if ('OK' === rtrim(shell_exec(sprintf($test, $sh)))) {
$shell = $sh;
break;
}
}

if (isset($shell)) {
$readCmd = ($shell === 'csh') ? 'set mypassword = $<' : 'read -r mypassword';
$command = sprintf("/usr/bin/env %s -c 'stty -echo; %s; stty echo; echo \$mypassword'", $shell, $readCmd);
$value = self::trimAnswer(shell_exec($command));


 echo PHP_EOL;

return $value;
}
}


 if (!$allowFallback) {
throw new \RuntimeException('Could not prompt for input in a secure fashion, aborting');
}

return self::prompt();
}

private static function trimAnswer($str)
{
return preg_replace('{\r?\n$}D', '', $str);
}
}
Copyright (c) 2008, Gradua Networks
Author: Bruno Prieto Reis
All rights reserved.


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * Neither the name of the Gradua Networks nor the names of its contributors
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<?php








namespace JsonSchema\Constraints;







class CollectionConstraint extends Constraint
{



public function check($value, $schema = null, $path = null, $i = null)
{

 if (isset($schema->minItems) && count($value) < $schema->minItems) {
$this->addError($path, "There must be a minimum of " . $schema->minItems . " in the array");
}


 if (isset($schema->maxItems) && count($value) > $schema->maxItems) {
$this->addError($path, "There must be a maximum of " . $schema->maxItems . " in the array");
}


 if (isset($schema->uniqueItems)) {
$unique = $value;
if (is_array($value) && count($value)) {
$unique = array_map(function($e) { return var_export($e, true); }, $value);
}
if (count(array_unique($unique)) != count($value)) {
$this->addError($path, "There are no duplicates allowed in the array");
}
}


 if (isset($schema->items)) {
$this->validateItems($value, $schema, $path, $i);
}
}









protected function validateItems($value, $schema = null, $path = null, $i = null)
{
if (is_object($schema->items)) {

 foreach ($value as $k => $v) {
$initErrors = $this->getErrors();


 $this->checkUndefined($v, $schema->items, $path, $k);


 if (count($initErrors) < count($this->getErrors()) && (isset($schema->additionalItems) && $schema->additionalItems !== false)) {
$secondErrors = $this->getErrors();
$this->checkUndefined($v, $schema->additionalItems, $path, $k);
}


 if (isset($secondErrors) && count($secondErrors) < count($this->getErrors())) {
$this->errors = $secondErrors;
} else if (isset($secondErrors) && count($secondErrors) === count($this->getErrors())) {
$this->errors = $initErrors;
}
}
} else {

 foreach ($value as $k => $v) {
if (array_key_exists($k, $schema->items)) {
$this->checkUndefined($v, $schema->items[$k], $path, $k);
} else {

 if (property_exists($schema, 'additionalItems')) {
if ($schema->additionalItems !== false) {
$this->checkUndefined($v, $schema->additionalItems, $path, $k);
} else {
$this->addError(
$path, 'The item ' . $i . '[' . $k . '] is not defined and the definition does not allow additional items');
}
} else {

 $this->checkUndefined($v, new \stdClass(), $path, $k);
}
}
}


 if(count($value) > 0) {
for ($k = count($value); $k < count($schema->items); $k++) {
$this->checkUndefined(new UndefinedConstraint(), $schema->items[$k], $path, $k);
}
}
}
}
}<?php








namespace JsonSchema\Constraints;

use JsonSchema\Uri\UriRetriever;







abstract class Constraint implements ConstraintInterface
{
protected $checkMode = self::CHECK_MODE_NORMAL;
protected $uriRetriever;
protected $errors = array();
protected $inlineSchemaProperty = '$schema';

const CHECK_MODE_NORMAL = 1;
const CHECK_MODE_TYPE_CAST = 2;





public function __construct($checkMode = self::CHECK_MODE_NORMAL, UriRetriever $uriRetriever = null)
{
$this->checkMode = $checkMode;
$this->uriRetriever = $uriRetriever;
}




public function getUriRetriever()
{
if (is_null($this->uriRetriever))
{
$this->setUriRetriever(new UriRetriever);
}

return $this->uriRetriever;
}




public function setUriRetriever(UriRetriever $uriRetriever)
{
$this->uriRetriever = $uriRetriever;
}




public function addError($path, $message)
{
$this->errors[] = array(
'property' => $path,
'message' => $message
);
}




public function addErrors(array $errors)
{
$this->errors = array_merge($this->errors, $errors);
}




public function getErrors()
{
return $this->errors;
}




public function isValid()
{
return !$this->getErrors();
}





public function reset()
{
$this->errors = array();
}









protected function incrementPath($path, $i)
{
if ($path !== '') {
if (is_int($i)) {
$path .= '[' . $i . ']';
} elseif ($i == '') {
$path .= '';
} else {
$path .= '.' . $i;
}
} else {
$path = $i;
}

return $path;
}









protected function checkArray($value, $schema = null, $path = null, $i = null)
{
$validator = new CollectionConstraint($this->checkMode, $this->uriRetriever);
$validator->check($value, $schema, $path, $i);

$this->addErrors($validator->getErrors());
}










protected function checkObject($value, $schema = null, $path = null, $i = null, $patternProperties = null)
{
$validator = new ObjectConstraint($this->checkMode, $this->uriRetriever);
$validator->check($value, $schema, $path, $i, $patternProperties);

$this->addErrors($validator->getErrors());
}









protected function checkType($value, $schema = null, $path = null, $i = null)
{
$validator = new TypeConstraint($this->checkMode, $this->uriRetriever);
$validator->check($value, $schema, $path, $i);

$this->addErrors($validator->getErrors());
}









protected function checkUndefined($value, $schema = null, $path = null, $i = null)
{
$validator = new UndefinedConstraint($this->checkMode, $this->uriRetriever);
$validator->check($value, $schema, $path, $i);

$this->addErrors($validator->getErrors());
}









protected function checkString($value, $schema = null, $path = null, $i = null)
{
$validator = new StringConstraint($this->checkMode, $this->uriRetriever);
$validator->check($value, $schema, $path, $i);

$this->addErrors($validator->getErrors());
}









protected function checkNumber($value, $schema = null, $path = null, $i = null)
{
$validator = new NumberConstraint($this->checkMode, $this->uriRetriever);
$validator->check($value, $schema, $path, $i);

$this->addErrors($validator->getErrors());
}









protected function checkEnum($value, $schema = null, $path = null, $i = null)
{
$validator = new EnumConstraint($this->checkMode, $this->uriRetriever);
$validator->check($value, $schema, $path, $i);

$this->addErrors($validator->getErrors());
}

protected function checkFormat($value, $schema = null, $path = null, $i = null)
{
$validator = new FormatConstraint($this->checkMode, $this->uriRetriever);
$validator->check($value, $schema, $path, $i);

$this->addErrors($validator->getErrors());
}





protected function retrieveUri($uri)
{
if (null === $this->uriRetriever) {
$this->setUriRetriever(new UriRetriever);
}
$jsonSchema = $this->uriRetriever->retrieve($uri);

 return $jsonSchema;
}
}
<?php








namespace JsonSchema\Constraints;






interface ConstraintInterface
{





public function getErrors();






public function addErrors(array $errors);







public function addError($path, $message);






public function isValid();










public function check($value, $schema = null, $path = null, $i = null);
}<?php








namespace JsonSchema\Constraints;







class EnumConstraint extends Constraint
{



public function check($element, $schema = null, $path = null, $i = null)
{

 if ($element instanceof UndefinedConstraint && (!isset($schema->required) || !$schema->required)) {
return;
}

foreach ($schema->enum as $enum) {
$type = gettype($element);
if ($type === gettype($enum)) {
if ($type == "object") {
if ($element == $enum)
return;
} else {
if ($element === $enum)
return;

}
}
}

$this->addError($path, "does not have a value in the enumeration " . print_r($schema->enum, true));
}
}
<?php








namespace JsonSchema\Constraints;







class FormatConstraint extends Constraint
{



public function check($element, $schema = null, $path = null, $i = null)
{
if (!isset($schema->format)) {
return;
}

switch ($schema->format) {
case 'date':
if (!$date = $this->validateDateTime($element, 'Y-m-d')) {
$this->addError($path, sprintf('Invalid date %s, expected format YYYY-MM-DD', json_encode($element)));
}
break;

case 'time':
if (!$this->validateDateTime($element, 'H:i:s')) {
$this->addError($path, sprintf('Invalid time %s, expected format hh:mm:ss', json_encode($element)));
}
break;

case 'date-time':
if (!$this->validateDateTime($element, 'Y-m-d\TH:i:s\Z') &&
!$this->validateDateTime($element, 'Y-m-d\TH:i:s.u\Z') &&
!$this->validateDateTime($element, 'Y-m-d\TH:i:sP') &&
!$this->validateDateTime($element, 'Y-m-d\TH:i:sO')
) {
$this->addError($path, sprintf('Invalid date-time %s, expected format YYYY-MM-DDThh:mm:ssZ or YYYY-MM-DDThh:mm:ss+hh:mm', json_encode($element)));
}
break;

case 'utc-millisec':
if (!$this->validateDateTime($element, 'U')) {
$this->addError($path, sprintf('Invalid time %s, expected integer of milliseconds since Epoch', json_encode($element)));
}
break;

case 'regex':
if (!$this->validateRegex($element)) {
$this->addError($path, 'Invalid regex format ' . $element);
}
break;

case 'color':
if (!$this->validateColor($element)) {
$this->addError($path, "Invalid color");
}
break;

case 'style':
if (!$this->validateStyle($element)) {
$this->addError($path, "Invalid style");
}
break;

case 'phone':
if (!$this->validatePhone($element)) {
$this->addError($path, "Invalid phone number");
}
break;

case 'uri':
if (null === filter_var($element, FILTER_VALIDATE_URL, FILTER_NULL_ON_FAILURE)) {
$this->addError($path, "Invalid URL format");
}
break;

case 'email':
if (null === filter_var($element, FILTER_VALIDATE_EMAIL, FILTER_NULL_ON_FAILURE)) {
$this->addError($path, "Invalid email");
}
break;

case 'ip-address':
case 'ipv4':
if (null === filter_var($element, FILTER_VALIDATE_IP, FILTER_NULL_ON_FAILURE | FILTER_FLAG_IPV4)) {
$this->addError($path, "Invalid IP address");
}
break;

case 'ipv6':
if (null === filter_var($element, FILTER_VALIDATE_IP, FILTER_NULL_ON_FAILURE | FILTER_FLAG_IPV6)) {
$this->addError($path, "Invalid IP address");
}
break;

case 'host-name':
case 'hostname':
if (!$this->validateHostname($element)) {
$this->addError($path, "Invalid hostname");
}
break;

default:
$this->addError($path, "Unknown format: " . json_encode($schema->format));
break;
}
}

protected function validateDateTime($datetime, $format)
{
$dt = \DateTime::createFromFormat($format, $datetime);

if (!$dt) {
return false;
}

return $datetime === $dt->format($format);
}

protected function validateRegex($regex)
{
return false !== @preg_match('/' . $regex . '/', '');
}

protected function validateColor($color)
{
if (in_array(strtolower($color), array('aqua', 'black', 'blue', 'fuchsia',
'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple',
'red', 'silver', 'teal', 'white', 'yellow'))) {
return true;
}

return preg_match('/^#([a-f0-9]{3}|[a-f0-9]{6})$/i', $color);
}

protected function validateStyle($style)
{
$properties = explode(';', rtrim($style, ';'));
$invalidEntries = preg_grep('/^\s*[-a-z]+\s*:\s*.+$/i', $properties, PREG_GREP_INVERT);

return empty($invalidEntries);
}

protected function validatePhone($phone)
{
return preg_match('/^\+?(\(\d{3}\)|\d{3}) \d{3} \d{4}$/', $phone);
}

protected function validateHostname($host)
{
return preg_match('/^[_a-z]+\.([_a-z]+\.?)+$/i', $host);
}
}
<?php








namespace JsonSchema\Constraints;







class NumberConstraint extends Constraint
{



public function check($element, $schema = null, $path = null, $i = null)
{

 if (isset($schema->exclusiveMinimum)) {
if (isset($schema->minimum)) {
if ($schema->exclusiveMinimum && $element === $schema->minimum) {
$this->addError($path, "must have a minimum value greater than boundary value of " . $schema->minimum);
} else if ($element < $schema->minimum) {
$this->addError($path, "must have a minimum value of " . $schema->minimum);
}
} else {
$this->addError($path, "use of exclusiveMinimum requires presence of minimum");
}
} else if (isset($schema->minimum) && $element < $schema->minimum) {
$this->addError($path, "must have a minimum value of " . $schema->minimum);
}


 if (isset($schema->exclusiveMaximum)) {
if (isset($schema->maximum)) {
if ($schema->exclusiveMaximum && $element === $schema->maximum) {
$this->addError($path, "must have a maximum value less than boundary value of " . $schema->maximum);
} else if ($element > $schema->maximum) {
$this->addError($path, "must have a maximum value of " . $schema->maximum);
}
} else {
$this->addError($path, "use of exclusiveMaximum requires presence of maximum");
}
} else if (isset($schema->maximum) && $element > $schema->maximum) {
$this->addError($path, "must have a maximum value of " . $schema->maximum);
}


 if (isset($schema->divisibleBy) && $this->fmod($element, $schema->divisibleBy) != 0) {
$this->addError($path, "is not divisible by " . $schema->divisibleBy);
}


 if (isset($schema->multipleOf) && $this->fmod($element, $schema->multipleOf) != 0) {
$this->addError($path, "must be a multiple of " . $schema->multipleOf);
}

$this->checkFormat($element, $schema, $path, $i);
}

private function fmod($number1, $number2)
{
$modulus = fmod($number1, $number2);
$precision = abs(0.0000000001);
$diff = (float)($modulus - $number2);

if (-$precision < $diff && $diff < $precision) {
return 0.0;
}

$decimals1 = mb_strpos($number1, ".") ? mb_strlen($number1) - mb_strpos($number1, ".") - 1 : 0;
$decimals2 = mb_strpos($number2, ".") ? mb_strlen($number2) - mb_strpos($number2, ".") - 1 : 0;

return (float)round($modulus, max($decimals1, $decimals2));
}
}
<?php








namespace JsonSchema\Constraints;







class ObjectConstraint extends Constraint
{



function check($element, $definition = null, $path = null, $additionalProp = null, $patternProperties = null)
{
if ($element instanceof UndefinedConstraint) {
return;
}

$matches = array();
if ($patternProperties) {
$matches = $this->validatePatternProperties($element, $path, $patternProperties);
}

if ($definition) {

 $this->validateDefinition($element, $definition, $path);
}


 $this->validateElement($element, $matches, $definition, $path, $additionalProp);
}

public function validatePatternProperties($element, $path, $patternProperties)
{
$matches = array();
foreach ($patternProperties as $pregex => $schema) {

 if (@preg_match('/'. $pregex . '/', '') === false) {
$this->addError($path, 'The pattern "' . $pregex . '" is invalid');
continue;
}
foreach ($element as $i => $value) {
if (preg_match('/' . $pregex . '/', $i)) {
$matches[] = $i;
$this->checkUndefined($value, $schema ? : new \stdClass(), $path, $i);
}
}
}
return $matches;
}










public function validateElement($element, $matches, $objectDefinition = null, $path = null, $additionalProp = null)
{
foreach ($element as $i => $value) {

$property = $this->getProperty($element, $i, new UndefinedConstraint());
$definition = $this->getProperty($objectDefinition, $i);


 if (!in_array($i, $matches) && $additionalProp === false && $this->inlineSchemaProperty !== $i && !$definition) {
$this->addError($path, "The property " . $i . " is not defined and the definition does not allow additional properties");
}


 if (!in_array($i, $matches) && $additionalProp && !$definition) {
if ($additionalProp === true) {
$this->checkUndefined($value, null, $path, $i);
} else {
$this->checkUndefined($value, $additionalProp, $path, $i);
}
}


 $require = $this->getProperty($definition, 'requires');
if ($require && !$this->getProperty($element, $require)) {
$this->addError($path, "the presence of the property " . $i . " requires that " . $require . " also be present");
}

if (!$definition) {

 $this->checkUndefined($value, new \stdClass(), $path, $i);
}
}
}








public function validateDefinition($element, $objectDefinition = null, $path = null)
{
foreach ($objectDefinition as $i => $value) {
$property = $this->getProperty($element, $i, new UndefinedConstraint());
$definition = $this->getProperty($objectDefinition, $i);
$this->checkUndefined($property, $definition, $path, $i);
}
}










protected function getProperty($element, $property, $fallback = null)
{
if (is_array($element) ) {
return array_key_exists($property, $element) ? $element[$property] : $fallback;
} elseif (is_object($element)) {
return property_exists($element, $property) ? $element->$property : $fallback;
}

return $fallback;
}
}<?php








namespace JsonSchema\Constraints;

use JsonSchema\Exception\InvalidArgumentException;







class SchemaConstraint extends Constraint
{



public function check($element, $schema = null, $path = null, $i = null)
{
if ($schema !== null) {

 $this->checkUndefined($element, $schema, '', '');
} elseif (property_exists($element, $this->inlineSchemaProperty)) {

 $this->checkUndefined($element, $element->{$this->inlineSchemaProperty}, '', '');
} else {
throw new InvalidArgumentException('no schema found to verify against');
}
}
}<?php








namespace JsonSchema\Constraints;







class StringConstraint extends Constraint
{



public function check($element, $schema = null, $path = null, $i = null)
{

 if (isset($schema->maxLength) && $this->strlen($element) > $schema->maxLength) {
$this->addError($path, "must be at most " . $schema->maxLength . " characters long");
}


 if (isset($schema->minLength) && $this->strlen($element) < $schema->minLength) {
$this->addError($path, "must be at least " . $schema->minLength . " characters long");
}


 if (isset($schema->pattern) && !preg_match('#' . str_replace('#', '\\#', $schema->pattern) . '#', $element)) {
$this->addError($path, "does not match the regex pattern " . $schema->pattern);
}

$this->checkFormat($element, $schema, $path, $i);
}

private function strlen($string)
{
if (extension_loaded('mbstring')) {
return mb_strlen($string, mb_detect_encoding($string));
} else {
return strlen($string);
}
}
}
<?php








namespace JsonSchema\Constraints;

use JsonSchema\Exception\InvalidArgumentException;
use UnexpectedValueException as StandardUnexpectedValueException;







class TypeConstraint extends Constraint
{



static $wording = array(
'integer' => 'an integer',
'number' => 'a number',
'boolean' => 'a boolean',
'object' => 'an object',
'array' => 'an array',
'string' => 'a string',
'null' => 'a null',
'any' => NULL, 
 0 => NULL, 
 );




public function check($value = null, $schema = null, $path = null, $i = null)
{
$type = isset($schema->type) ? $schema->type : null;
$isValid = true;

if (is_array($type)) {

 $validatedOneType = false;
$errors = array();
foreach ($type as $tp) {
$validator = new TypeConstraint($this->checkMode);
$subSchema = new \stdClass();
$subSchema->type = $tp;
$validator->check($value, $subSchema, $path, null);
$error = $validator->getErrors();

if (!count($error)) {
$validatedOneType = true;
break;
}

$errors = $error;
}

if (!$validatedOneType) {
return $this->addErrors($errors);
}
} elseif (is_object($type)) {
$this->checkUndefined($value, $type, $path);
} else {
$isValid = $this->validateType($value, $type);
}

if ($isValid === false) {
if (!isset(self::$wording[$type])) {
throw new StandardUnexpectedValueException(
sprintf(
"No wording for %s available, expected wordings are: [%s]",
var_export($type, true),
implode(', ', array_filter(self::$wording)))
);
}
$this->addError($path, gettype($value) . " value found, but " . self::$wording[$type] . " is required");
}
}











protected function validateType($value, $type)
{

 if (!$type) {
return true;
}

if ('integer' === $type) {
return is_int($value);
}

if ('number' === $type) {
return is_numeric($value) && !is_string($value);
}

if ('boolean' === $type) {
return is_bool($value);
}

if ('object' === $type) {
return is_object($value);

 }

if ('array' === $type) {
return is_array($value);
}

if ('string' === $type) {
return is_string($value);
}

if ('null' === $type) {
return is_null($value);
}

if ('any' === $type) {
return true;
}

throw new InvalidArgumentException((is_object($value) ? 'object' : $value) . ' is an invalid type for ' . $type);
}
}<?php








namespace JsonSchema\Constraints;

use JsonSchema\Exception\InvalidArgumentException;
use JsonSchema\Uri\UriResolver;







class UndefinedConstraint extends Constraint
{



public function check($value, $schema = null, $path = null, $i = null)
{
if (is_null($schema)) {
return;
}

if (!is_object($schema)) {
throw new InvalidArgumentException(
'Given schema must be an object in ' . $path
. ' but is a ' . gettype($schema)
);
}

$i = is_null($i) ? "" : $i;
$path = $this->incrementPath($path, $i);


 $this->validateCommonProperties($value, $schema, $path);


 $this->validateOfProperties($value, $schema, $path);


 $this->validateTypes($value, $schema, $path, $i);
}









public function validateTypes($value, $schema = null, $path = null, $i = null)
{

 if (is_array($value)) {
$this->checkArray($value, $schema, $path, $i);
}


 if (is_object($value) && (isset($schema->properties) || isset($schema->patternProperties))) {
$this->checkObject(
$value,
isset($schema->properties) ? $schema->properties : null,
$path,
isset($schema->additionalProperties) ? $schema->additionalProperties : null,
isset($schema->patternProperties) ? $schema->patternProperties : null
);
}


 if (is_string($value)) {
$this->checkString($value, $schema, $path, $i);
}


 if (is_numeric($value)) {
$this->checkNumber($value, $schema, $path, $i);
}


 if (isset($schema->enum)) {
$this->checkEnum($value, $schema, $path, $i);
}
}









protected function validateCommonProperties($value, $schema = null, $path = null, $i = "")
{

 if (isset($schema->extends)) {
if (is_string($schema->extends)) {
$schema->extends = $this->validateUri($schema, $schema->extends);
}
if (is_array($schema->extends)) {
foreach ($schema->extends as $extends) {
$this->checkUndefined($value, $extends, $path, $i);
}
} else {
$this->checkUndefined($value, $schema->extends, $path, $i);
}
}


 if (is_object($value)) {

if (!($value instanceof UndefinedConstraint) && isset($schema->required) && is_array($schema->required) ) {

 foreach ($schema->required as $required) {
if (!property_exists($value, $required)) {
$this->addError($path, "the property " . $required . " is required");
}
}
} else if (isset($schema->required) && !is_array($schema->required)) {

 if ( $schema->required && $value instanceof UndefinedConstraint) {
$this->addError($path, "is missing and it is required");
}
}
}


 if (!($value instanceof UndefinedConstraint)) {
$this->checkType($value, $schema, $path);
}


 if (isset($schema->disallow)) {
$initErrors = $this->getErrors();

$typeSchema = new \stdClass();
$typeSchema->type = $schema->disallow;
$this->checkType($value, $typeSchema, $path);


 if (count($this->getErrors()) == count($initErrors)) {
$this->addError($path, "disallowed value was matched");
} else {
$this->errors = $initErrors;
}
}

if (isset($schema->not)) {
$initErrors = $this->getErrors();
$this->checkUndefined($value, $schema->not, $path, $i);


 if (count($this->getErrors()) == count($initErrors)) {
$this->addError($path, "matched a schema which it should not");
} else {
$this->errors = $initErrors;
}
}


 if (is_object($value)) {
if (isset($schema->minProperties)) {
if (count(get_object_vars($value)) < $schema->minProperties) {
$this->addError($path, "must contain a minimum of " . $schema->minProperties . " properties");
}
}
if (isset($schema->maxProperties)) {
if (count(get_object_vars($value)) > $schema->maxProperties) {
$this->addError($path, "must contain no more than " . $schema->maxProperties . " properties");
}
}
}


 if (is_object($value) && isset($schema->dependencies)) {
$this->validateDependencies($value, $schema->dependencies, $path);
}
}









protected function validateOfProperties($value, $schema, $path, $i = "")
{

 if ($value instanceof UndefinedConstraint) {
return;
}

if (isset($schema->allOf)) {
$isValid = true;
foreach ($schema->allOf as $allOf) {
$initErrors = $this->getErrors();
$this->checkUndefined($value, $allOf, $path, $i);
$isValid = $isValid && (count($this->getErrors()) == count($initErrors));
}
if (!$isValid) {
$this->addError($path, "failed to match all schemas");
}
}

if (isset($schema->anyOf)) {
$isValid = false;
$startErrors = $this->getErrors();
foreach ($schema->anyOf as $anyOf) {
$initErrors = $this->getErrors();
$this->checkUndefined($value, $anyOf, $path, $i);
if ($isValid = (count($this->getErrors()) == count($initErrors))) {
break;
}
}
if (!$isValid) {
$this->addError($path, "failed to match at least one schema");
} else {
$this->errors = $startErrors;
}
}

if (isset($schema->oneOf)) {
$allErrors = array();
$matchedSchemas = 0;
$startErrors = $this->getErrors();
foreach ($schema->oneOf as $oneOf) {
$this->errors = array();
$this->checkUndefined($value, $oneOf, $path, $i);
if (count($this->getErrors()) == 0) {
$matchedSchemas++;
}
$allErrors = array_merge($allErrors, array_values($this->getErrors()));
}
if ($matchedSchemas !== 1) {
$this->addErrors(
array_merge(
$allErrors,
array(array(
'property' => $path,
'message' => "failed to match exactly one schema"
),),
$startErrors
)
);
} else {
$this->errors = $startErrors;
}
}
}









protected function validateDependencies($value, $dependencies, $path, $i = "")
{
foreach ($dependencies as $key => $dependency) {
if (property_exists($value, $key)) {
if (is_string($dependency)) {

 if (!property_exists($value, $dependency)) {
$this->addError($path, "$key depends on $dependency and $dependency is missing");
}
} else if (is_array($dependency)) {

 foreach ($dependency as $d) {
if (!property_exists($value, $d)) {
$this->addError($path, "$key depends on $d and $d is missing");
}
}
} else if (is_object($dependency)) {

 $this->checkUndefined($value, $dependency, $path, $i);
}
}
}
}

protected function validateUri($schema, $schemaUri = null)
{
$resolver = new UriResolver();
$retriever = $this->getUriRetriever();

$jsonSchema = null;
if ($resolver->isValid($schemaUri)) {
$schemaId = property_exists($schema, 'id') ? $schema->id : null;
$jsonSchema = $retriever->retrieve($schemaId, $schemaUri);
}

return $jsonSchema;
}
}
<?php








namespace JsonSchema\Exception;




class InvalidArgumentException extends \InvalidArgumentException
{
}<?php








namespace JsonSchema\Exception;




class InvalidSchemaMediaTypeException extends \RuntimeException
{ 
}<?php








namespace JsonSchema\Exception;




class InvalidSourceUriException extends InvalidArgumentException
{
}
<?php








namespace JsonSchema\Exception;




class JsonDecodingException extends \RuntimeException
{
public function __construct($code = JSON_ERROR_NONE, \Exception $previous = null)
{
switch ($code) {
case JSON_ERROR_DEPTH:
$message = 'The maximum stack depth has been exceeded';
break;
case JSON_ERROR_STATE_MISMATCH:
$message = 'Invalid or malformed JSON';
break;
case JSON_ERROR_CTRL_CHAR:
$message = 'Control character error, possibly incorrectly encoded';
break;
case JSON_ERROR_UTF8:
$message = 'Malformed UTF-8 characters, possibly incorrectly encoded';
break;
case JSON_ERROR_SYNTAX:
$message = 'JSON syntax is malformed';
break;
default:
$message = 'Syntax error';
}
parent::__construct($message, $code, $previous);
}
}<?php








namespace JsonSchema\Exception;




class ResourceNotFoundException extends \RuntimeException
{
}<?php








namespace JsonSchema\Exception;




class UriResolverException extends \RuntimeException
{
}<?php








namespace JsonSchema;

use JsonSchema\Uri\Retrievers\UriRetrieverInterface;
use JsonSchema\Uri\UriRetriever;







class RefResolver
{







protected static $depth = 0;





public static $maxDepth = 7;




protected $uriRetriever = null;




public function __construct($retriever = null)
{
$this->uriRetriever = $retriever;
}








public function fetchRef($ref, $sourceUri)
{
$retriever = $this->getUriRetriever();
$jsonSchema = $retriever->retrieve($ref, $sourceUri);
$this->resolve($jsonSchema);

return $jsonSchema;
}







public function getUriRetriever()
{
if (is_null($this->uriRetriever)) {
$this->setUriRetriever(new UriRetriever);
}

return $this->uriRetriever;
}















public function resolve($schema, $sourceUri = null)
{
if (self::$depth > self::$maxDepth) {
return;
}
++self::$depth;

if (! is_object($schema)) {
--self::$depth;
return;
}

if (null === $sourceUri && ! empty($schema->id)) {
$sourceUri = $schema->id;
}


 $this->resolveRef($schema, $sourceUri);


 
 foreach (array('additionalItems', 'additionalProperties', 'extends', 'items') as $propertyName) {
$this->resolveProperty($schema, $propertyName, $sourceUri);
}


 
 
 foreach (array('disallow', 'extends', 'items', 'type', 'allOf', 'anyOf', 'oneOf') as $propertyName) {
$this->resolveArrayOfSchemas($schema, $propertyName, $sourceUri);
}


 foreach (array('dependencies', 'patternProperties', 'properties') as $propertyName) {
$this->resolveObjectOfSchemas($schema, $propertyName, $sourceUri);
}

--self::$depth;
}









public function resolveArrayOfSchemas($schema, $propertyName, $sourceUri)
{
if (! isset($schema->$propertyName) || ! is_array($schema->$propertyName)) {
return;
}

foreach ($schema->$propertyName as $possiblySchema) {
$this->resolve($possiblySchema, $sourceUri);
}
}









public function resolveObjectOfSchemas($schema, $propertyName, $sourceUri)
{
if (! isset($schema->$propertyName) || ! is_object($schema->$propertyName)) {
return;
}

foreach (get_object_vars($schema->$propertyName) as $possiblySchema) {
$this->resolve($possiblySchema, $sourceUri);
}
}









public function resolveProperty($schema, $propertyName, $sourceUri)
{
if (! isset($schema->$propertyName)) {
return;
}

$this->resolve($schema->$propertyName, $sourceUri);
}









public function resolveRef($schema, $sourceUri)
{
$ref = '$ref';

if (empty($schema->$ref)) {
return;
}

$refSchema = $this->fetchRef($schema->$ref, $sourceUri);
unset($schema->$ref);


 foreach (get_object_vars($refSchema) as $prop => $value) {
$schema->$prop = $value;
}
}







public function setUriRetriever(UriRetriever $retriever)
{
$this->uriRetriever = $retriever;

return $this;
}
}
<?php




namespace JsonSchema\Uri\Retrievers;






abstract class AbstractRetriever implements UriRetrieverInterface
{




protected $contentType;





public function getContentType()
{
return $this->contentType;
}
}
<?php








namespace JsonSchema\Uri\Retrievers;

use JsonSchema\Validator;






class Curl extends AbstractRetriever
{
protected $messageBody;

public function __construct()
{
if (!function_exists('curl_init')) {
throw new \RuntimeException("cURL not installed");
}
}





public function retrieve($uri)
{
$ch = curl_init();

curl_setopt($ch, CURLOPT_URL, $uri);
curl_setopt($ch, CURLOPT_HEADER, true);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_HTTPHEADER, array('Accept: ' . Validator::SCHEMA_MEDIA_TYPE));

$response = curl_exec($ch);
if (false === $response) {
throw new \JsonSchema\Exception\ResourceNotFoundException('JSON schema not found');
}

$this->fetchMessageBody($response);
$this->fetchContentType($response);

curl_close($ch);

return $this->messageBody;
}




private function fetchMessageBody($response)
{
preg_match("/(?:\r\n){2}(.*)$/ms", $response, $match);
$this->messageBody = $match[1];
}





protected function fetchContentType($response)
{
if (0 < preg_match("/Content-Type:(\V*)/ims", $response, $match)) {
$this->contentType = trim($match[1]);

return true;
}

return false;
}
}<?php








namespace JsonSchema\Uri\Retrievers;

use JsonSchema\Exception\ResourceNotFoundException;
use JsonSchema\Validator;






class FileGetContents extends AbstractRetriever
{
protected $messageBody;





public function retrieve($uri)
{
$context = stream_context_create(array(
'http' => array(
'method' => 'GET',
'header' => "Accept: " . Validator::SCHEMA_MEDIA_TYPE
)));

$response = file_get_contents($uri);
if (false === $response) {
throw new ResourceNotFoundException('JSON schema not found at ' . $uri);
}
if ($response == ''
&& substr($uri, 0, 7) == 'file://' && substr($uri, -1) == '/'
) {
throw new ResourceNotFoundException('JSON schema not found at ' . $uri);
}

$this->messageBody = $response;
if (! empty($http_response_header)) {
$this->fetchContentType($http_response_header);
} else {

 $this->contentType = null;
}

return $this->messageBody;
}





private function fetchContentType(array $headers)
{
foreach ($headers as $header) {
if ($this->contentType = self::getContentTypeMatchInHeader($header)) {
return true;
}
}

return false;
}





protected static function getContentTypeMatchInHeader($header)
{
if (0 < preg_match("/Content-Type:(\V*)/ims", $header, $match)) {
return trim($match[1]);
}
}
}
<?php

namespace JsonSchema\Uri\Retrievers;

use JsonSchema\Validator;
use JsonSchema\Uri\Retrievers\UriRetrieverInterface;













class PredefinedArray extends AbstractRetriever
{




private $schemas;







public function __construct(array $schemas, $contentType = Validator::SCHEMA_MEDIA_TYPE)
{
$this->schemas = $schemas;
$this->contentType = $contentType;
}





public function retrieve($uri)
{
if (!array_key_exists($uri, $this->schemas)) {
throw new \JsonSchema\Exception\ResourceNotFoundException(sprintf(
'The JSON schema "%s" was not found.',
$uri
));
}

return $this->schemas[$uri];
}
}<?php








namespace JsonSchema\Uri\Retrievers;






interface UriRetrieverInterface
{






public function retrieve($uri);





public function getContentType();
}<?php








namespace JsonSchema\Uri;

use JsonSchema\Exception\UriResolverException;






class UriResolver
{






public function parse($uri)
{
preg_match('|^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?|', $uri, $match);

$components = array();
if (5 < count($match)) {
$components = array(
'scheme' => $match[2],
'authority' => $match[4],
'path' => $match[5]
);
} 
if (7 < count($match)) {
$components['query'] = $match[7];
}
if (9 < count($match)) {
$components['fragment'] = $match[9];
}

return $components;
}







public function generate(array $components)
{
$uri = $components['scheme'] . '://' 
. $components['authority']
. $components['path'];

if (array_key_exists('query', $components)) {
$uri .= $components['query'];
}
if (array_key_exists('fragment', $components)) {
$uri .= '#' . $components['fragment'];
}

return $uri;
}








public function resolve($uri, $baseUri = null)
{
if ($uri == '') {
return $baseUri;
}

$components = $this->parse($uri);
$path = $components['path'];

if (! empty($components['scheme'])) {
return $uri;
}
$baseComponents = $this->parse($baseUri);
$basePath = $baseComponents['path'];

$baseComponents['path'] = self::combineRelativePathWithBasePath($path, $basePath);
if (isset($components['fragment'])) {
$baseComponents['fragment'] = $components['fragment'];
}

return $this->generate($baseComponents);
}









public static function combineRelativePathWithBasePath($relativePath, $basePath)
{
$relativePath = self::normalizePath($relativePath);
if ($relativePath == '') {
return $basePath;
}
if ($relativePath{0} == '/') {
return $relativePath;
}

$basePathSegments = self::getPathSegments($basePath);

preg_match('|^/?(\.\./(?:\./)*)*|', $relativePath, $match);
$numLevelUp = strlen($match[0]) /3 + 1;
if ($numLevelUp >= count($basePathSegments)) {
throw new UriResolverException(sprintf("Unable to resolve URI '%s' from base '%s'", $relativePath, $basePath));
}
$basePathSegments = array_slice($basePathSegments, 0, -$numLevelUp);
$path = preg_replace('|^/?(\.\./(\./)*)*|', '', $relativePath);

return implode('/', $basePathSegments) . '/' . $path;
}







private static function normalizePath($path)
{
$path = preg_replace('|((?<!\.)\./)*|', '', $path);
$path = preg_replace('|//|', '/', $path);

return $path;
}




private static function getPathSegments($path) {

return explode('/', $path);
}





public function isValid($uri)
{
$components = $this->parse($uri);

return !empty($components);
}
}
<?php








namespace JsonSchema\Uri;

use JsonSchema\Uri\Retrievers\FileGetContents;
use JsonSchema\Uri\Retrievers\UriRetrieverInterface;
use JsonSchema\Validator;
use JsonSchema\Exception\InvalidSchemaMediaTypeException;
use JsonSchema\Exception\JsonDecodingException;






class UriRetriever
{
protected $uriRetriever = null;






public function confirmMediaType($uriRetriever, $uri)
{
$contentType = $uriRetriever->getContentType();

if (is_null($contentType)) {

 return;
}

if (Validator::SCHEMA_MEDIA_TYPE === $contentType) {
return;
}

if (substr($uri, 0, 23) == 'http://json-schema.org/') {

 return true;
}

throw new InvalidSchemaMediaTypeException(sprintf('Media type %s expected', Validator::SCHEMA_MEDIA_TYPE));
}









public function getUriRetriever()
{
if (is_null($this->uriRetriever)) {
$this->setUriRetriever(new FileGetContents);
}

return $this->uriRetriever;
}














public function resolvePointer($jsonSchema, $uri)
{
$resolver = new UriResolver();
$parsed = $resolver->parse($uri);
if (empty($parsed['fragment'])) {
return $jsonSchema;
}

$path = explode('/', $parsed['fragment']);
while ($path) {
$pathElement = array_shift($path);
if (! empty($pathElement)) {
$pathElement = str_replace('~1', '/', $pathElement);
$pathElement = str_replace('~0', '~', $pathElement);
if (! empty($jsonSchema->$pathElement)) {
$jsonSchema = $jsonSchema->$pathElement;
} else {
throw new \JsonSchema\Exception\ResourceNotFoundException(
'Fragment "' . $parsed['fragment'] . '" not found'
. ' in ' . $uri
);
}

if (! is_object($jsonSchema)) {
throw new \JsonSchema\Exception\ResourceNotFoundException(
'Fragment part "' . $pathElement . '" is no object '
. ' in ' . $uri
);
}
}
}

return $jsonSchema;
}








public function retrieve($uri, $baseUri = null)
{
$resolver = new UriResolver();
$resolvedUri = $fetchUri = $resolver->resolve($uri, $baseUri);


 $arParts = $resolver->parse($resolvedUri);
if (isset($arParts['fragment'])) {
unset($arParts['fragment']);
$fetchUri = $resolver->generate($arParts);
}

$jsonSchema = $this->loadSchema($fetchUri);


 $jsonSchema = $this->resolvePointer($jsonSchema, $resolvedUri);
$jsonSchema->id = $resolvedUri;

return $jsonSchema;
}









protected function loadSchema($fetchUri)
{
if (isset($this->schemaCache[$fetchUri])) {
return $this->schemaCache[$fetchUri];
}

$uriRetriever = $this->getUriRetriever();
$contents = $this->uriRetriever->retrieve($fetchUri);
$this->confirmMediaType($uriRetriever, $fetchUri);
$jsonSchema = json_decode($contents);

if (JSON_ERROR_NONE < $error = json_last_error()) {
throw new JsonDecodingException($error);
}

$this->schemaCache[$fetchUri] = $jsonSchema;
return $jsonSchema;
}







public function setUriRetriever(UriRetrieverInterface $uriRetriever)
{
$this->uriRetriever = $uriRetriever;

return $this;
}







public function parse($uri)
{
preg_match('|^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?|', $uri, $match);

$components = array();
if (5 < count($match)) {
$components = array(
'scheme' => $match[2],
'authority' => $match[4],
'path' => $match[5]
);
}

if (7 < count($match)) {
$components['query'] = $match[7];
}

if (9 < count($match)) {
$components['fragment'] = $match[9];
}

return $components;
}







public function generate(array $components)
{
$uri = $components['scheme'] . '://'
. $components['authority']
. $components['path'];

if (array_key_exists('query', $components)) {
$uri .= $components['query'];
}

if (array_key_exists('fragment', $components)) {
$uri .= $components['fragment'];
}

return $uri;
}








public function resolve($uri, $baseUri = null)
{
$components = $this->parse($uri);
$path = $components['path'];

if ((array_key_exists('scheme', $components)) && ('http' === $components['scheme'])) {
return $uri;
}

$baseComponents = $this->parse($baseUri);
$basePath = $baseComponents['path'];

$baseComponents['path'] = self::combineRelativePathWithBasePath($path, $basePath);

return $this->generate($baseComponents);
}









private static function combineRelativePathWithBasePath($relativePath, $basePath)
{
$relativePath = self::normalizePath($relativePath);
$basePathSegments = self::getPathSegments($basePath);

preg_match('|^/?(\.\./(?:\./)*)*|', $relativePath, $match);
$numLevelUp = strlen($match[0]) /3 + 1;
if ($numLevelUp >= count($basePathSegments)) {
throw new \JsonSchema\Exception\UriResolverException(sprintf("Unable to resolve URI '%s' from base '%s'", $relativePath, $basePath));
}

$basePathSegments = array_slice($basePathSegments, 0, -$numLevelUp);
$path = preg_replace('|^/?(\.\./(\./)*)*|', '', $relativePath);

return implode('/', $basePathSegments) . '/' . $path;
}







private static function normalizePath($path)
{
$path = preg_replace('|((?<!\.)\./)*|', '', $path);
$path = preg_replace('|//|', '/', $path);

return $path;
}




private static function getPathSegments($path)
{
return explode('/', $path);
}





public function isValid($uri)
{
$components = $this->parse($uri);

return !empty($components);
}
}
<?php








namespace JsonSchema;

use JsonSchema\Constraints\SchemaConstraint;
use JsonSchema\Constraints\Constraint;

use JsonSchema\Exception\InvalidSchemaMediaTypeException;
use JsonSchema\Exception\JsonDecodingException;

use JsonSchema\Uri\Retrievers\UriRetrieverInterface;








class Validator extends Constraint
{
const SCHEMA_MEDIA_TYPE = 'application/schema+json';








public function check($value, $schema = null, $path = null, $i = null)
{
$validator = new SchemaConstraint($this->checkMode, $this->uriRetriever);
$validator->check($value, $schema);

$this->addErrors(array_unique($validator->getErrors(), SORT_REGULAR));
}
}
<?php



require_once __DIR__ . '/composer' . '/autoload_real.php';

return ComposerAutoloaderInitComposerPhar1432824732::getLoader();
<?php



$vendorDir = dirname(dirname(__FILE__));
$baseDir = dirname($vendorDir);

return array(
'Symfony\\Component\\Process\\' => array($vendorDir . '/symfony/process'),
'Symfony\\Component\\Finder\\' => array($vendorDir . '/symfony/finder'),
'Symfony\\Component\\Console\\' => array($vendorDir . '/symfony/console'),
'JsonSchema' => array($vendorDir . '/justinrainbow/json-schema/src'),
'Composer' => array($baseDir . '/src'),
);
<?php



$vendorDir = dirname(dirname(__FILE__));
$baseDir = dirname($vendorDir);

return array(
'Seld\\PharUtils\\' => array($vendorDir . '/seld/phar-utils/src'),
'Seld\\JsonLint\\' => array($vendorDir . '/seld/jsonlint/src/Seld/JsonLint'),
'Seld\\CliPrompt\\' => array($vendorDir . '/seld/cli-prompt/src'),
);
<?php



$vendorDir = dirname(dirname(__FILE__));
$baseDir = dirname($vendorDir);

return array(
);
<?php



class ComposerAutoloaderInitComposerPhar1432824732
{
private static $loader;

public static function loadClassLoader($class)
{
if ('Composer\Autoload\ClassLoader' === $class) {
require __DIR__ . '/ClassLoader.php';
}
}

public static function getLoader()
{
if (null !== self::$loader) {
return self::$loader;
}

spl_autoload_register(array('ComposerAutoloaderInitComposerPhar1432824732', 'loadClassLoader'), true, true);
self::$loader = $loader = new \Composer\Autoload\ClassLoader();
spl_autoload_unregister(array('ComposerAutoloaderInitComposerPhar1432824732', 'loadClassLoader'));

$map = require __DIR__ . '/autoload_namespaces.php';
foreach ($map as $namespace => $path) {
$loader->set($namespace, $path);
}

$map = require __DIR__ . '/autoload_psr4.php';
foreach ($map as $namespace => $path) {
$loader->setPsr4($namespace, $path);
}

$classMap = require __DIR__ . '/autoload_classmap.php';
if ($classMap) {
$loader->addClassMap($classMap);
}

$loader->register(true);

return $loader;
}
}

function composerRequireComposerPhar1432824732($file)
{
require $file;
}
<?php



$vendorDir = dirname(dirname(__FILE__));
$baseDir = dirname($vendorDir);

return array(
$vendorDir . '/phpunit/php-text-template',
$vendorDir . '/phpunit/php-timer',
);
<?php











namespace Composer\Autoload;





























class ClassLoader
{

 private $prefixLengthsPsr4 = array();
private $prefixDirsPsr4 = array();
private $fallbackDirsPsr4 = array();


 private $prefixesPsr0 = array();
private $fallbackDirsPsr0 = array();

private $useIncludePath = false;
private $classMap = array();

private $classMapAuthoritative = false;

public function getPrefixes()
{
if (!empty($this->prefixesPsr0)) {
return call_user_func_array('array_merge', $this->prefixesPsr0);
}

return array();
}

public function getPrefixesPsr4()
{
return $this->prefixDirsPsr4;
}

public function getFallbackDirs()
{
return $this->fallbackDirsPsr0;
}

public function getFallbackDirsPsr4()
{
return $this->fallbackDirsPsr4;
}

public function getClassMap()
{
return $this->classMap;
}




public function addClassMap(array $classMap)
{
if ($this->classMap) {
$this->classMap = array_merge($this->classMap, $classMap);
} else {
$this->classMap = $classMap;
}
}









public function add($prefix, $paths, $prepend = false)
{
if (!$prefix) {
if ($prepend) {
$this->fallbackDirsPsr0 = array_merge(
(array) $paths,
$this->fallbackDirsPsr0
);
} else {
$this->fallbackDirsPsr0 = array_merge(
$this->fallbackDirsPsr0,
(array) $paths
);
}

return;
}

$first = $prefix[0];
if (!isset($this->prefixesPsr0[$first][$prefix])) {
$this->prefixesPsr0[$first][$prefix] = (array) $paths;

return;
}
if ($prepend) {
$this->prefixesPsr0[$first][$prefix] = array_merge(
(array) $paths,
$this->prefixesPsr0[$first][$prefix]
);
} else {
$this->prefixesPsr0[$first][$prefix] = array_merge(
$this->prefixesPsr0[$first][$prefix],
(array) $paths
);
}
}











public function addPsr4($prefix, $paths, $prepend = false)
{
if (!$prefix) {

 if ($prepend) {
$this->fallbackDirsPsr4 = array_merge(
(array) $paths,
$this->fallbackDirsPsr4
);
} else {
$this->fallbackDirsPsr4 = array_merge(
$this->fallbackDirsPsr4,
(array) $paths
);
}
} elseif (!isset($this->prefixDirsPsr4[$prefix])) {

 $length = strlen($prefix);
if ('\\' !== $prefix[$length - 1]) {
throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
}
$this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
$this->prefixDirsPsr4[$prefix] = (array) $paths;
} elseif ($prepend) {

 $this->prefixDirsPsr4[$prefix] = array_merge(
(array) $paths,
$this->prefixDirsPsr4[$prefix]
);
} else {

 $this->prefixDirsPsr4[$prefix] = array_merge(
$this->prefixDirsPsr4[$prefix],
(array) $paths
);
}
}








public function set($prefix, $paths)
{
if (!$prefix) {
$this->fallbackDirsPsr0 = (array) $paths;
} else {
$this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;
}
}










public function setPsr4($prefix, $paths)
{
if (!$prefix) {
$this->fallbackDirsPsr4 = (array) $paths;
} else {
$length = strlen($prefix);
if ('\\' !== $prefix[$length - 1]) {
throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
}
$this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
$this->prefixDirsPsr4[$prefix] = (array) $paths;
}
}






public function setUseIncludePath($useIncludePath)
{
$this->useIncludePath = $useIncludePath;
}







public function getUseIncludePath()
{
return $this->useIncludePath;
}







public function setClassMapAuthoritative($classMapAuthoritative)
{
$this->classMapAuthoritative = $classMapAuthoritative;
}






public function isClassMapAuthoritative()
{
return $this->classMapAuthoritative;
}






public function register($prepend = false)
{
spl_autoload_register(array($this, 'loadClass'), true, $prepend);
}




public function unregister()
{
spl_autoload_unregister(array($this, 'loadClass'));
}







public function loadClass($class)
{
if ($file = $this->findFile($class)) {
includeFile($file);

return true;
}
}








public function findFile($class)
{

 if ('\\' == $class[0]) {
$class = substr($class, 1);
}


 if (isset($this->classMap[$class])) {
return $this->classMap[$class];
}
if ($this->classMapAuthoritative) {
return false;
}

$file = $this->findFileWithExtension($class, '.php');


 if ($file === null && defined('HHVM_VERSION')) {
$file = $this->findFileWithExtension($class, '.hh');
}

if ($file === null) {

 return $this->classMap[$class] = false;
}

return $file;
}

private function findFileWithExtension($class, $ext)
{

 $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;

$first = $class[0];
if (isset($this->prefixLengthsPsr4[$first])) {
foreach ($this->prefixLengthsPsr4[$first] as $prefix => $length) {
if (0 === strpos($class, $prefix)) {
foreach ($this->prefixDirsPsr4[$prefix] as $dir) {
if (is_file($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) {
return $file;
}
}
}
}
}


 foreach ($this->fallbackDirsPsr4 as $dir) {
if (is_file($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
return $file;
}
}


 if (false !== $pos = strrpos($class, '\\')) {

 $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
. strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
} else {

 $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
}

if (isset($this->prefixesPsr0[$first])) {
foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
if (0 === strpos($class, $prefix)) {
foreach ($dirs as $dir) {
if (is_file($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
return $file;
}
}
}
}
}


 foreach ($this->fallbackDirsPsr0 as $dir) {
if (is_file($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
return $file;
}
}


 if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
return $file;
}
}
}






function includeFile($file)
{
include $file;
}
<?php

if (PHP_SAPI !== 'cli') {
    echo 'Warning: Composer should be invoked via the CLI version of PHP, not the '.PHP_SAPI.' SAPI'.PHP_EOL;
}

require __DIR__.'/../src/bootstrap.php';

use Composer\Console\Application;

error_reporting(-1);

if (function_exists('ini_set')) {
    @ini_set('display_errors', 1);

    $memoryInBytes = function ($value) {
        $unit = strtolower(substr($value, -1, 1));
        $value = (int) $value;
        switch($unit) {
            case 'g':
                $value *= 1024;
                // no break (cumulative multiplier)
            case 'm':
                $value *= 1024;
                // no break (cumulative multiplier)
            case 'k':
                $value *= 1024;
        }

        return $value;
    };

    $memoryLimit = trim(ini_get('memory_limit'));
    // Increase memory_limit if it is lower than 1GB
    if ($memoryLimit != -1 && $memoryInBytes($memoryLimit) < 1024 * 1024 * 1024) {
        @ini_set('memory_limit', '1G');
    }
    unset($memoryInBytes, $memoryLimit);
}

// run the command application
$application = new Application();
$application->run();

Copyright (c) 2015 Nils Adermann, Jordi Boggiano

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

l,VÉüO9=ÎÅµVWñ^   GBMB